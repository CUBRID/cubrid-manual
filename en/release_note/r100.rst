:tocdepth: 3

.. contents::

******************
10.0 Release Notes
******************

Release Notes Information
=========================

This document includes information on CUBRID 10.0(Build No. 10.0.x.xxxx). 
CUBRID 10.0 includes all of the fixed errors and improved features that were detected in the CUBRID 9.2 and were applied to the previous versions.

For details on CUBRID 9.2 or lower, see http://www.cubrid.org/manual/92/en/release_note/index.html.

For details on CUBRID 2008 R4.3 or less, see http://release.cubrid.org/en.

Overview
========

CUBRID 10.0 is the version which stabilized and improved CUBRID 9.2.

CUBRID 10.0's DB volume is not compatible with CUBRID 9.2. Therefore, if you use CUBRID 9.2 or less, you must **migrate the database**. Regarding this, see :doc:`/upgrade`.

Improvement of Administrative Convenience
-----------------------------------------


Additions in SQL functions and statements
-----------------------------------------


Improvement of Performance
--------------------------


Stabilization in HA replication
-------------------------------



Improvements and Stabilization in Sharding Features
---------------------------------------------------


Globalization
-------------

    
Behavioral Changes
------------------


Configuration
-------------


Installation
------------


Driver Compatibility
--------------------
*   The JDBC and CCI driver of CUBRID 10.0 are compatible with the DB server of CUBRID 9.1, 9.2, 2008 R4.1, R4.3 or R4.4.

Not only the above issues, but also many issues for stability are fixed. For more details on changes, see the following. Users of previous versions should check the :ref:`changed-behaviors100` and :ref:`new-cautions100` sections.

New Features
============

Administrative Convenience
--------------------------

SQL
---

CREATE PROCECURE/FUNCTION 문에서 "OR REPLACE" 구문을 사용할 수 있게 수정(CUBRIDSUS-6542)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: sql

    CREATE FUNCTION func_or_replace(I IN NUMBER) RETURN NUMBER 
    AS LANGUAGE JAVA NAME 'sptest.testint(INT) RETURN INT';

    CREATE OR REPLACE FUNCTION func_or_replace(I IN NUMBER) RETURN NUMBER 
    AS LANGUAGE JAVA NAME 'sptest.testint(INT) RETURN INT';

    CREATE PROCEDURE proc_or_replace(I IN NUMBER) 
    AS LANGUAGE JAVA NAME 'sptest.testint2(INT)';

    CREATE OR REPLACE PROCEDURE proc_or_replace(I IN NUMBER) 
    AS LANGUAGE JAVA NAME 'sptest.testint2(INT)';
    
테이블 표현식을 감싸는 괄호를 허용하도록 수정(CUBRIDSUS-6380)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

아래 예와 같이 "(SELECT * FROM tab1) AS tab11"와 같은 테이블 표현식을 괄호로 감싸도 테이블 표현식으로 인식되도록 수정했다. 

.. code-block:: sql 

    SELECT * FROM ((SELECT * FROM tab1) AS tab11), tab0; 

수정 이전 버전에서 위의 질의를 수행하면 아래의 오류를 반환한다. 
     
:: 

    ERROR: syntax error, unexpected AS, expecting ')' 

인덱스 이름 변경이 가능하도록 수정(CUBRIDSUS-6568)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ALTER INDEX 문 또는 ALTER TABLE ... RENAME CONSTRAINT 문을 사용하여 인덱스 이름 변경이 가능하도록 수정했다. 

.. code-block:: sql 

    ALTER INDEX old_name ON table_name RENAME TO new_name; 
    ALTER TABLE table_name RENAME {CONSTRAINT|INDEX|KEY} old_name {AS|TO} new_name; 

"UPDATE tbl SET a=1, b=a" 수행 시 b의 값이 1이 될 수 있도록 수정(CUBRIDSUS-8202)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


update_use_attribute_references 시스템 파라미터를 추가하고, 이 값이 yes이면 UPDATE 문에서 명시한 칼럼 값이 해당 칼럼을 사용하는 다른 칼럼의 갱신에 영향을 주도록 수정했다. 
이 파라미터 값이 no(기본값)이면 수정 이전처럼 동작한다. 

.. code-block:: sql 

    CREATE TABLE tbl(a int, b int); 
    INSERT INTO tbl values (null, 10); 

    UPDATE tbl SET a=1, b=a; 
    SELECT * FROM tbl; 
    -- 수정 이전 버전에서는 1, 10을 반환한다. 
    -- 수정 이후 버전에서는 update_use_attribute_references 시스템 파라미터의 값이 no이면 수정 이전 버전과 같은 값을, yes이면 1,1을 반환한다. 


"CASCADE CONSTRAINTS" 절을 DROP 테이블 문장에 추가하여, 외래 키가 참조하는 기본 키를 가진 테이블의 DROP이 가능하도록 수정(CUBRIDSUS-9830)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: sql 

    CREATE TABLE a_parent ( 
        id INTEGER PRIMARY KEY, 
        name VARCHAR(10) 
    ); 
    CREATE TABLE b_child ( 
        id INTEGER PRIMARY KEY, 
        parent_id INTEGER, 
        CONSTRAINT fk_parent_id FOREIGN KEY(parent_id) REFERENCES a_parent(id) ON DELETE CASCADE ON UPDATE RESTRICT 
    ); 

    DROP TABLE a_parent CASCADE CONSTRAINTS; 
     
위의 질의를 수행하면 a_parent 테이블이 DROP되며, b_child 테이블의 외래 키 역시 DROP된다. 단, b_child 테이블의 데이터는 유지된다. 

통계 정보 갱신 시 샘플링 방식 도입(CUBRIDSUS-11962)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
통계 정보 갱신 시 샘플링 방식을 도입하여 통계 정보 갱신 시간이 단축되었다. 

수정 이후, "UPDATE STATISTICS" 문 뒤에 "WITH FULLSCAN" 구문이 없으면 샘플링된 데이터를 가지고 통계 정보를 업데이트하며, "WITH FULLSCAN"을 추가하면 전체 데이터를 가지고 통계 정보를 업데이트한다. 
  
.. code-block:: sql 
  
    UPDATE STATISTICS ON foo; 
    UPDATE STATISTICS ON foo WITH FULLSCAN; 

"CREATE TABLE IF NOT EXISTS" 구문 지원(CUBRIDSUS-12366)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: sql

    CREATE TABLE IF NOT EXISTS tbl1;

드라이버
--------

[CCI] 로그인 타임아웃 값 변경 함수 추가 및 datasource 속성 변경 함수 추가(CUBRIDSUS-12530)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
다음 함수들이 추가되었다.
 
*   cci_set_login_timeout  
 
        로그인 타임아웃을 밀리초 단위로 설정한다.
    
*   cci_get_login_timeout
 
        로그인 타임아웃 값을 반환한다.
 
    
*   cci_datasource_change_property
 
    CCI의 DATASOURCE에 대해 key에 명시한 속성(property)의 값을 val에 설정한다. 이 함수를 사용하여 변경한 속성 값은 datasource 내 모든 연결에 적용된다.
 
    
운영 편의성
-----------

DB에 지정한 질의가 정상 수행되는지 테스트해 보는 명령 추가(CUBRIDSUS-11760)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
DB에 질의 수행을 테스트해 보고 성공 여부를 출력하는 명령을 추가했다. 질의 수행 후 트랜잭션은 롤백된다. SHARD 기능이 설정된 경우, 모든 SHARD DB에 질의를 수행해 볼 수 있다. 이 명령어를 통해 DB 연결 상태, 사용자의 질의 권한, SHARD DB의 해싱 결과 등을 확인할 수 있다.

::

    cubrid broker test <broker_name> [-D <db_name>] [-u <db_user>] [-p <db_password>] {-c <query> | -i <input_file>} [-o <output_file>] [-s] [-v]

다음은 사용 예이다.
    
*   DB에 질의

    **cubrid_broker.conf의 SHARD 파라미터 값이 OFF일 때**
    
    ::
    
        $ cubrid broker test shard1 -D shard -u shard -p shard123 -c "select 1 from db_root where charset = 3"

        @ cubrid broker test
        @ [OK] CONNECT broker1 DB [demodb] USER [shard]

        @ SHARD OFF

        RESULT         ROW COUNT      EXECUTION TIME      QUERY
        ========================================================
        OK             1              0.011341 sec        select 1,'a' from db_root where charset = 3
        @ [OK] QUERY TEST
        
    **cubrid_broker.conf의 SHARD 파라미터 값이 ON일 때**

    ::
    
        $ cubrid broker test shard1 -D shard -u shard -p shard123 -c "select 1 from db_root where charset = 3"

        @ cubrid broker test
        @ [OK] CONNECT shard1 DB [shard] USER [shard]

        @ SHARD ON

        RESULT         SHARD_ID  ROW COUNT      EXECUTION TIME      QUERY
        ==================================================================
        OK             0         1              0.003436 sec        select 1 from db_root where charset = 3
        OK             1         1              0.003010 sec        select 1 from db_root where charset = 3
        OK             2         1              0.003039 sec        select 1 from db_root where charset = 3
        OK             3         1              0.002916 sec        select 1 from db_root where charset = 3
        @ [OK] QUERY TEST

*   사용자 권한 확인

    **SHARD DB 중 하나에 INSERT 권한이 없는 경우**
    
    ::
    
        $ cubrid broker test shard1 -c "insert into foo values (1,"a") " -v
        
        @ cubrid broker test
        @ [OK] CONNECT shard1 DB [shard] USER [shard]

        @ SHARD ON

        RESULT         SHARD_ID  ROW COUNT      EXECUTION TIME      QUERY
        ==================================================================
        OK             0         1              0.001322 sec        insert into foo values(1,'a')
        FAIL(-494)     -1        -1             0.001608 sec        insert into foo values(1,'a')
        <Error>
        ERROR CODE : -494
        Semantic: INSERT is not authorized on foo. insert into foo foo (foo.a, foo.b) values (1,  cast('a' as v...[CAS INFO - 127.0.0.1:52002, 1, 18145].

        OK             2         1              0.001334 sec        insert into foo values(1,'a')
        OK             3         1              0.001325 sec        insert into foo values(1,'a')
        @ [FAIL] QUERY TEST
    
    **SHARD DB 중 하나에 UPDATE 권한이 없는 경우**
    
    ::
    
        $ vi dml.txt
    
        #query
        select a from foo
        insert into foo(b) values(3)
        update foo set c = 2 where b = 3
        delete foo where b = 3
    
    ::
    
        $ cubrid broker test broker1 -D demodb -u shard -p shard123 -i dml.txt -v

        @ cubrid broker test
        @ [OK] CONNECT broker1 DB [demodb] USER [shard]

        @ SHARD OFF

        RESULT         ROW COUNT      EXECUTION TIME      QUERY
        ========================================================
        OK             1              0.001612 sec        select a from foo
        <Result of SELECT Command>
          a
        ------------
          1

        OK             1              0.001215 sec        insert into foo(b) values(3)
        FAIL(-494)     -1             0.001291 sec        update foo set c = 2 where b = 3
        <Error>
        ERROR CODE : -494
        Semantic: UPDATE is not authorized on foo. update foo foo set foo.c=2 where foo.b=3[CAS INFO - 127.0.0.1:52001, 1, 18139].

        OK             0              0.001534 sec        delete foo where b = 3
        @ [FAIL] QUERY TEST

*   SHARD HASH 정상 동작 확인

    ::
    
        $ vi test_query.txt
        
        #query
        select number from demo_db where key = /*+ shard_key */ 14
        select number from demo_db where key = /*+ shard_key */ 50
        select number from demo_db where key = /*+ shard_key */ 80
        select number from demo_db where key = /*+ shard_key */ 120
        ..

    ::
    
        $ cubrid broker test shard1 -D shard -u shard -p shard123 -i shard_key.txt -v -s

        @ cubrid broker test
        @ [OK] CONNECT shard1 DB [shard] USER [shard]

        @ SHARD ON

        RESULT         SHARD_ID  ROW COUNT      EXECUTION TIME      QUERY
        ==================================================================
        OK             0         1              0.002225 sec        select * from foo where a = /*+ shard_key */ 10
        <Result of SELECT Command>
          a           b
        ----------------------------------
          10          'aaaa'

        OK             1         1              0.001870 sec        select * from foo where a = /*+ shard_key */ 40
        <Result of SELECT Command>
          a           b
        ----------------------------------
          40          'bbb'

        OK             2         1              0.002004 sec        select * from foo where a = /*+ shard_key */ 70
        <Result of SELECT Command>
          a           b
        ----------------------------------
          70          'cccc'

        OK             3         1              0.002025 sec        select * from foo where a = /*+ shard_key */ 100
        <Result of SELECT Command>
          a           b
        ----------------------------------
          100         'dddd'

        @ [OK] QUERY TEST

HA
--

브로커가 레플리카에만 접속하도록 설정하는 파라미터 추가(CUBRIDSUS-12136)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
cubrid_broker.conf에 REPLICA_ONLY 파라미터를 추가하여, 이 값이 ON이면 레플리카에만 접속되도록 수정했다. ACCESS_MODE의 값이 RW이고 REPLICA_ONLY의 값이 ON이면 레플리카에 쓰기가 가능해진다. 

슬레이브 노드 또는 레플리카 노드에서 통계 정보 갱신이 가능해짐(CUBRIDSUS-12198)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
CUBRIDSUS-12136의 수정으로, --sysadm과 함께 --write-on-standby 옵션 사용 시 슬레이브 노드 또는 레플리카 노드에서 UPDATE STATISTICS 문의 수행이 가능해졌다. 

CAS와 DB 서버 간 복제 지연 시 다른 노드로 재접속을 시도하게 하는 기능 추가(CUBRIDSUS-11707)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
cubrid_ha.conf에 ha_delay_limit와 ha_delay_limit_delta를 추가하여 standby 서버에 ha_delay_limit 이상의 복제 지연 발생 시 CAS는 해당 DB와 연결을 끊고 다른 DB로 접속을 시도하는 기능을 추가했다. ha_delay_limit 이상의 복제 지연 발생 시 서버는 스스로 복제 지연 상태라 판단하고 복제 지연 시간이 ha_delay_limit에서 ha_delay_limit_delta를 뺀 시간 보다 낮아질 경우 복제 지연이 해소되었다고 판단한다. 

복제 지연으로 인해 우선 순위가 낮은 DB에서 연결된 CAS는 cubrid_broker.conf의 RECONNECT_TIME으로 명시한 시간이 경과하면 복제 지연이 해소되었을 것으로 기대하여, 우선 순위가 높은 standby DB 서버에 재접속을 시도한다. 

Sharding
--------


다국어
------

유틸리티
--------

"cubrid unloaddb" 명령에 DB 계정과 암호를 지정하는 옵션 추가(CUBRIDSUS-12070)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

수정 이전 버전에서는 DB 계정과 암호의 지정이 없이 "cubrid unloaddb"를 수행할 수 있어 
전체 데이터를 덤프할 수 있는 보안 문제가 존재했으나, 
"cubrid unloaddb"에 DB 계정과 암호를 지정해야만 수행 가능하도록 수정했다. 
수정 이후 버전에서 DB 계정과 암호가 지정되지 않을 경우 DB 계정은 "DBA", 암호는 빈 문자열("")이 된다.


"cubrid checkdb"에 --check-prev-link와 --repair-prev-link 옵션 추가(CUBRIDSUS-12077)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

--check-prev-link는 인덱스의 이전 링크(previous link)에 오류가 있는지를 검사하고, --repair-prev-link는 index의 이전 링크(previous link)에 오류가 있으면 복구한다. 


설정
----



.. _changed-behaviors100:

동작 변경
=========

SQL
---


다국어
------


HA
--



드라이버
--------


.. _changed-config100:

설정
----


기타
----



개선 및 오류 수정 
=================

성능 및 최적화
--------------

SHARD의 statement pool에서 statement가 재사용될 때의 성능 개선(CUBRIDSUS-11996)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

statement pool에서 statement가 재사용될 때의 성능을 개선했다. 
  
또한, SHARD_MAX_PREPARED_STMT_COUNT의 기본값을 2000에서 10000으로 늘렸다. 

테이블에 대해 다량의 DELETE가 수행되어 데이터 페이지에 빈 공간이 많아진 이후, INSERT 수행 시간이 오래 소요되는 현상(CUBRIDSUS-12405)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

하나의 테이블에 대해 많은 양의 DELETE가 발생해서 데이터 페이지에 대한 빈 공간이 많이진 이후, 여러 클라이언트들이 해당 테이블에 대해 동시에 INSERT를 수행할 때 비정상적으로 많은 시간이 소요되는 현상을 수정했다.


집계 함수와 GROUP BY 절을 포함하며 커버링 인덱스가 적용되는 질의에서 GROUP BY 절 최적화(skip group by)에 의한 인덱스 스킵 스캔이 적용되도록 수정(CUBRIDSUS-7508)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: sql

    CREATE TABLE tab (k1 int, k2 int, k3 int, v double);
    INSERT INTO tab
    SELECT
        RAND(CAST(UNIX_TIMESTAMP() AS INT)) MOD 5,
        RAND(CAST(UNIX_TIMESTAMP() AS INT)) MOD 10,
        RAND(CAST(UNIX_TIMESTAMP() AS INT)) MOD 100000,
        RAND(CAST(UNIX_TIMESTAMP() AS INT)) MOD 100000
    FROM db_class a, db_class b, db_class c, db_class d LIMIT 20000;
    CREATE INDEX idx ON tab(k1, k2, k3);
 
    SELECT /*+ recompile */ k1, k2, SUM(DISTINCT k3)          
    FROM tab 
    WHERE k2 > -1 
    GROUP BY k1, k2;

위의 예는 k1, k2 칼럼으로 GROUP BY를 수행하며 k3로 집계 함수를 수행하므로 tab(k1, k2, k3)로 구성된 인덱스가 사용되고 별도의 정렬 과정이 필요 없다. 또한 SELECT 리스트에 있는 k1, k2, k3 칼럼이 모두 tab(k1, k2, k3)로 구성된 인덱스 내에 존재하므로 커버링 인덱스가 적용된다.
    
안정성
------


SQL
---

고유 인덱스를 DROP할 때 UNQUE 키워드를 명시하지 않아도 정상 수행되도록 수정(CUBRIDSUS-9352)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
.. code-block:: sql 
  
    DROP INDEX unique_index_name ON table_name ; 
    ALTER TABLE table_name DROP INDEX unique_index_name ; 
    
LIMIT 절 또는 ORDER BY 절을 포함한 UNION ALL 질의로 생성한 뷰에 대해 SELECT 수행 시 LIMIT 절 또는 ORDER BY 절이 무시되는 현상(CUBRIDSUS-8059)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: sql 

    CREATE VIEW v11 as 
    SELECT * FROM t21 UNION ALL SELECT * FROM t22 LIMIT 1, 3; 
     
    SELECT * FROM v11; 

수정 이전 버전에서 위의 질의를 수행하면 LIMIT 1, 3이 무시된다.

예약어로 된 컬럼 이름이 "테이블 (별칭)."과 같이 사용되는 경우 이를 겹따옴표로 감싸지 않아도 질의 수행이 가능하도록 수정(CUBRIDSUS-8909)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: sql 

    CREATE TABLE tbl ("int" int, "double" double); 

수정 이전 버전에서는 아래의 질의를 수행하면 오류가 발생하지만, 수정 이후 버전에서는 정상 수행된다. 
     
.. code-block:: sql 

    SELECT t.int FROM tbl t; 

LIMIT 절을 포함하는 SELECT ... UNION 문으로 생성한 VIEW에 LIMIT가 적용되지 않는 문제(CUBRIDSUS-10265)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: sql 

    CREATE TABLE s1(i int, j int); 
    INSERT INTO s1 VALUES (1,1), (2,2), (3,3), (4,4), (5,5), (6,6), (7,7), (8,8), (9,9), (10,10); 
    CREATE VIEW v1 AS (SELECT * FROM s1 UNION SELECT * FROM s1) LIMIT 2; 

    -- 수정 이전 버전에서 아래의 질의를 수행하면 LIMIT 절이 적용되지 않아 10건의 레코드가 모두 출력된다. 
    SELECT * FROM SELECT * FROM v1;

VIEW에 LIMIT 절이 있을 때 INSERT .. ON DUPLICATE KEY UPDATE 문 수행에 실패하는 현상(CUBRIDSUS-10853)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: sql 
     
    CREATE TABLE tbl(a INT unique); 
    INSERT INTO tbl VALUES (2), (3); 

    CREATE VIEW vw AS SELECT a FROM t1 ORDER BY a LIMIT 1; 
     
    -- 수정 이전 버전에서는 아래 질의 수행 시 값이 UPDATE되지 않는다. 
    INSERT INTO vw VALUES (2) ON DUPLICATE KEY UPDATE a=1; 

카탈로그 테이블과 뷰에서 DB의 문자셋 이름, 콜레이션 이름을 확인할 수 있도록 수정(CUBRIDSUS-10948)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

시스템 테이블 _db_charset과 db_charset을 추가하여 DB의 문자셋 이름을 확인할 수 있게 되었다. 
또한 시스템 뷰 db_attribute과 db_class에 존재하던 code_set 칼럼이 제거되고, charset 칼럼이 추가되었다. 이와 함께, collation 칼럼이 추가되었다.

수정 이후 CHAR, VARCHAR, NCHAR, VARNCHAR 그리고 ENUM 타입에 대해 db_attribute 뷰의 collation 칼럼과 charset 칼럼 정보를 출력한다. 


TO_CHAR 함수에서 zerodate와 함께 리터럴 형식을 출력하도록 인자를 지정하는 경우 NULL을 반환하도록 수정(CUBRIDSUS-11880)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

zerodate에 대해 'Month', 'Day'와 같은 리터럴 형식을 지정하는 경우 NULL을 반환하도록 수정했다. 

.. code-block:: sql 

    SELECT TO_ CHAR(timestamp '0000-00-00 00:00:00', 'Month Day YYYY') 

:: 
     
    NULL 
     
참고로, 수정 이전 버전에서는 "Sunday Dec 0000"을 출력한다.

DEFAULT 속성과 SHARED 속성 간 변환 시 정상 동작하지 않는 오류(CUBRIDSUS-11135)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: sql 
     
    CREATE TABLE sharedefault( 
        sh character(1) SHARED 'a', 
        de character(1) DEFAULT 'b' 
    ); 
    -- 수정 이전 버전에서는 아래 질의를 수행해도 SHARED, DEFAULT 속성이 바뀌지 않는 오류가 존재한다. 
    ALTER TABLE sharedefault CHANGE COLUMN sh sh character(1) DEFAULT 'a'; 
    ALTER TABLE sharedefault CHANGE COLUMN de de character(1) SHARED 'b';

ALTER INDEX ... REBUILD, DROP INDEX 구문에 테이블 이름을 명시하도록 수정(CUBRIDSUS-11308)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: sql 
  
    ALTER INDEX a ON tbl_name REBUILD; 
    DROP INDEX b ON tbl_name; 


GROUP BY ... ROLLUP과 함께 LIMIT 절을 사용하면 한 행이 더 출력됨(CUBRIDSUS-11454)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 

.. code-block:: sql 

    CREATE TABLE foo (a VARCHAR(50), b VARCHAR(50), c VARCHAR(50), d VARCHAR(50)); 
    INSERT INTO foo VALUES ('1', '1', '1', 'dd'); 
    INSERT INTO foo VALUES ('1', '1', '2', 'dd'); 
    INSERT INTO foo VALUES ('2', '2', '2', 'dd'); 
    INSERT INTO foo VALUES ('1', '2', '1', 'dd'); 
    INSERT INTO foo VALUES ('1', '2', '2', 'dd'); 
    INSERT INTO foo VALUES ('2', '1', '1', 'dd'); 
    INSERT INTO foo VALUES ('2', '1', '2', 'dd'); 
    INSERT INTO foo VALUES ('2', '2', '1', 'dd'); 

수정 이전 버전에서는 아래 질의 수행 시 LIMIT 3인데 4건을 출력하는 오류가 존재한다. 
    
.. code-block:: sql 
    
    SELECT a, b, c, count(*) from foo group by a, b, c with rollup limit 3; 

::
    
      '1' '1' '1' 1 
      '1' '1' '2' 1 
      '1' '1' NULL 2 
      '1' '2' '1' 1

인덱스의 칼럼 개수가 9개 이상인 테이블의 카디널리티 출력 시 9번째 칼럼부터 항상 0으로 출력하는 문제(CUBRIDSUS-12022)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
 
수정 이전에는 인덱스 칼럼 개수가 9개 이상이면 9번째 칼럼의 카디널리티 값부터 0이 되는 문제가 존재했다. 
수정 이후에는 SHOW INDEX 문 수행 시 인덱스를 구성하는 전체 칼럼에 대한 카디널리티 정보를 출력하도록 변경했다. 
  
SHOW INDEX 문 또는 INDEX_CARDINALITY 함수를 사용하여 카디널리티 값을 출력할 수 있다. 
  
.. code-block:: sql 
     
    SHOW INDEX IN tbl; 
    SELECT INDEX_CARDINALITY('foo', 'idx1', 8); 

NULLIF 함수의 첫 번째 인자가 호스트 변수이고, NULL로 바인딩되면 DB 서버가 비정상 종료하는 현상(CUBRIDSUS-12119)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
.. code-block:: sql 
  
    PREPARE stmt FROM 'SELECT NULLIF(?, ?)'; 
    EXECUTE stmt USING NULL, '1';
    
UNION ALL이 많은 질의 또는 표현식의 중첩이 많은 질의 수행 시 DB 서버가 비정상 종료하는 현상(CUBRIDSUS-12208)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
UNION ALL이 많은 질의 또는 표현식의 중첩이 많은 질의 수행 시 DB 서버가 비정상 종료했으나, 오류 처리하도록 수정했다. 

다국어
------


분할
----


HA
--

12234  broker와 DB 사이에 발생하는 에러 세분화

broker와 DB 사이에 발생하는 핸드쉐이크(handshake) 에러 및 연결 에러를 세분화했다.

에러 원인에 따라 세분화된 에러 코드 및 에러 메시지는 다음과 같다.


*   handshake 관련 에러

    +------------------------------------------------------+----------------+-----------------------------------------------------+----------------+-----------------------------------------------------+
    | 에러 원인                                            | 기존 에러 코드 | 기존 에러 메시지                                    | 새 에러 코드   | 새 에러 메시지                                      |
    +======================================================+================+=====================================================+================+=====================================================+
    | 브로커 ACCESS_MODE와 서버의 상태 (active/standby)    | -743           | Failed on handshake between client and server.      | -1139          | Handshake error (peer host ?): incompatible         |
    | 불일치                                               |                | (peer host ?)                                       |                | read/write mode. (client: ?, server: ?)             |
    +------------------------------------------------------+                |                                                     +----------------+-----------------------------------------------------+
    | ha_delay_limit을 설정한 서버에서 복제 지연 발생      |                |                                                     | -1140          | Handshake error (peer host ?):                      |
    |                                                      |                |                                                     |                | HA replication delayed.                             |
    +------------------------------------------------------+                |                                                     +----------------+-----------------------------------------------------+
    | 레플리카만 접속 가능한 브로커(CAS)가 레플리카가      |                |                                                     | -1141          | Handshake error (peer host ?): replica-only         |
    | 아닌 서버 접속 시도                                  |                |                                                     |                | client to non-replica server.                       |
    +------------------------------------------------------+                |                                                     +----------------+-----------------------------------------------------+
    | HA maintenance 모드인 서버에 원격 접속               |                |                                                     | -1142          | Handshake error (peer host ?): remote access to     |
    |                                                      |                |                                                     |                | server not allowed.                                 |
    +------------------------------------------------------+                |                                                     +----------------+-----------------------------------------------------+
    | 서버 버전 알 수 없음                                 |                |                                                     | -1143          | Handshake error (peer host ?): unidentified         |
    |                                                      |                |                                                     |                | server version.                                     |
    +------------------------------------------------------+----------------+-----------------------------------------------------+----------------+-----------------------------------------------------+

*   연결 관련 에러

    +------------------------------------------------------+----------------+-----------------------------------------------------+----------------+-----------------------------------------------------+
    | 에러 원인                                            | 기존 에러 코드 | 기존 에러 메시지                                    | 새 에러 코드   | 새 에러 메시지                                      |
    +======================================================+================+=====================================================+================+=====================================================+
    | cub_master 프로세스 down                             | -353           | Cannot make connection to master server on  .       | -353           | Cannot make connection to master server on host ?.  |
    |                                                      |                | host ?.                                             |                |                                                     |
    +------------------------------------------------------+                |                                                     +----------------+-----------------------------------------------------+
    | 장비 down                                            |                |                                                     | -1144          | Timed out attempting to connect to ?.               |
    |                                                      |                |                                                     |                | (timeout: ? sec(s))                                 |
    +------------------------------------------------------+----------------+-----------------------------------------------------+----------------+-----------------------------------------------------+

HA 환경에서 빈번한 롤백, 커밋이 수행될 때 DB 서버가 비정상 종료되는 현상(CUBRIDSUS-12215)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
슬레이브 노드 또는 레플리카 노드에서 CSQL에 --sysadm 옵션만 사용하는 경우 DDL, INSERT 질의가 성공하지 못하도록 수정(CUBRIDSUS-12187)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
수정 이후 슬레이브 노드 또는 레플리카 노드에서 DDL, INSERT를 포함한 쓰기 질의가 성공하려면 --sysadm과 함께 --write-on-standby 옵션을 사용해야 한다.


INHERIT 절이 있는 질의의 복제에 실패하는 현상(CUBRIDSUS-11409)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: sql 

    ALTER CLASS t0004 ADD SUPERCLASS t0001,t0002,t0003 
     INHERIT col3 OF t0001, 
     col3 OF t0003 AS col3_modify_1, 
     col4 OF t0001, 
     col4 OF t0003 AS col4_modify_3, 
     ddl5 OF t0001, 
     ddl5 OF t0003 AS ddl5_modify_5; 

applylogdb가 schema 복제 반영에 실패했을 때 기록하는 로그의 형식 수정(CUBRIDSUS-11426)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

applylogdb 로그에 에러 코드 뿐만 아니라 에러 메시지를 같이 남기도록 수정했다. 
       
:: 
  
    // 수정 이전 
    log applier: failed to apply schema replication log. class: "rt2", schema: "'create class [rt2] as select * from [rt1]'", internal error: -1016. 
    log applier: failed to apply schema replication log. class: "-", schema: "'drop [rt2]'", internal error: -492. 
     
    // 수정 이후 
    log applier: failed to apply schema replication log. class: "rt2", schema: "'create class [rt2] as select * from [rt1]'", server error: -1016, POSIX external storage error: /home1/DB/tdb/lob/ces_276/rt1.00001377079956388423_2523... No such file or directory. 
    log applier: failed to apply schema replication log. class: "-", schema: "'drop [rt2]'", server error: -492, Unknown class "rt2".. 

copylogdb를 두 번 구동하는 경우 잘못된 에러 메시지가 출력됨(CUBRIDSUS-12043)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
수정 이전 버전의 HA 환경에서 copylogdb 를 두번 실행 시 아래와 같은 에러가 출력된다. 
  
:: 
  
    Server $haid@cubhost:/home1/cubrid1/DB/haid_cubhost already exists. 
  
이는 잘못된 에러 메시지이므로 아래와 같이 출력하도록 수정했다. 
  
:: 
  
    Copylogdb for haid@cubhost:/home1/cubrid1/DB/haid_cubhost already exists. 
    or 
    Applylogdb for haid@cubhost:/home1/cubrid1/DB/haid_cubhost already exists. 

HA 환경에서 copylogdb가 요청한 로그 페이지가 없는 경우 copylogdb 에러 로그에 에러 메시지를 기록하도록 수정(CUBRIDSUS-12249)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
HA 환경에서 copylogdb가 요청한 로그 페이지가 없는 경우 copylogdb와 서버의 에러 로그에 다음 메시지를 기록하도록 수정했다. 
  
:: 
  
    log writer: failed to get log page(s) starting from page id 108.

    
CAS가 특정 상황에서 일정 시간 경과 시 서버에 재연결을 시도하도록 수정(CUBRIDSUS-12042)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    CAS가 다음의 상황에서 일정 시간 경과 시 서버에 재연결을 시도하도록 수정했다. 
     
    *   PREFERRED_HOSTS가 아닌 다른 호스트에 연결한 경우 
    *   RO 브로커인데 active 서버에 연결한 경우 
     
    일정 시간은 RECONNECT_TIME(기본값: 600s) 브로커 파라미터로 명시하며, 이 값이 0이면 재연결을 시도하지 않는다. 

"cubrid broker reset"이 동작하지 않는 현상(CUBRIDSUS-11959)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
다수의 standby HA 서버 구성 (host1:host2)에서 host1의 서버 이상으로 RO/SO 브로커가 host2에 연결된 경우 host1이 서버 복구 후 "cubrid broker reset" 명령을 수행해도 host1에 재연결되지 않고 host2에 연결이 유지되는 현상을 수정했다. 

슬레이브 노드의 DB 볼륨이 마스터 노드의 DB 볼륨보다 커지는 현상(CUBRIDSUS-11994)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
슬레이브 노드의 DB 볼륨이 마스터 노드의 DB 볼륨보다 커지는 현상을 줄이기 위해, 슬레이브 노드의 복제 반영 주기(커밋 주기)가 자동으로 조절되도록 수정했다.

복제 로그를 슬레이브 노드의 DB에 반영하는 applylogdb 프로세스는 일정 시간 단위로 복제 로그에 대한 커밋을 수행하는데, 주기가 짧을수록 볼륨 재사용률이 높아져서 볼륨 크기가 불필요하게 증가하지 않게 된다. 반면, 주기가 짧아지면 복제 반영 속도가 늦어져서 복제 지연의 가능성이 높아진다. 수정 이전 버전에서는 복제 반영 주기가 고정되었으나, 수정 이후 버전에서는 복제 지연 정도를 계산하여 복제 반영 주기를 자동으로 조정한다. 

마스터 노드와 슬레이브 노드 간 방화벽이 설정되어 있는 경우 장시간 동안 트랜잭션 로그가 복사되지 않으면 DB 서버 쪽 연결이 종료되는 현상(CUBRIDSUS-12038)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

TCP 네트워크 프로토콜에 SO_KEEPALIVE 옵션을 적용하여, 위 제목의 현상으로 인해 마스터 DB에서 장애 발생 시 failover가 정상 동작하지 않을 수 있는 문제를 수정했다. 
  
또한, cubrid.conf에 tcp_keepalive 파라미터(기본값: yes)를 추가하여 TCP 네트워크 프로토콜에 SO_KEEPALIVE 옵션을 적용할지 여부를 지정할 수 있도록 수정했다. 

Sharding
--------

.. 9.3 반영 

SHARD 환경에서 CAS가 드라이버의 접속 정보를 이용하여 DB에 접속하도록 수정(CUBRIDSUS-6560)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

SHARD_DB_USER/SHARD_DB_PASSWORD 파라미터는 제거될 예정(deprecated)이므로, 수정 이후 버전에서는 응용 프로그램에서 제공하는 DB 접속 방법을 사용할 것을 권장한다. 

SHARD 환경에서 특정 시간 동안 아무런 요청이 없으면 CAS가 DB와의 접속을 끊도록 수정(CUBRIDSUS-6560)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

SHARD_PROXY_CONN_WAIT_TIMEOUT(기본값: 8시간) 브로커 파라미터를 추가하여, 이 파라미터로 명시한 시간 동안 아무런 요청이 없으면 CAS가 DB와의 접속을 끊도록 수정했다. 이 기능은 이전 비밀번호 정보를 지닌 CAS가 계속 유지되는 것을 방지한다. 

Sharding 환경에서 질의 에러 발생 시 발생한 SHARD/CAS 위치를 알 수 있도록 에러 메시지 개선(CUBRIDSUS-11968)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
Sharding 환경에서 질의 에러 발생 시 어느 SHARD/CAS에서 발생했는지 알 수 있도록 에러 메시지를 개선했다. 
  
CAS 에러 메시지의 가장 마지막에는 아래 형식의 SHARD/CAS 정보가 출력된다. 
  
:: 
  
    [SHARD/CAS ID %d,%d] 
     
드라이버 에러 메시지에는 기존의 CAS 정보 대신 PROXY 정보를 출력한다. 
  
:: 
  
    // 수정 이전 
     
    [CAS INFO %s],[SESSION - %d],[URL - %s] 
     
    // 수정 이후 
    [PROXY INFO %s],[URL - %s]

SHARD 환경에서 스키마 변경으로 인한 오류 발생 시 이후 변경된 테이블에 질의를 수행하면 잘못된 결과를 출력하거나 오류가 발생하는 현상(CUBRIDSUS-11189)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. 4.5: 9.2 P1, CUBRIDSUS-11977

SHARD 환경에서 한 응용 프로그램이 동일한 SQL 문에 대해 동시에 여러 개를 PREPARE한 후 실행하면 질의 결과가 잘못되는 현상(CUBRIDSUS-11349)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
.. code-block:: java 
  
    PreparedStatement pstmt1 = con.prepareStatement(sql); 
    PreparedStatement pstmt2 = con.prepareStatement(sql); 
     
    pstmt1.setInt(1, 2); 
    ResultSet rs1 = pstmt1.executeQuery(); 
    pstmt2.setInt(1, 4); 
    ResultSet rs2 = pstmt2.executeQuery(); 
     
    // 수정 이전 버전에서 아래를 실행하면 rs2의 결과가 섞여서 출력되는 오류가 존재한다. 
    while (rs1.next()) { 
      System.out.println(rs1.getInt(1) + " : " + rs1.getInt(2)); 
    } 

응용 프로그램에서 shard key의 입력 값 타입으로 16bit, 64bit integer를 추가로 지원하도록 수정(CUBRIDSUS-11920)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
응용 프로그램에서 shard key의 입력 값에 대한 정수형 타입으로 수정 이전에는 32bit integer만 지원했으나 수정 이후 16bit(short), 32bit(int), 64bit(INT64) integer를 모두 지원한다. 

SHARD 환경에서 SQL 주석 뒤에 개행문자가 없으면 에러가 발생하는 현상(CUBRIDSUS-11922)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

SHARD 환경에서 SQL 주석 뒤에 "\n"이 없으면 에러가 발생하는 현상을 수정했다. 
  
:: 
  
    select 1; --this is comment 

드라이버
--------

[CCI] prepare 또는 execute 함수에서 내부적인 재접속 시 login_timeout 속성이 적용되도록 수정(CUBRIDSUS-12530)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
수정 이전 버전에서는 prepare 또는 execute 함수에서 내부적인 재접속 시 로그인 타임아웃이 적용되지 않았으나 login_timeout이 설정되어 있을 경우 반영되도록 수정했다.

[CCI] shard_key가 VARCHAR인 경우 hash 함수의 결과가 모두 동일한 값이 되는 현상(CUBRIDSUS-11487)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

CCI 응용 프로그램에서 shard_key가 VARCHAR인 경우 hash 함수의 결과가 모두 동일한 값이 되어, 동일한 shard에서만 질의가 수행되는 현상을 수정했다. 
참고로, JDBC 응용 프로그램에서는 이 현상이 발생하지 않는다. 
수정된 버전에서는 shard_key가 VARCHAR인 경우의 hash 함수를 지원하지 않는다. 

[JDBC][CCI] CAS의 keepalive 패킷 전송 주기가 OS 설정을 따라가도록 수정하고, 드라이버의 소켓에 keepalive 시간을 사용하도록 수정(CUBRIDSUS-12354)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

CAS에서 사용하는 소켓의 keepalive 패킷전송 주기가 OS 설정을 따라가도록 수정했고, JDBC와 CCI드라이버의 소켓도 CAS 소켓과 동일하게 keepalive 시간을 사용하도록 수정했다. 이 수정으로 인해 드라이버와 CAS 간 방화벽에 의해 연결이 끊기는 현상이 줄어들게 되었다.

[JDBC] Datasource을 이용한 접속 시 연결 URL 문자열을 사용할 수 있도록 수정(CUBRIDSUS-12429)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

CUBRIDDataSource 클래스에 setURL 메서드를 추가하여, 연결 URL 문자열을 사용할 수 있도록 수정했다. 연결 URL 문자열에는 IP, 포트, DB 이름 뿐만 아니라 charset, logSlowQueries 등과 같이 CUBRID에서 정의한 속성(property)들을 포함할 수 있다.
 
.. code-block:: java
 
    import cubrid.jdbc.driver.CUBRIDDataSource;
    ...
    
    ds = new CUBRIDDataSource();
    ds.setUrl("jdbc:cubrid:10.113.153.144:55300:demodb:::?charset=utf8&logSlowQueries=true&slowQueryThresholdMillis=1000&logTraceApi=true&logTraceNetwork=true");
 

운영 편의성
-----------


유틸리티
--------

백업 수행 시 -B 혹은 -D 옵션으로 주어진 경로에 접근 권한이 없거나 디스크 여유 공간이 없으면 멈춰있는(hang) 현상(CUBRIDSUS-12286)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
수정 이전 버전에서 위의 현상이 발생하면 체크포인트가 실행되지 않아서 보관 로그 파일이 삭제되지 않을 수 있다. 

Windows에서 DB 생성 시 --lob-base-path 옵션 값에 "D:"와 같이 드라이브 이름을 포함하면 실패하는 현상(CUBRIDSUS-10590)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
:: 
  
    cubrid createdb testdb --lob-base-path=D:\lob_base
    
다중 키 칼럼의 인덱스가 비정상인 상태에서 "cubrid checkdb" 명령이 비정상 종료되는 현상(CUBRIDSUS-12176)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

SHARD 힌트로 인해 broker_log_top 수행 결과에서 동일한 질의가 구분되어 집계되는 현상(CUBRIDSUS-12410)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
broker_log_top 수행 시 질의 힌트를 제거한 이후에 질의 개수를 집계하도록 수정했다.

설정, 빌드 및 설치
------------------

access_ip_control_file에서 ip 주소에 0 이 포함되어 있으면 DB 서버 구동에 실패(CUBRIDSUS-12188)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**cubrid.conf** 
     
:: 
  
    access_ip_control=yes 
    access_ip_control_file=db.access 
  
수정 이전 버전에서 아래 db.access 파일의 IP 주소에 0이 포함되면 DB 서버 구동에 실패한다. 
  
**db.access** 
  
:: 
  
    [@TESTDB] 
    10.100.0.1 
    
기타
----

중복 키 오류 출력 시 인덱스 이름이 출력되지 않는 문제(CUBRIDSUS-11739)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

수정 이전 버전에서는 중복 키 오류 출력 시 인덱스 이름 대신 UNKNOWN-INDEX을 출력한다. 
  
:: 
  
    ERROR: Operation would have caused one or more unique constraint violations. INDEX *UNKNOWN-INDEX*(B+tree: 0|137|-1) ON CLASS foo(CLASS_OID: 0|522|25). key: 1(OID: 0|560|12). 
  
수정 이후 버전에서는 중복 키 오류 출력 시 인덱스 이름을 출력한다. 
     
:: 
  
    ERROR: Operation would have caused one or more unique constraint violations. INDEX u_t_i(B+tree: 0|152|830) ON CLASS foo(CLASS_OID: 0|486|13). key: 1(OID: 0|560|10). 
    
인덱스 스킵 스캔으로 질의 계획 생성할 때 비용이 inf로 잘못 출력되는 현상(CUBRIDSUS-12011)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    
Cautions
=========

.. _new-cautions100:

New Cautions
------------

DB volume of 9.2 version and 9.1 version is not compatible(CUBRIDSUS-11316)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

As the DB volume of 9.2 version and 9.1 version are not compatible, a user upgrading CUBRID 9.1 to version 9.2 should convert the existing DB volume to the DB volume of version 9.2 after installing CUBRID 9.2. For volume migration, the migrate_90_to_91 utility for version 9.2 is provided. ::

    % migrate_91_to_92 <db_name>

For details, see :doc:`/upgrade`.

.. note:: 9.1 version users should upgrade all drivers, broker, and DB server together as migrating DB volume.

DB volume of 9.2 version and the lower versions of 9.1 version are not compatible
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

As the DB volume of version 9.2 and versions lower than 9.1 are not compatible, the user should migrate the data using cubrid unloaddb/loaddb. For more details, see :doc:`/upgrade`\.

Existing Cautions
-----------------

Locale(language and charset) is specified when creating DB
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

It is changed as locale is specified when creating DB.
   
CUBRID_CHAERSET environment variable is removed
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

As locale(language and charset) is specified when creating DB from 9.2 version, CUBRID_CHARSET is not used anymore.

.. 4.4new

[JDBC] Change zero date of TIMESTAMP into '1970-01-01 00:00:00'(GST) from '0001-01-01 00:00:00' when the value of zeroDateTimeBehavior in the connection URL is "round"(CUBRIDSUS-11612)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
From 2008 R4.4, when the value of the property "zeroDateTimeBehavior" in the connection URL is "round", the  zero date value of TIMESTAMP is changed into '1970-01-01 00:00:00'(GST) from '0001-01-01 00:00:00'. You should be cautious when using zero date in your application.


Recommendation for installing CUBRID SH package in AIX(CUBRIDSUS-12251)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you install CUBRID SH package by using ksh in AIX OS, it fails with the following error. 
  
:: 
  
    0403-065 An incomplete or invalid multibyte character encountered. 
  
Therefore, it is recommended to use ksh93 or bash instead of ksh.
  
:: 
  
    $ ksh93 ./CUBRID-9.2.0.0146-AIX-ppc64.sh 
    $ bash ./CUBRID-9.2.0.0146-AIX-ppc64.sh 

CUBRID_LANG is removed, CUBRID_MSG_LANG is added
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

From version 9.1, CUBRID_LANG environment variable is no longer used.
To output the utility message and the error message, the CUBRID_MSG_LANG environment variable is used. 


Modify how to process an error for the array of the result of executing several queries at once in the CCI application(CUBRIDSUS-9364)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When executing several queries at once in the CCI application, if an error has occurs from at least one query among the results of executing queries by using the cci_execute_array function, the cci_execute_batch function, the error code of the corresponding query was returned from 2008 R3.0 to 2008 R4.1. This problem has been fixed to return the number of the entire queries and check the error of each query by using the CCI_QUERY_RESULT_* macros from 2008 R4.3 and 9.1.

In earlier versions of this modification, there is no way to know whether each query in the array is success or failure when an error occurs; therefore, it it requires certain conditions.

.. code-block:: c

    ...
    char *query = "INSERT INTO test_data (id, ndata, cdata, sdata, ldata) VALUES (?, ?, 'A', 'ABCD', 1234)";
    ...
    req = cci_prepare (con, query, 0, &cci_error);
    ...
    error = cci_bind_param_array_size (req, 3);
    ...
    error = cci_bind_param_array (req, 1, CCI_A_TYPE_INT, co_ex, null_ind, CCI_U_TYPE_INT);
    ...
    n_executed = cci_execute_array (req, &result, &cci_error);

    if (n_executed < 0)
      {
        printf ("execute error: %d, %s\n", cci_error.err_code, cci_error.err_msg);

        for (i = 1; i <= 3; i++)
          {
            printf ("query %d\n", i);
            printf ("result count = %d\n", CCI_QUERY_RESULT_RESULT (result, i));
            printf ("error message = %s\n", CCI_QUERY_RESULT_ERR_MSG (result, i));
            printf ("statement type = %d\n", CCI_QUERY_RESULT_STMT_TYPE (result, i));
          }
      }
    ...

From the modified version, entire queries are regarded as failure if an error occurs. In case that no error occurred, it is determined whether each query in the array succeeds or not.

.. code-block:: c

    ...
    char *query = "INSERT INTO test_data (id, ndata, cdata, sdata, ldata) VALUES (?, ?, 'A', 'ABCD', 1234)";
    ...
    req = cci_prepare (con, query, 0, &cci_error);
    ...
    error = cci_bind_param_array_size (req, 3);
    ...
    error = cci_bind_param_array (req, 1, CCI_A_TYPE_INT, co_ex, null_ind, CCI_U_TYPE_INT);
    ...
    n_executed = cci_execute_array (req, &result, &cci_error);
    if (n_executed < 0)
      {
        printf ("execute error: %d, %s\n", cci_error.err_code, cci_error.err_msg);
      }
    else
      {
        for (i = 1; i <= 3; i++)
          {
            printf ("query %d\n", i);
            printf ("result count = %d\n", CCI_QUERY_RESULT_RESULT (result, i));
            printf ("error message = %s\n", CCI_QUERY_RESULT_ERR_MSG (result, i));
            printf ("statement type = %d\n", CCI_QUERY_RESULT_STMT_TYPE (result, i));
          }
      }
    ...

In java.sql.XAConnection interface, HOLD_CURSORS_OVER_COMMIT is not supported(CUBRIDSUS-10800)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Current CUBRID does not support ResultSet.HOLD_CURSORS_OVER_COMMIT in java.sql.XAConnection interface.

From 9.0, STRCMP behaves case-sensitively
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Until the previous version of 9.0, STRCMP did not distinguish an uppercase and a lowercase. From 9.0, it compares the strings case-sensitively.
To make STRCMP case-insensitive, you should use case-insensitive collation(e.g.: utf8_en_ci).

.. code-block:: sql

    -- In previous version of 9.0 STRCMP works case-insensitively
    SELECT STRCMP ('ABC','abc');
    0
    
    -- From 9.0 version, STRCMP distinguish the uppercase and the lowercase when the collation is case-sensitive.
    export CUBRID_CHARSET=en_US.iso88591
    
    SELECT STRCMP ('ABC','abc');
    -1
    
    -- If the collation is case-insensitive, it distinguish the uppercase and the lowercase.
    export CUBRID_CHARSET=en_US.iso88591

    SELECT STRCMP ('ABC' COLLATE utf8_en_ci ,'abc' COLLATE utf8_en_ci);
    0

Since the 2008 R4.1 version, the Default value of CCI_DEFAULT_AUTOCOMMIT has been ON(CUBRIDSUS-5879)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The default value for the CCI_DEFAULT_AUTOCOMMIT broker parameter, which affects the auto commit mode for applications developed with CCI interface, has been changed to ON since CUBRID 2008 R4.1. As a result of this change, CCI and CCI-based interface (PHP, ODBC, OLE DB etc.) users should check whether or not the application's auto commit mode is suitable for this.

From the 2008 R4.0 version, the options and parameters that use the unit of pages were changed to use the unit of volume size(CUBRIDSUS-5136)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The options (-p, -l, -s), which use page units to specify the database volume size and log volume size of the cubrid createdb utility, will be removed. Instead, the new options, added after 2008 R4.0 Beta (--db-volume-size, --log-volume-size, --db-page-size, --log-page-size), are used.

To specify the database volume size of the cubrid addvoldb utility, use the newly-added option (--db-volume-size) after 2008 R4.0 Beta instead of using the page unit.
It is recommended to use the new system parameters in bytes because the page-unit system parameters will be removed. For details on the related system parameters, see the below.

Be cautious when setting db volume size if you are a user of a version before 2008 R4.0 Beta(CUBRIDSUS-4222)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

From the 2008 R4.0 Beta version, the default value of data page size and log page size in creating the database was changed from 4 KB to 16 KB. If you specify the database volume to the page count, the byte size of the volume may differ from your expectations. If you did not set any options, 100MB-database volume with 4KB-page size was created in the previous version. However, starting from the 2008 R4.0, 512MB-database volume with 16KB-page size is created.

In addition, the minimum size of the available database volume is limited to 20 MB. Therefore, a database volume less than this size cannot be created.

The change of the default value of some system parameters of the versions before 2008 R4.0(CUBRIDSUS-4095)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Starting from 2008 R4.0, the default values of some system parameters have been changed.

Now, the default value of max_clients, which specifies the number of concurrent connections allowed by a DB server, and the default value of index_unfill_factor that specifies the ratio of reserved space for future updates while creating an index page, have been changed. Furthermore, the default values of the system parameters in bytes now use more memory when they exceed the default values of the previous system parameters per page.

+-----------------------------+----------------------------+----------------------+--------------------+ 
| Previous System             | Added System               | Previous Default     | Changed Default    | 
| Parameter                   | Parameter                  | Value                | Value (unit: byte) |
|                             |                            |                      |                    | 
+=============================+============================+======================+====================+ 
| max_clients                 | None                       | 50                   | 100                | 
+-----------------------------+----------------------------+----------------------+--------------------+ 
| index_unfill_factor         | None                       | 0.2                  | 0.05               | 
+-----------------------------+----------------------------+----------------------+--------------------+
| data_buffer_pages           | data_buffer_size           | 100M(page size=4K)   | 512M               | 
+-----------------------------+----------------------------+----------------------+--------------------+
| log_buffer_pages            | log_buffer_size            | 200K(page size=4K)   | 4M                 | 
|                             |                            |                      |                    |
+-----------------------------+----------------------------+----------------------+--------------------+
| sort_buffer_pages           | sort_buffer_size           | 64K(page size=4K)    | 2M                 | 
|                             |                            |                      |                    | 
+-----------------------------+----------------------------+----------------------+--------------------+
| index_scan_oid_buffer_pages | index_scan_oid_buffer_size | 16K(page size=4K)    | 64K                | 
|                             |                            |                      |                    | 
+-----------------------------+----------------------------+----------------------+--------------------+

In addition, when a database is created using cubrid createdb, the minimum value of the data page size and the log page size has been changed from 1K to 4K.
 
Changed so that database services, utilities, and applications cannot be executed when the system parameter is incorrectly configured(CUBRIDSUS-5375)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

It has been changed so that now the related database services, utilities, and applications are not executed when configuring system parameters that are not defined in cubrid.conf or cubrid_ha.conf, when the value of system parameters exceed the threshold, or when the system parameters per page and the system parameters in bytes are used simultaneously.

Database fails to start if the data_buffer_size is configured with a value that exceeds 2G in CUBRID 32-bit version(CUBRIDSUS-5349)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In the CUBRID 32-bit version, if the value of data_buffer_size exceeds 2G, the running database fails. Note that the configuration value cannot exceed 2G in the 32-bit version because of the OS limit.

Recommendations for controlling services with the CUBRID Utility in Windows Vista and higher(CUBRIDSUS-4186)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

To control services using cubrid utility from Windows Vista and higher, it is recommended to start the command prompt window with administrative privileges.

If you don't start the command prompt window with administrative privileges and use the cubrid utility, you can still execute it with administrative privileges through the User Account Control (UAC) dialog box, but you will not be able to verify the resulting messages.

The procedures for starting the command prompt window as an administrator in Windows Vista and higher are as follows:

* Right-click [Start > All Programs > Accessories > Command Prompt].
* When [Execute as an administrator (A)] is selected, a dialog box to verify the privilege escalation is activated. Click “YES” to start with administrative privileges.
    
A manager server process-related error occurs in the execution of the CUBRID source after its build(CUBRIDSUS-3553)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    
If users want to build the CUBRID source and install it themselves, they must build and install CUBRID and the CUBRID Manager respectively. If you check out only CUBRID source and run cubrid service start or cubrid manager start after build, the error "cubrid manager server is not installed" will occur.


GLO class which is used in 2008 r3.0 or before is not supported any longer(CUBRIDSUS-3826)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

CUBRID 2008 R3.0 and earlier versions processed Large Objects with the Generalized Large Object glo class, but the glo class has been removed from CUBRID 2008 R3.1 and later versions. Instead, they support BLOB and CLOB (LOB from this point forward) data types. (See :ref:`blob-clob` for more information about LOB data types).

glo class users are recommended to carry out tasks as follows:

* After saving GLO data as a file, modify to not use GLO in any application and DB schema.
* Implement DB migration by using the unloaddb and loaddb utilities.
* Perform tasks to load files into LOB data according to the modified application.
* Verify the application that you modified operates normally.

For reference, if the cubrid loaddb utility loads a table that inherits the GLO class or has the GLO class type, it stops the data from loading by displaying an error message, "Error occurred during schema loading."

With the discontinued support of GLO class, the deleted functions for each interface are as follows:

+------------+----------------------------+
| Interface  | Deleted Functions          |
+============+============================+
| CCI        | cci_glo_append_data        |
|            |                            |
|            | cci_glo_compress_data      |
|            |                            |
|            | cci_glo_data_size          |
|            |                            |
|            | cci_glo_delete_data        |
|            |                            |
|            | cci_glo_destroy_data       |
|            |                            |
|            | cci_glo_insert_data        |
|            |                            |
|            | cci_glo_load               |
|            |                            |
|            | cci_glo_new                |
|            |                            |
|            | cci_glo_read_data          |
|            |                            |
|            | cci_glo_save               |
|            |                            |
|            | cci_glo_truncate_data      |
|            |                            |
|            | cci_glo_write_data         |
|            |                            |
+------------+----------------------------+
| JDBC       | CUBRIDConnection.getNewGLO |
|            |                            |
|            | CUBRIDOID.loadGLO          |
|            |                            |
|            | CUBRIDOID.saveGLO          |
|            |                            |
+------------+----------------------------+
| PHP        | cubrid_new_glo             |
|            |                            |
|            | cubrid_save_to_glo         |
|            |                            |
|            | cubrid_load_from_glo       |
|            |                            |
|            | cubrid_send_glo            |
|            |                            |
+------------+----------------------------+

Port configuration is required if the protocol between the master and server processes is changed, or if two versions are running at the same time(CUBRIDSUS-3564)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Because the communication protocol between a master process (cub_master) and a server process (cub_server) has been changed, the master process of CUBRID 2008 R3.0 or later cannot communicate with the server process of a lower version, and the master process of a lower version cannot communicate with a server process of 2008 R3.0 version or later. Therefore, if you run two versions of CUBRID at the same time by adding a new version in an environment where a lower version has already been installed, you should modify the cubrid_port_id system parameter of cubrid.conf so that different ports are used by the different versions.

Specifying a question mark when entering connection information as a URL string in JDBC(CUBRIDSUS-3217)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When entering connection information as a URL string in JDBC, property information was applied even if you did not enter a question mark (?) in the earlier version. However, you must specify a question mark depending on syntax in this CUBRID 2008 R3.0 version. If not, an error is displayed. In addition, you must specify colon (:) even if there is no username or password in the connection information. ::

    URL=jdbc:CUBRID:127.0.0.1:31000:db1:::altHosts=127.0.0.2:31000,127.0.0.3:31000 -- Error
    URL=jdbc:CUBRID:127.0.0.1:31000:db1:::?altHosts=127.0.0.2:31000,127.0.0.3:31000 -- Normal

Not allowed to include @ in a database name(CUBRIDSUS-2828)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If @ is included in a database name, it can be interpreted that a host name has been specified. To prevent this, a revision has been made so that @ cannot be included in a database name when running cubrid createdb, cubrid renamedb and cubrid copydb utilities.
