:tocdepth: 3

.. contents::

***************
9.1 릴리스 노트
***************

릴리스 노트 정보
================

본 문서는 CUBRID 9.1(빌드번호 9.1.)에 관한 정보를 포함한다.
CUBRID 9.1은 CUBRID 9.0 Beta에서 발견된 오류 수정 및 기능 개선과 CUBRID 2008 R4.3에 반영된 오류 수정 및 기능 개선을 포함한다.

CUBRID 2008 R4.3에 대한 정보는 `<http://release.cubrid.org/ko>`_ 에서 확인할 수 있다.

CUBRID 9.0 Beta에 대한 정보는 :doc:`r90`를 참조한다.

릴리스 특징
===========

CUBRID 9.1은 9.0 Beta의 안정화 버전이다.
CUBRID 9.1은  ....


보다 자세한 변경 사항은 아래의 CUBRID 9.1에서 변경된 사항을 참고한다.


기능 추가
=========

SQL
---


[검토]
^^^^^^
SHOW COLLATION 문 및 CHARSET, COLLATION, COERCIBILITY 함수(CUBRIDSUS-9404)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	콜레이션 정보를 출력하는 SHOW COLLATION 문을 추가했다.
	그리고, 지정한 문자열의 문자셋, 콜레이션, 콜레이션 변환도를 각각 반환하는 CHARSET 함수, COLLATION 함수, COERCIBILITY 함수를 추가했다.
	
[검토]
^^^^^^
주어진 범위를 균등 분할하는 WIDTH_BUCKET 함수 추가(CUBRIDSUS-4209)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	범위를 개수로 균등 분할하여 각 버킷마다 순차적으로 번호를 부여하는 WIDTH_BUCKET 함수를 추가했다. 
	범위는 최소값과 최대값으로 부여하며, 해당 범위를 균등 분할하여 버킷 번호를 순차적으로 1부터 할당한다. 

	다음 예에서 범위는 [100, 0)이며 범위에 따른 각 버킷 번호는 [100, 80)이 1, [80, 60)이 2, [60, 40)이 3, [40, 20)이 4, [20, 0)이 5가 된다.
	
	::
	
		SELECT name, score, WIDTH_BUCKET(score, 100, 0, 5) grade FROM t_score ORDER BY grade ASC, score DESC;

		  name                        score        grade
		================================================
		  'Ralph'                        99            1
		  'Jane'                         80            2
		  'James'                        75            2
		  'Peter'                        70            2
		  'Amie'                         60            3
		  'Lora'                         60            3
		  'David'                        55            3
		  'Ralph'                        30            4

[검토]
^^^^^^
행의 개수를 균등 분할하는 NTILE 분석 함수 추가(CUBRIDSUS-9688)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	행의 개수를 균등 분할하여 각 버킷마다 순차적으로 번호를 부여하는 NTILE 분석 함수를 추가했다. ::
	
		SELECT name, score, NTILE(5) OVER (ORDER BY score DESC) grade FROM t_score;

		  name                        score        grade
		================================================
		  'Ralph'                        99            1
		  'Jane'                         80            1
		  'James'                        75            2
		  'Peter'                        70            2
		  'Amie'                         60            3
		  'Lora'                         60            3
		  'David'                        55            4
		  'Ralph'                        30            5
			   
[검토]
^^^^^^
TRUNC 함수에 DATE, DATETIME, TIMESTAMP 타입을 입력 인자로 사용하는 기능 추가(CUBRIDSUS-9413)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	TRUNC 함수에 DATE, DATETIME, TIMESTAMP 타입을 입력하면 지정한 단위 미만을 절삭하여 반환하는 기능을 추가했다. ::
		
		// 다음 예에서 지정 단위는 'YYYY'이므로, 월 이하는 최소 값으로 출력된다.
		SELECT TRUNC(TO_DATE('2012-10-26'), 'YYYY');

		01/01/2012

.. 9953 참고	

[검토]
^^^^^^		
ROUND 함수에 DATE, DATETIME, TIMESTAMP 타입을 입력 인자로 사용하는 기능 추가(CUBRIDSUS-9488)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	ROUNDE 함수에 DATE, DATETIME, TIMESTAMP 타입을 입력하면 지정한 단위 미만을 반올림(rounding)하여 반환하는 기능을 추가했다. ::
	
		SELECT ROUND(datetime'2012-10-21 1:2:3', 'yyyy');

[검토]
^^^^^^			
LEAD와 LAG 분석 함수 추가(CUBRIDSUS-9414)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	한 행 내에서 다음 행과 이전 행의 칼럼 정보를 가져올 수 있는 LEAD, LAG 분석 함수를 추가했다.	::
		
		SELECT * FROM
		(
			SELECT num, title, 
			LEAD(title,1,'no next page') OVER (ORDER BY num) next_title,
			LAG(title,1,'no previous page') OVER (ORDER BY num) prev_title,
			FROM tbl_board
		) 
		WHERE num=10;

[검토]
^^^^^^
여러 개의 인덱스 힌트 지정이 가능하도록 구문 지원(CUBRIDSUS-6675)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	USE, FORCE, IGNORE 등의 인덱스 힌트를 여러 개 지정할 수 있게 되었다. ::
	
		SELECT * FROM tbl USE INDEX(idx1), IGNORE INDEX (idx2) WHERE col1 < 4;

	또한, IGNORE 힌트와 같은 기능을 하는 "USING INDEX index_name(-)" 구문을 지원하게 되었다.	 ::
		
		 SELECT * FROM tbl  WHERE col1 < 4 USING INDEX idx1(-);
		 
다국어
------


[검토]
^^^^^^
확장이 있는 콜레이션에서 액센트에 따라 역순으로 프랑스어를 정렬하는 콜레이션 지원(CUBRIDSUS-9407)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	확장이 있는 콜레이션에서 액센트에 따라 역순으로 프랑스어를 정렬하는 콜레이션(utf8_fr_exp_ab)을 지원하도록 수정했다.
	액센트에 따른 역순 프랑스어 정렬(french order)이란, 문자열 뒤에 액센트가 오는 순서를 우선으로 하여 문자열의 순서를 결정하는 것을 말한다. 가중치가 문자열의 끝에서부터 확인된다.

	::
	
		Normal Accent Ordering : cote < coté < côte < côté
		Backward Accent Ordering : cote < côte < coté < côté
		
[검토]
^^^^^^		
데이터베이스 콜레이션을 시스템 콜레이션에 맞게 변경하는 명령 추가(CUBRIDSUS-9495)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	데이터베이스 콜레이션(시스템 카탈로그 테이블에 정의된 콜레이션)을 시스템 콜레이션($CUBRID/conf/cubrid_locales.txt에 정의된 콜레이션)에 맞게 변경하는 명령이 추가되었다. ::
	 
		cubrid synccolldb testdb
	
	이와 함께, 로캘 라이브러리를 생성하는 스크립트(Linux에서는 make_locale.sh, Windows에서는 make_locale.bat) 실행 이후 기존에 생성된 데이터베이스의 콜레이션과 로캘 라이브러리의 콜레이션을 동기화하는 cubrid synccolldb를 수행할 것을 요구하는 메시지를 출력하도록 수정했다.	::
	
		To check compatibility and synchronize your existing databases, run:
			cubrid synccolldb <database-name>

	cubrid synccolldb 명령은 시스템 카탈로그 테이블에 정의된 콜레이션을 변경시킬 뿐 테이블의 콜레이션과 데이터의 문자셋을 변경하는 것은 아님을 인지해야 한다.

[검토]
^^^^^^
테이블에 대한 콜레이션 지원(CUBRIDSUS-9403)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	9.0 베타 버전에서는 컬럼에 대한 콜레이션만을 지원했으나, 9.1 버전부터 테이블에 대한 콜레이션을 지원하도록 수정했다. ::
	
		CREATE TABLE tbl(i1 INTEGER, s STRING) COLLATE utf8_en_cs;
		
Sharding
--------


Shard ID로 shard key 값을 얻는 명령 추가(CUBRIDSUS-9547)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	Shard key로 shard id를 얻는 명령을 추가했다.

	다음은 shard1이라는 shard proxy에서 shard 키 1에 대한 shard id 정보를 출력하는 명령이다. ::
	
		$ cubrid shard getid -b shard1 1
		
	-f 옵션을 통해 shard id에 대한 전체 정보를 출력할 수 있다. ::
	
		$ cubrid shard getid -b shard1 -f 1
	
Windows용 CUBRID에서 SHARD 기능 지원(CUBRISUS-9549)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	Windows용 CUBRID에서 SHARD 기능을 지원하도록 수정했다. 단, Windows용 SHARD에서는 동일 버전의 드라이버를 사용하는 응용 프로그램만이 접속 가능하다.

드라이버
--------


[CCI][JDBC] Added the load balancing functionality (CUBRIDSUS-8675)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	Added a functionality to connect an application to the main host and the hosts specified in althosts in a random order when althosts was added to the connection URL of CCI and JDBC. In the following example of a connection URL, this functionality is activated when the value of loadBalance is set to true.

	::
	
		jdbc:cubrid:host1:port1:demodb:::?althosts=host2:port2,host3:port3&loadBalance=true

[CCI]Added a function to close Resultset (CUBRIDSUS-9269)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	Different from the JDBC driver which provided two methods to close resultset and statement respectively, the CCI driver had one function, cci_close_req_handle, to close both. The cci_close_query_result function has been added to close resultset. When a new function is not called, the memory for resultset is occupied until the statement is closed. So, the memory usage may be increased.

	In the revised version, when the cci_close_req_handle function is called without calling the cci_close_query_result function, both resultset and the statement are closed like the previous version.
	
설정
----

Set whether to execute the procedure to check if the database server process and the client process that connected to the database server process, such as the broker application server, have run normally or not(CUBRIDSUS-9308)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	Added the check_peer_alive system parameter to set whether to execute the procedure to check if the database server process (cub_server) and the client process that connected to the database server process have run normally or not. The types of client processes are including the broker application server (cub_cas) process, the replication log reflection server (copylogdb), the replication log copy process (applylogdb), and the CSQL interpreter (csql).

	When a server process and a client process do not receive any response for a long time (e.g., 5 seconds or longer) while waiting for data via the network after they have been connected, they check if the opponent normally operates or not based on the configuration. If they decide that the opponent does not normally operate, they disconnect the connection by force.

	When the ECHO(7) port is blocked by the firewall configuration, the server process or the client process may mistake the opponent process as terminated. Set the parameter to none to avoid this problem.

브로커 응용 서버(CAS)의 멈춤(hang) 여부를 판단(CUBRIDSUS-7558)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	일정 비율 이상의 CAS가 멈춘(hang) 것으로 판단되면 해당 브로커로의 접속을 차단하는 기능을 추가했다. 이 기능은 ENABLE_MONITOR_HANG 파라미터를 ON으로 설정할 때 동작한다.
	
	브로커 프로세스는 CAS의 멈춤(hang)이 1분 이상 지속되는 경우 CAS를 멈춘(hang) 상태로 판단하고, 해당 CAS의 개수에 따라 해당 브로커 프로세스가 비정상으로 판단되면 정상화되기 전까지 해당 브로커로 접속을 시도하는 응용 프로그램을 차단하여, 접속 URL에 설정한 대체 호스트(altHosts)로의 접속을 유도한다.

모니터링
--------

Improved to output the replication delay information (CUBRIDSUS-9525)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	Improved to output the replication delay information when copying the transaction logs and outputting the transaction log reflection information by using the applylogdb command in the HA environment. The following example shows how to output the replication delay information:

	::

		% cubrid applyinfo -L /home/cubrid/DB/testdb_nodeA -r nodeA -a -i 3 testdb

		...

		*** Delay in Copying Active Log *** 
		Delayed log page count         : 4
		Estimated Delay                : 0 second(s)

		 *** Delay in Applying Copied Log *** 
		Delayed log page count         : 1459
		Estimated Delay                : 22 second(s)


Added a functionality to output the query execution status of transactions(CUBRIDSUS-9588)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	Added a functionality to output the query execution status of transactions to cubrid killtran with –q(--query-exec-info) option.

	::
	
		% cubrid killtran -q testdb
		Tran index  Process id  Program name  Query time   Tran timeWait for lock holder      SQL Text
		-------------------------------------------------------------------------------------------------------------------------------------------------------------------
			  1(+)     22982   b1_cub_cas_1        0.00       0.00                    -1         *** empty ***
			  2(+)     22983   b1_cub_cas_2        1.80       1.80                     1         update [ta] [ta] set [a]=5 wh
		-------------------------------------------------------------------------------------------------------------------------------------------------------------------
		The status of a query execution includes the following information:

	* Tran index: Transaction index
	* Process id: Client process ID
	* Program name: Client program name
	* Query time: Total execution time of a query being executed (unit: seconds)
	* Tran time: Total execution time of the current transaction (unit: seconds)
	* Wait for lock holder: The list of transactions which hold the lock when the current transaction is in lock waiting
	* SQL Text: The query statement being executed (up to 30 characters)

트랜잭션 정보를 출력하는 별도의 유틸리티 추가(CUBRIDSUS-9601)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	데이터베이스의 트랜잭션 정보를 출력하는 유틸리티인 cubrid tranlist를 추가했다. DBA 또는 DBA 그룹 사용자만 이 명령을 수행할 수 있다.
	
	::
	
		$ cubrid tranlist -s testdb
		
		Tran index         User name      Host name      Process id          Program name
		-------------------------------------------------------------------------------
		   1(ACTIVE)         PUBLIC        myhost            1822           broker1_cub_cas_1
		   2(ACTIVE)            dba        myhost            1823           broker1_cub_cas_2
		   3(COMMITTED)         dba        myhost            1824           broker1_cub_cas_3
		-------------------------------------------------------------------------------

특정 SQL을 수행 중인 트랜잭션을 제거하는 기능(CUBRIDSUS-9653)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	killtran 명령으로 특정 SQL ID를 통해 특정 트랜잭션을 제거하는 기능을 추가했다.
	
	::
	
		$ cubrid killtran --query-exec-info testdb
	
			Tran index     Process id    Program name              Query time    Tran time              Wait for lock holder      SQL_ID       SQL Text
		--------------------------------------------------------------------------------------------------------------------------------------------------
			  1(+)          26650    query_editor_cub_cas_1          0.00         0.00                              -1     *** empty ***
			  2(+)          26652    query_editor_cub_cas_3          0.00         0.00                              -1     *** empty ***
			  3(+)          26651    query_editor_cub_cas_2          0.00         0.00                              -1     *** empty ***
			  4(+)          26653    query_editor_cub_cas_4          1.80         1.80                         2, 1, 3     cdcb58552e320   update [ta] [ta] set [ta].[a]=
		--------------------------------------------------------------------------------------------------------------------------------------------------

		SQL_ID: cdcb58552e320
		Tran index : 4
		update [ta] [ta] set [ta].[a]= ?:1  where ([ta].[a]> ?:0 )

		$ cubrid killtran --kill-sql-id=cdcb58552e320 -f testdb	
		
Added a function to log the query statements which exceeded the specified time and the query execution plan information to a log(CUBRIDSUS-6987)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	With the system parameter sql_trace_slow_msecs, added a function to log the query statements which exceeded the specified time and the query execution plan information to a log. When the value of the system parameter sql_trace_execution_plan is yes, the SQL statement, query execution plan, and the cubrid statdump information are recorded in the server error log file and the broker application server (CAS) log file. When the cubrid plandump is executed, the corresponding SQL statement and the query execution plan are output.

	However, the corresponding information is recorded in the server error log file only when the value of the error_log_level parameter is NOTIFICATION.


브로커 및 샤드의 실행중인 파라미터 정보를 확인하는 명령 추가(CUBRIDSUS-7771)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	브로커의 실행 중인 파라미터 정보를 확인하는 "cubrid broker info", "cubrid shard info" 명령을 추가했다.

기타
----


브로커 로그 변환 명령 및 브로커 로그 실행 명령에 기능 추가(CUBRIDSUS-8804)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	브로커 로그 변환 명령인 broker_log_converter에 질의문 앞에 질의 ID 커멘트를 출력하는 -i 옵션을 추가했다.
	broker_log_converter 에 의해서 변환된 출력 파일을 가지고 질의를 재수행하는 명령인 broker_log_runner에 질의 당 statdump 정보를 출력하는 -s, 자동 커밋 모드로 질의를 실행하게 하는 -a 옵션을 추가했다.

여러 개의 트랜잭션을 한꺼번에 강제 종료하는 기능 추가(CUBRIDSUS-9601)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	killtran의 -i 옵션에 강제 종료하고자 하는 트랜잭션 ID들을 쉼표로 구분하여 입력할 수 있게 수정했다.
	
	::
		
		cubrid killtran -i ID1,ID2,ID3, ... testdb

동작 변경
=========

SQL
---


[검토]
^^^^^^
두 개 이상의 문자열 인자가 요구되는 SQL 함수에서 입력 인자가 어느 한 쪽으로 변환이 가능한 콜레이션인 경우에만 함수 수행이 가능하도록 수정(CUBRIDSUS-9920)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	IF, CASE, DECODE, FIELD 함수 등에서 두 개 이상의 인자가 입력되면 어느 한 쪽으로 변환이 가능한 콜레이션인 경우에만 함수 수행이 가능하도록 수정했다.
	
	입력 인자의 콜레이션이 바이너리인 경우는 호환이 가능하다. utf8_bin 문자열과 iso88591_bin 문자열이 입력되면 utf8_bin 문자열은 iso88591_bin 문자셋으로 변환된다. ::
	
		SELECT IF(1, _utf8'a', _iso88591'b'), CHARSET(IF(1, _utf8'a', _iso88591'b'));
		
		   if(1<>0, _utf8'a', 'b')   charset( if(1<>0, _utf8'a', 'b'))
		============================================
		  'a'                   'iso88591'		
		
	입력 인자의 콜레이션이 바이너리가 아닌 경우는 어느 한 쪽으로 변환 가능하지 않으므로 오류가 발생한다. ::
	
		SELECT * FROM t1 
		WHERE IF(id%2, _utf8'a' collate utf8_en_cs, _utf8'b' collate utf8_en_ci) = concat(a, '');
		
		ERROR: before '  = concat(a, ''); '
		'if ' requires arguments with compatible collations.

다국어
------


[검토]		
^^^^^^ 
콜레이션 변환도 변경(CUBRIDSUS-10057)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	높은 변환도가 낮은 변환도의 콜레이션으로 변환되는 정도를 나타내는 콜레이션 변환도(coercibility level)가 다음 표와 같이 변경되었다. 특히, 바이너리 콜레이션은 변환도를 낮추어, 호스트 변수와 문자열 상수에 대한 LIKE 질의 시 결과가 서로 불일치되는 현상을 해결했다.

	::
	
		CREATE TABLE tbl(s STRING COLLATE utf8_bin);
		INSERT INTO tbl VALUES('bbb');
		SET NAMES utf8 COLLATE utf8_gen_ci;

		// 아래 질의는 정상적으로 1건을 출력한다.
		SELECT * FROM t WHERE s LIKE '_B_';

		// 아래 질의는 수정 이전 버전에서 0건을 출력하며, 새 버전에서 정상적으로 1건을 출력한다.
		PREPARE st from 'SELECT * FROM tbl WHERE s LIKE ?';
		EXECUTE st USING '_B_';

	+------------------------+------------------------------------------------------------------------------------+
	| **콜레이션 변환도**    |  **표현식의 인자(피연산자)**                                                       |
	+========================+====================================================================================+
	| 0                      | COLLATE 수정자를 지닌 피연산자                                                     |
	+------------------------+------------------------------------------------------------------------------------+
	|                        | **칼럼** 이                                                                        |
	|                        |                                                                                    |
	| 1                      | 바이너리가 아닌(non-binary) 콜레이션을 가진 경우                                   |
	|                        |                                                                                    |
	| 2                      | ISO-8859-1 문자셋을 가진 경우를 제외하고 바이너리 콜레이션을 가진 경우             |
	|                        |                                                                                    |
	| 3                      | 바이너리 콜레이션과 ISO-8859-1 문자셋(iso88591_bin)을 가진 경우                    |
	+------------------------+------------------------------------------------------------------------------------+
	|                        | **SELECT 값**, **표현식** 이                                                       |
	|                        |                                                                                    |
	| 4                      | 바이너리가 아닌 콜레이션을 가진 경우                                               |
	|                        |                                                                                    |
	| 5                      | ISO-8859-1 문자셋을 가진 경우를 제외하고 바이너리 콜레이션을 가진 경우             |
	|                        |                                                                                    |
	| 6                      | 바이너리 콜레이션과 ISO-8859-1 문자셋(iso88591_bin)을 가진 경우                    |
	+------------------------+------------------------------------------------------------------------------------+
	| 7                      | **특수 함수들** (:func:`USER`, :func:`DATABASE`, :func:`SCHEMA`, :func:`VERSION`)  |
	|                        |                                                                                    |
	+------------------------+------------------------------------------------------------------------------------+
	|                        | **상수 문자열** 이                                                                 |
	|                        |                                                                                    |
	| 8                      | 바이너리가 아닌(non-binary) 콜레이션을 가진 경우                                   |
	|                        |                                                                                    |
	| 9                      | ISO-8859-1 문자셋을 가진 경우를 제외하고 바이너리 콜레이션을 가진 경우             |
	|                        |                                                                                    |
	| 10                     | 바이너리 콜레이션과 ISO-8859-1 문자셋(iso88591_bin)을 가진 경우                    |
	+------------------------+------------------------------------------------------------------------------------+
	| 11                     | 호스트 변수, 사용자 정의 변수                                                      |
	+------------------------+------------------------------------------------------------------------------------+

[검토]
^^^^^^
바이너리가 아닌 콜레이션 문자열로 테이블을 해시 분할 시 정상적으로 분할되지 않는 현상으로 인해 이를 허용하지 않도록 수정(CUBRIDSUS-10156)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	바이너리(non-binary)가 아닌 콜레이션 문자열을 사용하여 테이블 해시 분할(hash partioning) 시 정상적으로 분할되지 않는 현상이 존재했으며, 이 경우 테이블 해시 분할(hash partioning)을 허용하지 않도록 수정했다. 바이너리가 아닌 콜레이션 문자열을 사용한 테이블 해시 분할(hash partioning)은 이후 버전에서 지원할 예정이다.
	
	::
	
		SET NAMES utf8 COLLATE utf8_de_exp_ai_ci; 
		
		// 수정 이후 버전에서는 아래의 테이블 생성을 허용하지 않는다.
		CREATE TABLE t2 ( code VARCHAR(10)) collate utf8_de_exp_ai_ci PARTITION BY HASH (code) PARTITIONS 4;
		INSERT INTO t2(code) VALUES ('AE');
		INSERT INTO t2(code) VALUES ('ae');
		INSERT INTO t2(code) VALUES ('Ä');
		INSERT INTO t2(code) VALUES ('ä');
		
		// 수정 이전 버전에서 아래 질의 수행 시 'ä'와 'Ä' 두 개의 행을 출력해야 하나 4개의 행을 출력하는 문제가 존재한다.
		SELECT * FROM t2 WHERE code='ä';
		
드라이버
--------

[JDBC][CCI]Modified to commit whenever a function which executed several query statements in the array at once executes each query statement in the auto commit mode(CUBRIDSUS-6148)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	In the auto commit mode, when the cci_execute_array function and the cci_execute_batch function, and the Statement.executeBatch method and the PreparedStatement.executeBatch method of JDBC have processed several query statements in the array at once, commit has been executed after executing all query statements. It was fixed to commit whenever each query statement is executed.

[JDBC]Problem in which only the BIT type values were allowed as binding the values for the PreparedStatement object by using the setBoolean method in JDBC(CUBRIDSUS-9205)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	There was a problem in which only the BIT type values were allowed as binding the values for the PreparedStatement object by using the setBoolean method in JDBC. Now, the BIT type values are excluded but all numeric types such as SMALLINT, INTEGER, BIGINT, DECIMAL, REAL, DOUBLE, and MONETARY or all character types such as CHAR and VARCHAR can be bound.


[CCI]Modified the way to process an error for the array of the result of executing several queries at once in the CCI application(CUBRIDSUS-9364)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	When executing several queries at once in the CCI application, if an error has occurs from at least one query among the results of executing queries by using the cci_execute_array function, the cci_execute_batch function, the error code of the corresponding query was returned from 2008 R3.0 to 2008 R4.1. This problem has been fixed to return the number of the entire queries and check the error of each query by using the CCI_QUERY_RESULT_* macros from 2008 R4.3 version.

	In regard to this, the CCI_QUERY_RESULT_ERR_NO macro to check the error number of a specific query failed among the entire query results has been added, and the error identifiers (CAS error -1 and DBMS error -2) have been added to the return value of the CCI_QUERY_RESULT_RESULT macro.

[CCI]cci_property_set 함수 또는 cci_connect_with_url 함수에서 DB 사용자와 암호 설정 시 동작 방식 변경(CUBRIDSUS-9393)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	cci_property_set 함수로 DATASOURCE에 대한 DB 사용자와 암호 설정 시 또는 cci_connect_with_url 함수에 DB 사용자 인자와 암호 인자 값 설정 시 동작 방식을 통일했다. 수정 이후 다음과 같이 동작한다.
	
	* 인자와 URL에 둘다 값이 지정되면 인자의 값이 우선한다.
	* 둘 중 하나가 NULL이면 NULL이 아닌 값이 사용된다.
	* 둘 다 NULL이면 NULL 값으로 사용된다.
	* DB 사용자 인자 값이 NULL이면 "public", 암호 인자 값이 NULL이면 NULL로 설정된다.
	* 암호 인자 값이 NULL이면 URL의 설정을 따른다.
	
	수정 이전 버전에서 cci_property_set 함수로 DATASOURCE에 대한 DB 사용자와 암호 설정 시 DB 사용자 인자는 반드시 설정해야 되며, 암호 인자를 설정하지 않으면 NULL로 인식했다. 또한, 암호 인자가 NULL이면 URL의 암호를 사용했다.
	
	수정 이전 버전에서 cci_connect_with_url 함수에 DB 사용자와 암호 설정 시 DB 사용자 인자가 NULL이면 "public"으로 지정되었으며, 암호 인자가 NULL이면 URL의 암호를 사용했다.

기본 설정 변경  
--------------


시스템 파라미터 sort_buffer_size의 최대 크기를 2G로 제한(CUBRIDSUS-9582)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	시스템 파라미터인 sort_buffer_size의 최대 크기를 2G로 제한했다. 수정 이전 버전에서 sort_buffer_size의 크기를 2G보다 크게 설정하는 경우, 인덱스 생성과 같은 정렬이 필요한 작업에서 2G보다 큰 sort_buffer를 사용하게 되면 해당 작업이 비정상 종료되었다.

브로커 파라미터 KEEP_CONNECTION에서 OFF 값 설정 제거(CUBRIDSUS-5316)	
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	브로커 파라미터 KEEP_CONNECTION에서 OFF 값 설정을 제거했다. 2008 R4.x 이하 버전에서 해당 파라미터의 값을 OFF로 설정하면 사용자 정의 변수, LAST_INSERT_ID, ROW_COUNT, PREPARE 문이 정상 수행되지 않는다.

CUBRID_LANG 환경 변수 제거 및 이를 대체하는 환경 변수 추가(CUBRIDSUS-9719)(CUBRIDSUS-9468)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	CUBRID_LANG 환경 변수를 제거하고 데이터베이스 문자셋을 설정하는 CUBRID_CHARSET 환경 변수 및 유틸리티 메시지 및 오류 메시지에 대한 문자셋을 설정하는 CUBRID_MSG_LANG 환경 변수를 추가했다.

브로커 파라미터 SELECT_AUTO_COMMIT 제거(CUBRIDSUS-9326)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	자동 커밋 모드가 OFF인 상황에서도 SELECT 문에 대해서만 자동 커밋이 가능하게 설정하는 브로커 파라미터 SELECT_AUTO_COMMIT를 제거했다. 

CAS 프로세스의 최대 메모리 사용량을 정의하는 파라미터들의 값에 따른 동작 방식 수정(CUBRIDSUS-10260)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	브로커 파라미터 APPL_SERVER_MAX_SIZE_HARD_LIMIT의 값의 범위를 1과 2,097,151 사이의 값으로 제한하고 이를 벗어나는 경우 브로커 구동을 하지 못하도록 수정했다.
	이와 함께 broker_changer를 이용해서 APPL_SERVER_MAX_SIZE_HARD_LIMIT의 값을 APPL_SERVER_MAX_SIZE보다 작게 변경하면 경고 메시지를 출력하도록 수정했다. 

call_stack_dump_activation_list 파라미터 지정에 따른 동작 방식 변경 (CUBRIDSUS-9836)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	cubrid.conf의 call_stack_dump_activation_list 파라미터 지정에 따른 동작 방식이 변경되었다.
	
		* call_stack_dump_activation_list의 값을 지정하면 기본적으로 설정되던 오류 번호들이 있었으나 지정한 값에 대해서만 오류 번호가 설정되도록 수정했다.
		* call_stack_dump_activation_list의 값으로 DEFAULT 키워드를 지정할 수 있게 수정했다. DEFAULT 키워드는  "-2, -7, -13, -14, -17, -19 , -21, -22, -45, -46, -48, -50, -51, -52, -76, -78, -79, -81, -90, -96, -97, -313, -314, -407, -414, -415, -416, -417, -583, -603, -836, -859, -890, -891, -976, -1040, -1075"으로 대체된다.
	
	call_stack_dump_activation_list의 값을 지정하지 않으면 기존처럼 "-2, -7, -13, -14, -17, -19 , -21, -22, -45, -46, -48, -50, -51, -52, -76, -78, -79, -81, -90, -96, -97, -313, -314, -407, -414, -415, -416, -417, -583, -603, -836, -859, -890, -891, -976, -1040, -1075"이 기본으로 설정된다.

SQL 로그 파일 크기를 지정하는 브로커 파라미터의 기본 설정값을 100MB에서 10MB로 줄임(CUBRIDSUS-9944)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	cubrid_broker.conf의 SQL_LOG_MAX_SIZE의 기본 설정값을 100MB에서 10MB로 줄였다. 기존 버전 사용자가 새 버전으로 업그레이드 한 이후에도 기존과 동일한 양의 SQL 로그를 남기고 싶다면 SQL_LOG_MAX_SIZE의 값을 100,000(단위: KB)으로 설정해야 한다.

HA 기능
-------


HA 환경에서 특정 노드가 to-be-active 상태인 경우 SELECT 문을 처리할 수 있도록 수정(CUBRIDSUS-8896)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	HA 환경에서 특정 노드가 to-be-active 상태인 경우 SELECT 문을 처리할 수 있도록 수정했다.

기타
----


브로커의 상태 출력 개선 및 변경(CUBRIDSUS-9602)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	cubrid broker status 명령을 통해 브로커의 상태를 출력할 때 아래와 같이 몇 가지 사항이 추가 또는 변경되었다.
 
	* 브로커의 SERVICE 파라미터 값을 ON으로 설정하면 구동 중인 브로커의 상태만 출력하게 되었다. ::
 
		cubrid broker status SERVICE=ON
		
	* -b 옵션으로 브로커 상태 출력 시
		* 브로커 이름은 최대 20자까지만 출력하고, 이를 초과하는 경우 이름 뒤에 ...을 출력하게 되었다.	
		* REQ 항목은 출력하지 않게 되었다.
		* QPS, TPS 항목 출력 시 UINT64 최대 값까지 출력하게 되었다. 수정 이전에는 해당 항목이 음수로 출력되는 경우가 존재했다.
		* 브로커 응용 서버(CAS) 별 응용 프로그램 연결 개수의 합을 출력하는 #CONNECT가 추가되었다.
		* 질의 종류 별 수행 회수를 출력하는 SELECT, INSERT, UPDATE, DELETE, OTHERS 항목을 추가하게 되었다. 단, -f 옵션이 있는 경우는 해당 항목들이 출력되지 않는다.
		* 고유 키 위반 오류 회수를 출력하는 UNIQUE-ERR-Q 항목이 추가되었다.
		
	* -b 옵션 없이 브로커 상태 출력 시
		* STATUS 항목 출력 시 "CLIENT WAIT", "CLOSE WAIT"가 각각 "CLIENT_WAIT", "CLOSE_WAIT"로 출력되도록 변경되었다.			
		* 브로커 설정 정보가 출력에서 제외되었다.
		
	* -l 옵션 사용 시 상태가 "CLOSE_WAIT"인 CAS의 정보는 출력에서 제외하게 되었다.
 			
개선 및 오류 수정 
=================

성능 및 리소스 
--------------


Added a function to limit the disk output volume to reduce the affect caused by adding the database volume on system operation (CUBRIDSUS-9521)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	Added a function to limit the disk output volume to reduce the effect caused by adding the database volume on system operation. This function uses the --max_writesize-in-sec option to the addvoldb command and specifies the volume size used per second.

	::
	
		% cubrid addvoldb -C --db-volume-size=2G --max-writesize-in-sec=1M testdb

질의 결과 정렬 시 필요한 메모리 사용 공간을 보다 정확히 예측하도록 개선(CUBRIDSUS-1339)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	질의 결과 정렬 시 필요한 메모리 사용 공간을 보다 정확히 예측하여 디스크를 사용해야 하는 외부 정렬(external sorting)의 가능성을 줄이도록 개선했다.

브로커 응용 서버(CAS)를 최대 접속 개수까지 구동하는데 소요되는 시간 개선(CUBRIDSUS-9067)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	브로커를 구동하면 처음에는 브로커 파라미터 MIN_NUM_APPL_SERVER 값만큼 CAS가 구동되어 있으며, 해당 CAS와 접속하는 응용 프로그램의 개수가 늘어나면서 최대 MAX_NUM_APPL_SERVER 값까지 CAS가 구동된다. 이때, MIN_NUM_APPL_SERVER부터 MAX_NUM_APPL_SERVER까지 CAS가 구동되는데 소요되는 시간을 개선했다.
	
	예를 들어 MIN_NUM_APPL_SERVER이 100이고 MAX_NUM_APPL_SERVER가 400일 때, 접속을 400개까지 늘리면 브로커가 101번째 접속부터 CAS를 400개까지 하나씩 늘어 나는데, 기존에는 30초가 소요되었으나 수정 이후 3초로 줄어들었다.

INSERT/DELETE 반복 수행 시 DELETE 성능 저하 개선(CUBRIDSUS-5222)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	INSERT/DELETE 반복 수행 시 DELETE 수행 시간이 점점 증가했으나 INSERT/DELETE 반복 수행 이후에도 초기 DELETE와 비슷한 수행 시간을 유지하도록 개선했다.

오버플로우 페이지가 존재하는 데이터베이스에 대한 DELETE 성능 개선(CUBRIDSUS-5878)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

TRUNCATE 테이블 반복 수행 또는 인덱스 재생성 반복 수행 이후 INSERT 작업의 성능 저하 현상(CUBRIDSUS-6501)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	TRUNCATE 테이블 반복 수행 또는 인덱스 재생성 반복 수행 이후 INSERT 작업에서 나타나는 성능 저하 현상을 개선했다.

[검토]
^^^^^^
일시적 임시 볼륨을 불필요하게 할당하는 공간이 증가하는 현상(CUBRIDSUS-9772)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	인덱스 생성이나 SELECT 수행 시 정렬 대상 데이터의 크기가 매우 커서 디스크를 이용하는 외부 정렬(external sorting)을 수행하는 과정에서, 일시적 임시 볼륨을 불필요하게 할당하는 공간이 증가하는 현상을 수정했다.

서버 비정상 종료 이후 재시작 시 일시적 임시 볼륨이 제거되지 않는 문제(CUBRIDSUS-10195)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

주기적으로 샤드 상태 정보를 출력하는 명령 수행 시 메모리 사용량이 증가하는 현상(CUBRIDSUS-10393)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	주기적으로 샤드 상태 정보를 출력하는 "cubrid shard status -c -s 1" 명령 수행 시 메모리 누수로 인해 메모리 사용량이 증가하는 현상을 수정했다.

SQL
---


다중 왼쪽 조인 질의에 WHERE 절 조건이 있으면 잘못된 질의 결과를 출력하는 문제(CUBRIDSUS-8867) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	다중 왼쪽 조인 질의에 WHERE 절 조건이 있으면 잘못된 질의 결과를 출력하는 문제를 수정했다. ::
		SELECT *
		FROM tblA LEFT JOIN tblB on tblA.pkey=tblB.pkey
		left join tblC on tblC.p2key=tblB.p2key
		left join tblD on tblD.p3key=tblC.p3key 
		WHERE tblD.p3key=4;
		
[검토]
^^^^^^
CLOB_TO_CHAR 함수의 인자에 문자셋을 지정할 수 있도록 개선(CUBRIDSUS-9467)	
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	::
		CLOB_TO_CHAR(col_clob USING utf8);

[검토]
^^^^^^
UPDATE JOIN 또는 DELETE JOIN 시 힌트 지원하도록 개선(CUBRIDSUS-9491)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	UPDATE JOIN 또는 DELETE JOIN 시 ORDERED, USE_DESC_IDX, NO_COVERING_INDEX, NO_DESC_IDX, USE_NL, USE_IDX, USE_MERGE, NO_MULTI_RANGE_OPT, RECOMPILE와 같은 힌트를 지원하도록 개선했다.
		
[검토]
^^^^^^
분석 함수에서 PARTITION BY 절 뒤에 상수가 아닌 표현식이 올 때 오류 발생(CUBRIDSUS-9579)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	분석 함수에서 PARTITION BY 절 뒤에 상수가 아닌 표현식이 올 때 오류가 발생하는 문제를 수정했다. ::
	
		SELECT v.a, ROW_NUMBER() over(PARTITION BY 1 + 0) r
		FROM (VALUES (1), (2), (3)) v (a)

	수정 이전 버전에서는 아래의 오류가 발생한다. ::

		Semantic: System error (generate order_by) in ..\..\src\parser\xasl_generation.c (line: 5466) 
		select [v].[a], row_number() over (partition by 1+0) from (values (1),(2),(3)) [v] ([a]) 
		where (rownum>= ?:0  and rownum<= ?:1 )?171="en_US";172="en_US";

	수정 이후, 분석 함수의 OVER 절 뒤에 함께 사용되는  ORDER BY 절 뒤에 오는 표현식에 따른 동작 방식은 다음과 같다.
	PARTITION BY 절의 동작 방식도 ORDRE BY 절과 동일하다.
		
	* ORDER BY 상수 (예: 1): 상수는 SELECT 리스트의 칼럼 위치로 다루어짐.
	* ORDER BY 상수 표현식 (예: 1+0): 상수 표현식은 무시되어, 정렬/분할(ordering/partitioning)에 사용되지 않음.
	* ORDER BY 상수가 아닌 표현식(예: i, sin(i+1)): 표현식은 정렬/분할(ordering/partitioning)에 사용됨.	

Modified a problem in which the str_to_date function always returned the millisecond as 0 (CUBRIDSUS-9553)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	Modified a problem in which the STR_TO_DATE function always returned the millisecond as 0.

	::
		SELECT STR_TO_DATE('2012-10-31 23:49:29.123', '%Y-%m-%d %H:%i:%s.%f');
		
[검토]
^^^^^^
BLOB_FROM_FILE 혹은 CLOB_FROM_FILE 함수 수행 시 오류가 발생하는 문제(CUBRIDSUS-7596)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	BLOB_FROM_FILE 혹은 CLOB_FROM_FILE 함수 수행 시 "Semantic: Cannot coerce blob to type unknown data type." 오류가 발생하는 문제를 수정했다.
	
[검토]
^^^^^^
BIGINT 타입의 최대값에 TIME 타입의 값을 더할 때 잘못된 결과를 출력하는 현상(CUBRIDSUS-3735)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	BIGINT 타입의 최대값에 TIME 타입의 값을 더할 때 잘못된 결과를 출력했으나, 오류를 출력하도록 수정했다. ::
	
		SELECT CAST(9223372036854775807 as bigint) + TIME '11:59:59 pm';
	
[검토]
^^^^^^
데이터베이스 이름을 변경한 후 LOB 타입의 연산 수행에 실패하는 현상(CUBRIDSUS-8905)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	데이터베이스 이름을 변경하면 lob 타입에 대한 디렉터리가 설정되지 않아 CHAR_TO_BLOB 함수와 같은 LOB 타입 연산 수행에 실패하는 현상을 수정했다. ::
	
		cubrid createdb --db-volume-size=20m testdb
		cubrid renamedb testdb testdb2
		cubrid server start testdb2

		csql -u dba testdb2
		
		csql> CREATE TABLE tbl(b BLOB);
		csql> INSERT INTO tbl VALUES(CHAR_TO_BLOB('1'));
		
		ERROR: before ' )); '
		External storage is not initialized because the path is not specified in "databases.txt".

Fixed a Problem in which session operations, such as LAST_INSERT_ID function, Could continuously fail under network failure or HA failover(CUBRIDSUS-7549)(CUBRIDSUS-7669)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	Fixed a problem in which, although CASs were not supposed to share session ID for normal actions, when one of the CASs sharing the session ID due to a network failure or HA failover was terminated earlier than the others, session operation execution continuously failed in the applications connected to the remaining CASs. Session operations include: LAST_INSERT_ID functions, PREPARE statements, user session variables defined through SET, and ROW_COUNT() functions.

Fixed a problem in which a query result would be wrong when there is a DESC column in the multi-column index with OR conditions(CUBRIDSUS-9314)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	Previously, a query result would be wrong when there was a DESC column in the multi-column index, and the OR condition was given for the part of keys. This problem has been fixed.

	::
	
		CREATE TABLE foo(col1 INT, col2 INT, col3 INT);
		CREATE INDEX idx_foo ON foo(col1,col2 DESC, col3);
		INSERT INTO foo VALUES(1,10,100);
		INSERT INTO foo VALUES (1,11,100);
		PREPARE s FROM 'SELECT col1,col2 FROM foo WHERE col1=? AND ((col2=? AND col3<?) OR col2>?);';
		EXECUTE s USING 1, 10, 100, 10;

Fixed a phenomenon in which a server was abnormally terminated when executing select for the view that included the ORDER BY clause (CUBRIDSUS-9331)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	Fixed a phenomenon in which a server was abnormally terminated when executing SELECT for the view that included the ORDER BY clause, except the case that an asterisk (*) has been used for the SELECT list.

	::

		CREATE VIEW au AS 
		SELECT 
			tbla.a_id AS a_id, 
			tbla.u_id AS u_id, 
			tbla.a_date AS a_date, 
			tblu.u_name AS u_name, 
		FROM 
			tbla LEFT JOIN tblu ON tbla.u_id = tblu.u_id 
		ORDER BY tbla.a_date ASC;

		SELECT u_name FROM au;
		
Fixed a Problem in Which Auto Commit Was Not Executed When Multiple Queries Have Been Executed at Once in the Auto Commit Mode (CUBRIDSUS-7606)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	Fixed a problem in which auto commit was not executed when multiple queries have been executed at once in the auto commit mode, for example, when executing multiple queries as "CREATE TABLE a(col int);INSERT INTO a VALUES (1);".

[검토]
^^^^^^
테이블과 같은 이름을 가지는 뷰를 생성하는 오류(CUBRIDSUS-3091)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	테이블과 같은 이름을 가지는 뷰를 생성하는 오류를 수정했다. ::

		CREATE TABLE t1 (a INT, b INT);
		CREATE VIEW t1 AS SELECT * FROM t1;
		ERROR: Class t1 already exists.
		
[검토]
^^^^^^
자식 테이블의 기본 키를 참조하는 외래 키에 설정한 "ON DELETE CASCADE" 속성이 동작하지 않는 오류(CUBRIDSUS-3493)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	특정 테이블로부터 상속받은 자식 테이블의 기본 키를 참조하는 외래 키에 "ON DELETE CASCADE" 속성이 있음에도 불구하고
	해당 자식 테이블에 대해 DELETE를 수행해도 이를 참조하는 테이블의 레코드가 삭제되지 않는 오류를 수정했다. ::

		CREATE TABLE pk_super10 (id INT PRIMARY KEY);
		CREATE TABLE pk20 UNDER pk_super10 ( A INT);
		CREATE TABLE fk20 (id INT);
		ALTER TABLE fk20 ADD CONSTRAINT FOREIGN KEY (id) REFERENCES pk20(id) ON DELETE CASCADE;

		INSERT INTO pk20 VALUES (1,1),(2,2),(3,3);
		INSERT INTO fk20 VALUES (1), (1), (2);

		DELETE FROM pk20 WHERE a = 1;
		SELECT COUNT(*) from fk20;  // 수정 이전에는 DELETE CASCADE가 동작하지 않아 3건, 수정 이후 정상 동작하여 1건

[검토]
^^^^^^
MERGE 문의 대상 테이블에서 UPDATE할 레코드가 여러 건인 것을 허용하는 문제(CUBRIDSUS-7489)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	MERGE 문의 대상 테이블에서 UPDATE할 레코드는 오직 하나여야 하나 여러 건이 가능한 문제를 수정했다. ::

		CREATE TABLE t1(a INT, b INT);
		INSERT INTO t1 VALUES(1, 100);

		CREATE TABLE t2(a INT, b INT);
		INSERT INTO t2 VALUES(1, 200);
		INSERT INTO t2 VALUES(1, 300);

		// 수정 이후 아래 질의 수행 시 오류를 출력해야 한다.
		MERGE INTO t1
			USING t2
			ON (t1.a=t2.a)
			WHEN MATCHED THEN
			UPDATE SET t1.b=t2.b;

부질의에 사용되는 ORDER BY 절의 칼럼이 부질의의 SELECT 리스트에 없는 경우 잘못된 결과를 출력하는 문제(CUBRIDSUS-8931)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	부질의(subquery)에 사용되는 ORDER BY 절의 칼럼이 부질의의 SELECT 리스트에 없으면 잘못된 결과를 출력하거나 오류를 출력(9.0 Beta만 해당)하는 문제를 수정했다. ::

		SELECT a FROM foo WHERE a IN ( SELECT a FROM foo WHERE b = 'AAA' ORDER BY b, c);
	
[검토]
^^^^^^
WITH CHECK OPTION 절로 생성한 뷰에 MERGE 문 수행 시 실패하는 문제(CUBRIDSUS-9174)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	WITH CHECK OPTION 절로 생성한 뷰에 MERGE 문 수행 시 실패하는 문제를 수정했다.
	
	::

		CREATE TABLE t1(a INT, b INT);
		INSERT INTO t1 VALUES(1, 100);
		INSERT INTO t1 VALUES(2, 200);
		CREATE TABLE t2(a INT, b INT);
		INSERT INTO t2 VALUES(1, 99);
		INSERT INTO t2 VALUES(2, 999);
		CREATE VIEW v as SELECT * FROM t1 WHERE b < 150 WITH CHECK OPTION;

		MERGE INTO v
		USING t2
		ON (t2.a=v.a)
		WHEN MATCHED THEN
		UPDATE
		SET v.b=t2.b;

		// 위의 질의 수행이 성공해야 하나 수정 이전 버전에서는 아래의 오류 메시지가 출력되었다.
		ERROR: Check option exception on view v.

[검토]
^^^^^^
뷰 생성 시 SELECT 리스트에 없는 칼럼이 ORDER BY 절에 있으면 실패하는 문제(CUBRIDSUS-9345)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	뷰를 생성하는 질의문에서 SELECT 리스트에 없는 칼럼(hidden column)이 ORDER BY 절에 있으면 수행에 실패하는 문제를 수정했다. ::

		CREATE TABLE foo (i INT, j INT);
		CREATE VIEW v AS SELECT i FROM foo ORDER BY j;
		
[검토]
^^^^^^
뷰에서 DISTINCT 질의 수행 시 잘못된 값을 출력하는 문제(CUBRIDSUS-9880)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	::

		CREATE TABLE t (s CHAR(10), i INT);
		INSERT INTO t VALUES ('xxxx', 1);
		INSERT INTO t VALUES ('yyyy', 2);
		CREATE VIEW v AS SELECT s s_v, i i_v FROM t ORDER BY s;

		SELECT DISTINCT t1.i_v FROM v t1, v t2;

뷰 생성에 사용된 테이블의 이름을 변경해도 뷰에 대한 질의 수행 시 변경 이전의 테이블로 동작하는 문제(CUBRIDSUS-8536)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	뷰 생성에 사용된 테이블의 이름을 변경해도 뷰에 대한 질의를 수행하면 변경 이전의 테이블로 동작하는 문제를 수정했다. ::

		CREATE TABLE foo (a INT PRIMARY KEY, b VARCHAR(20));
		INSERT INTO foo VALUES(1, 'foo');

		CREATE TABLE bar (a INT PRIMARY KEY, b VARCHAR(20));
		INSERT INTO bar VALUES(1, 'bar');
		CREATE VIEW v1 (a int, b VARCHAR(20)) AS SELECT * FROM foo;

		// foo를 foo_old, bar를 foo로 이름을 변경한다.
		RENAME foo AS foo_old;
		RENAME bar AS foo;
		
		// 수정 이전 버전에서는 Q1의 결과로 'bar', Q2의 결과로 'foo'를 출력하며, 수정 이후 버전에서는 둘다 'bar'를 출력한다.
		SELECT b FROM foo; -- Q1
		SELECT b FROM v1;  -- Q2
		
NUMERIC타입 컬럼에 호스트 변수를 이용하여 INSERT 수행 시 실패하는 문제(CUBRIDSUS-9500)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	NUMERIC 타입 컬럼에 대해 호스트변수를 이용하여 INSERT를 수행할 때, 사용자가 입력한 값이 NUMERIC의 기본 precision, scale(15, 0)로 변경되어 입력되는 문제를 해결하였다. 
	
	::

		CREATE TABLE tb2 (a NUMERIC(4,4));
		PREPARE STMT FROM 'INSERT INTO tb2 VALUES (?)';
		EXECUTE STMT USING 0.1;
		SELECT a FROM tb2;
		a
		----------
		0.0

		EXECUTE STMT USING 0.5;
		ERROR: A domain conflict exists on attribute "a".
		
[검토]
^^^^^^
계층 질의문에서 LEVEL 의사 칼럼의 최대값 조건이 있는 경우 CONNECT BY 절 뒤에 NOCYCLE이 지정되어도 순환이 무시되도록 수정(CUBRIDSUS-9581)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	계층 질의문에서 LEVEL 의사 칼럼의 최대값 조건이 있는 경우 CONNECT BY 절 뒤에 NOCYCLE이 지정되어도 순환이 무시되도록 수정했다.

	::
	
		SELECT LEVEL FROM db_root CONNECT BY NOCYCLE LEVEL <= 5;

				level
		=============
					1
					2
					3
					4
					5
					
[검토]
^^^^^^
현재의 날짜/시간을 구하는 함수의 반환 값을 트리거를 통해 INSERT하면 년월일시가 0이 되는 현상(CUBRIDSUS-9596)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	현재의 날짜/시간을 구하는 SYSDATE, SYSTIME, SYSDATETIME, SYSTIMESTAMP의 반환 값을 트리거를 통해 INSERT하면 년월일시가 0(zero datetime)이 되는 현상을 수정했다.
	
	::
		
		CREATE TABLE testtbl (field1 INT);
		CREATE TABLE resulttbl (ts TIMESTAMP);
		CREATE TRIGGER batchtestresult AFTER COMMIT EXECUTE AFTER INSERT INTO resulttbl  VALUES (SYSTIMESTAMP);
		INSERT INTO testtbl VALUES(1);

		SELECT * FROM resulttbl;
		
		// 수정 이전 버전에서는 년월일시가 0으로 잘못 출력되었다.
		  ts
		===============================
		  12:00:00.000 AM 00/00/0000
		  12:00:00.000 AM 00/00/0000
		  
[검토]
^^^^^^
AUTO_INCREMENT 칼럼이 있는 테이블을 RENAME할 수 없는 문제(CUBRIDSUS-9691)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[검토]
^^^^^^
ON DUPLICATE KEY UPDATE(ODKU) 절에서 SELECT 문의 칼럼을 참조할 때 오류 수정 및 REPLACE 문과 ODKU에서 분할 테이블 지원(CUBRIDSUS-8337)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	아래 구문과 같이 ODKU 절에서 SELECT 문의 칼럼을 참조할 때 오류가 발생하는 문제를 수정했다. :: 
	
		INSERT INTO t1 (field_1, field_2, field_3) SELECT t2.field_a, t2.field_b, t2.field_c FROM t2 ON DUPLICATE KEY UPDATE t1.field_3=t2.field_c;
		ERROR: t2.field_c is not defined.
		
	또한, ODKU 절과 REPLACE 문에서 분할 테이블을 지원하도록 수정했다.
	
[검토]
^^^^^^
ORDERY BY 절 뒤에 질의문이 이어질 경우 문법 오류가 발생하는 문제(CUBRIDSUS-6920)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	ORDERY BY 절이 질의문의 가장 뒤에 위치하는 것으로 다루어져 "SELECT~ORDER BY~UNION SELECT"처럼 ORDER BY 절 뒤에 문장이 이어지는 경우 문법 오류로 처리하는 문제를 수정했다. ::

		SELECT * FROM tbl1 ORDER BY a UNION SELECT * FROM tbl2 ORDER BY b;

	참고로, 수정 이전 버전에서도 UNION 절 사이를 괄호로 묶으면 오류를 회피할 수 있다. ::
	
		(SELECT * FROM tbl1 ORDER BY a) UNION (SELECT * FROM tbl2 ORDER BY b);
		
[검토]
^^^^^^
SUM 함수 혹은 AVG 함수의 호스트 변수 인자에 double 타입으로 변환 가능한  문자열을 입력하는 경우 오류 발생 현상(CUBRIDSUS-8789)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	SUM 함수 혹은 AVG 함수의 호스트 변수 인자로 double 타입으로 변환 가능한 문자열을 입력하는 경우 "ERROR: Invalid data type referenced." 오류를 출력하는 현상을 수정했다. ::
	
		CREATE TABLE tbl(a INT);
		INSERT INTO tbl VALUES(1),(2);
		PREPARE STMT FROM 'SELECT AVG(?) FROM tbl';
		EXECUTE STMT USING '1.1';

[검토]
^^^^^^
두 개 이상의 응용 프로그램이 번갈아 INCR 함수 수행 시 교착 상태가 발생하는 현상(CUBRIDSUS-5009)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	두 개 이상의 응용 프로그램이 번갈아 INCR 함수 수행 시 교착 상태가 발생한 후 비정상적으로 동작하는 현상을 수정했다. 
	
	::
	
		+---------------------------------------+---------------------------------------+
		| T1                                    | T2                                    |
		+=======================================+=======================================+
		| // autocommit off                     | // autocommit off                     |
		|                                       |                                       |   
		| CREATE TABLE t1(a INT);               |                                       |
		| CREATE UNIQUE INDEX ON t1 (a);        |                                       |
		| INSERT INTO t1 VALUES (1),(4),(7);    |                                       |
		| COMMIT;                               |                                       |
		+---------------------------------------+---------------------------------------+
		| INSERT INTO t1 VALUES (3);            |                                       |
		+---------------------------------------+---------------------------------------+
		|                                       | DELETE FROM t1 WHERE a=4;             |
		+---------------------------------------+---------------------------------------+
		| SELECT INCR(a) FROM t1 WHERE a=3;     |                                       |
		| -- BLOCKED                            |                                       |
		+---------------------------------------+---------------------------------------+
		| 0 rows selected.                      | SELECT INCR(a) FROM t1 WHERE a=1;     |
		|                                       | -- BLOCKED                            |
		+---------------------------------------+---------------------------------------+
		| SELECT INCR(a) FROM t1 WHERE a=3;     |                                       |
		| 0 rows selected.                      |                                       |
		+---------------------------------------+---------------------------------------+
		| SELECT INCR(a) FROM t1 WHERE a=3;     |                                       |
		| 0 rows selected.                      |                                       |
		+---------------------------------------+---------------------------------------+
		| // the same as above                  |                                       |
		+---------------------------------------+---------------------------------------+		

[검토]
^^^^^^
GROUP BY 절을 가진 구문에서 분석 함수를 사용하면 오류가 발생하는 문제(CUBRIDSUS-7270)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	GROUP BY 절을 가진 구문에서 분석 함수를 사용할 수 있도록 수정했다. ::
			
		SELECT a, ROW_NUMBER() OVER(ORDER BY a) FROM tbl GROUP BY a;
		
		// 수정 이전 버전에서는 다음의 오류가 발생했다.
		ERROR:  before '  from tbl group by a; '
		Nested or invalid use of aggregate function.

[검토]
^^^^^^
EUC-KR 문자셋 DB에서 LIKE 절을 포함한 질의의 출력 결과가 잘못된 문제(CUBRIDSUS-9199)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	EUC-KR 문자셋 DB에서 LIKE 절에 '_' 혹은 '%'와 같이 와일드 카드 문자를 포함하는 경우 질의 출력 결과가 잘못된 문제를 수정했다.

	::

		SELECT * FROM tbl WHERE col LIKE '_乖a';
		
[검토]
^^^^^^
DELETE, UPDATE 범위 질의에서 키 잠금 오류로 인한 고유 키 위반 현상(CUBRIDSUS-9382)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	DELETE, UPDATE의 범위 질의에서 키 잠금 오류로 인해 여러 개의 응용 프로그램이 동시에 수행될 때 고유 키 위반이 발생하는 현상을 수정했다.

자동 커밋 OFF인 상태에서 테이블 생성 후 고유 키 위반 오류 이후 INSERT 문 재수행 시 미디어 실패 오류가 발생하는 현상(CUBRIDSUS-10239)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	자동 커밋 OFF인 상태에서 테이블 생성 후 INSERT 문 수행 도중 고유 키 위반 오류가 발생한 이후, INSERT 문을 재수행하면 미디어 실패 오류가 발생하는 현상을 수정했다. 

	::
		$ csql testdb --no-auto-commit 
		
		CREATE TABLE tbl(col1 int unique);
		INSERT INTO tbl SELECT 500 + ROWNUM FROM db_class a, db_class b;
		INSERT INTO tbl SELECT ROWNUM FROM db_class a, db_class b;

		ERROR: Operation would have caused one or more unique constraint violations. INDEX u_t_i(B+tree: 0|139|540) ON CLASS t(CLASS_OID: 0|486|2). key: 501(OID: 0|551|358).
		
		INSERT INTO tbl SELECT 500 + ROWNUM FROM db_class a, db_class b;

		ERROR: Media recovery may be needed on volume "/home1/cubrid1/CUBRID/databases/testdb/testdb".

	

[검토]
^^^^^^
같은 이름의 뷰로 또 다른 뷰가 생성되는 문제(CUBRIDSUS-3090)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	같은 이름의 뷰로 또 다른 뷰가 생성되지 않도록 수정했다. ::
	
		CREATE VIEW v2 AS SELECT * FROM t1;
		// 수정 이후에는 아래의 질의 수행을 허용하지 않는다.
		CREATE OR REPLACE VIEW v2 AS SELECT * FROM v2;
		
[검토]
^^^^^^
UPDATE JOIN 수행 시 영향을 받는 레코드 개수가 잘못 출력되는 현상(CUBRIDSUS-7185)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	UPDATE JOIN으로 한 질의에 여러 개의 테이블에 대한 UPDATE 수행 시 영향을 받는 레코드 개수가 잘못 출력되는 현상을 수정했다. ::
	
		UPDATE t1 m1, t2 m2 SET m1.a=100, m2.b=100 WHERE m1.a=m2.b;
		// 수정 이후 x rows가 정상 출력된다.
		x rows affected.

[검토]
^^^^^^
질의 내 논리 표현식을 괄호로 감싸주어야 정상 인식되는 현상(CUBRIDSUS-7392)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	특정 질의에 대해서는 질의 내 논리 표현식을 괄호로 감싸주어야 정상 인식되는 현상을 수정했다. ::
	
		// 수정 이전 버전에서는 아래 질의에서 괄호로 감싼 논리 표현식에서 괄호를 제거하면 오류가 발생했다. 
		SELECT * FROM t1 ORDER BY (code > 10);
		SELECT SUM((code>10)) FROM t1;

[검토]
^^^^^^
서로 연관이 없는 다중 테이블 DELETE 구문 수행 시 성능 개선(CUBRIDSUS-8144)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	서로 연관이 없는 다중 테이블 DELETE 구무 수행 시 JOIN 연산을 수행하지 않도록 하여 해당 질의의 성능을 개선했다. ::

		DELETE m1,m2,m3,m4,m5,m6,m7,m8,m9,m10 from m1, m2,m3,m4,m5,m6,m7,m8,m9,m10;
		
[검토]
^^^^^^		
MERGE 문이 오동작하는 문제(CUBRIDSUS-9158)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	MERGE 문에서 원본 테이블을 이용한 부질의를 대상 테이블로 사용할 때 오동작하는 현상을 수정했다. ::

		MERGE INTO t1 USING (SELECT * FROM t1 WHERE b<3) t2 ON (t1.a=t2.a) 
			WHEN MATCHED THEN UPDATE SET t1.b=1000 DELETE WHERE t1.a>1;
			WHEN MATCHED THEN UPDATE SET t1.b=1000 DELETE WHERE t1.a>1;
		
	또한, MERGE 문에서 분할 테이블을 UPDATE한 이후 해당 데이터가 DELETE되지 않는 현상을 수정했다. ::
	
		MERGE INTO t2 USING t1 ON (t1.id1=t2.id2) 
			WHEN MATCHED THEN UPDATE SET t2.col1='updated', t2.col2=t1.col1
			DELETE WHERE t2.col1='updated';
				
[검토]
^^^^^^
LIMIT 절을 가진 SELECT문으로 생성한 뷰에 INSERT 수행 시 응용 프로그램이 비정상 종료하는 현상(CUBRIDSUS-9940)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	::
		CREATE TABLE t(s string);
		CREATE VIEW tv AS SELECT s FROM t ORDER BY s LIMIT 2;
		INSERT INTO tv VALUES('a');

[검토]
^^^^^^
FROM 절을 생략한 질의문에서 SQL 함수의 입력 인자를 문장으로 전달하면 오류가 발생하는 현상(CUBRIDSUS-9949)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	FROM 절을 생략한 질의문에서 "SELECT INET_NTOA((SELECT 3232235530))"처럼 SQL 함수의 입력 인자를 SQL 구문으로 전달하면 "ERROR: syntax is ambiguous" 오류가 발생하는 현상을 수정했다.

[검토]
^^^^^^
수치 함수에 NULL 인자가 입력되면 NULL을 반환하도록 수정(CUBRIDSUS-10324)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	::
				
		SELECT POW('a', NULL);

		// 수정 이전 버전에서 위의 질의를 수행하면 아래와 같은 오류가 발생하며, 새 버전에서 수행하면 NULL을 반환한다.
		
		ERROR: before ' , null); '
		Cannot coerce 'a' to type double.
		
[검토]
^^^^^^
WHERE 절에 WITH CHECK OPTION이 있는 SELECT 절을 가지고 생성한 뷰에 대해 MERGE 문 수행 시 CHECK OPTION 조건이 필터링되지 않는 현상(CUBRIDSUS-10219)	
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	::
	
		CREATE TABLE t1(a INT, b INT);
		INSERT INTO t1 VALUES(1, 500);
		CREATE TABLE t2(a INT, b INT);
		INSERT INTO t2 VALUES(1, 400);
		INSERT INTO t2 VALUES(2, 200);

		CREATE VIEW v AS SELECT * FROM t1 WHERE b < 300 WITH CHECK OPTION;

		MERGE INTO v
		USING t2
		ON (t2.a=v.a)
		WHEN NOT MATCHED THEN
		INSERT VALUES(t2.a, t2.b);
		
[검토]
^^^^^^	
MERGE문에서 원본과 대상 테이블 이름이 같으면 수행에 실패하는 문제(CUBRIDSUS-10207)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	::
	
		MERGE INTO tbl t
			USING tbl s
			ON (t.a=s.a)
			WHEN MATCHED THEN 
			UPDATE SET t.b='updated';

[검토]
^^^^^^
VALUE 문을 이용하여 생성한 뷰에 SELECT를 수행할 수 없는 현상(CUBRIDSUS-9982)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	VALUE 문을 이용하여 생성한 뷰에 SELECT를 수행할 수 없는 현상을 수정했다. ::
	
		CREATE VIEW vw as VALUES (1 AS col1, 'first' AS col2); 
		SELECT * FROM vw;
		
		// 9.0 Beta 버전에서는 다음 오류가 발생했다.
		ERROR: There are more attributes in class vw than columns in the query specification.

SPACE 함수를 가지고 함수 인덱스 생성이 되지 않도록 수정(CUBRIDSUS-10419)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	SPACE 함수는 인덱스 스캔 입장에서 무의미한 일련의 공백 문자를 반환하므로, SPACE 함수를 가지고 함수 인덱스 생성을 허용하지 않도록 수정했다. ::
	
		CREATE INDEX i_tbl_col on tbl(SPACE(col1));

		// 수정 이후 위의 질의를 수행하면 아래 오류 메시지를 출력한다.
		'space ' function cannot be used for function based index.

다국어
------


[검토]
^^^^^^
FIND_IN_SET 함수가 콜레이션을 고려하여 동작하도록 수정(CUBRIDSUS-6319)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	FIND_IN_SET 함수가 콜레이션에 따라 동작하도록 수정했다. ::

		SELECT FIND_IN_SET('b' , 'a,B,c' COLLATE 'iso88591_en_ci');

		2

[검토]
^^^^^^
COLLATE 수정자가 표현식에 대해 적용될 수 있도록 수정(CUBRIDSUS-9401)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	COLLATE 수정자가 표현식에 대해 적용될 수 있도록 수정했다. 다음 예에서 첫 번째 질의와 두 번째 질의는 같은 결과를 수행한다. ::
	
		SELECT * FROM t WHERE (col > 'a') COLLATE utf8_en_ci;
		SELECT * FROM t WHERE col COLLATE utf8_en_ci > 'a' COLLATE utf8_en_ci;
		
[검토]
^^^^^^
POSITION, REPLACE, INSTR, LOCATE, SUBSTRING_INDEX 함수에서 콜레이션 지원(CUBRIDSUS-8393)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[검토]
^^^^^^
ENUM 타입에서 COLLATE 수정자 지원(CUBRIDSUS-8700)(CUBRIDSUS-9943)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	ENUM 타입에서 COLLATE 수정자를 지원하도록 수정했다. ::
	
		SET NAMES utf8 COLLATE utf8_en_ci; 
		// 수정 이후 아래 문장들은 정상 수행된다.
		CREATE TABLE tbl (a ENUM('A','B') COLLATE utf8_en_ci);
		INSERT INTO tbl VALUES ('a');
	
	ENUM 타입은 기본적으로 숫자 타입으로 인식되는데, 수정 이후 ENUM 타입 칼럼에 COLLATE 수정자를 사용하는 경우에는 VARCHAR 타입으로 인식하게 되었다.
	다만, ALTER TABLE .. MODIFY 문을 이용하여 ENUM 타입 칼럼을 다른 문자셋으로 바꿀 수는 없다.

[검토]
^^^^^^
대소문자 구분 없는 콜레이션에서 LIKE 조건이 정상 동작하지 않는 문제(CUBRIDSUS-8391)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	대소문자 구분 없는 콜레이션에서 LIKE 조건이 정상 동작하지 않는 문제를 수정했다. ::

		CREATE TABLE t(v STRING COLLATE utf8_en_ci);
		INSERT INTO t VALUES('I'),('i');

		// 수정 이전 버전에서 대문자 "I"는 질의 결과에서 제외되었다.
		SELECT * FROM t WHERE v LIKE '%i%';

[검토]
^^^^^^
바이너리 콜레이션 외의 일부 콜레이션의 칼럼 인덱스에서 검색 결과가 잘못되는 문제(CUBRIDSUS-7737)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	바이너리 콜레이션 외의 일부 콜레이션으로 칼럼을 지정하여 생성한 인덱스를 사용하면 검색 결과가 잘못되는 문제를 수정했다.
	수정 이전 버전에서 iso88591_bin, utf8_bin, euckr_bin, iso88591_en_cs, utf8_en_cs, utf8_ko_cs를 제외한 나머지 콜레이션으로 인덱스를 생성하면 검색 결과가 잘못될 수 있다. 
	
	::
	
		CREATE TABLE tbl(id INT,s STRING COLLATE utf8_en_ci);
		CREATE REVERSE INDEX ix1 on tbl(s);
	
	참고로, 확장이 있는 콜레이션으로는 prefix 인덱스를 생성할 수 없다.
	
[검토]
^^^^^^
CHR 함수의 멀티바이트 문자셋 변경 지원(CUBRIDSUS-8934)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	::
	
		SET NAMES utf8;
		SELECT CHR(14909886);

		   chr(14909886 using utf8)
		======================
		  'ま'
		
[검토]
^^^^^^
유니코드 정규화가 수행되지 않는 문제(CUBRDISUS-8685)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	출력 시 유니코드 정규화를 수행하게 하는 파라미터 unicode_output_normalization의 값을 yes로 설정했는데도 유니코드 정규화가 수행되지 않는 문제를 수정했다.
	
[검토]
^^^^^^
콜레이션이 서로 다른 테이블끼리 외래 키 속성 설정할 수 없도록 수정(CUBRIDSUS-8742)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	
	::
	
		CREATE TABLE dim(s STRING COLLATE utf8_en_ci PRIMARY KEY);
		CREATE TABLE fact(s STRING COLLATE utf8_en_cs PRIMARY KEY);
		
		// 수정 이후 아래 질의를 수행하면 오류를 출력한다.
		ALTER TABLE fact ADD CONSTRAINT FOREIGN KEY(s) REFERENCES dim(s);
		
[검토]
^^^^^^
칼럼을 다른 문자셋의 콜레이션으로 변환하면 응용 프로그램이 비정상 종료하는 현상(CUBRIDSUS-10158)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	::
	
		SET NAMES utf8;
		CREATE TABLE t (i INT, s STRING COLLATE utf8_fr_exp_ab);
		INSERT INTO t VALUES (1,'cote ');
		INSERT INTO t VALUES (2,'coté');
		INSERT INTO t VALUES (3,'côte ');
		INSERT INTO t VALUES (4,'côté');
		// 수정 이전 버전에서 아래 질의를 수행하면 응용 프로그램이 비정상 종료되었다.
		SELECT * FROM t oRDER BY CAST (s AS STRING COLLATE utf8_de_exp);
		
[검토]
^^^^^^
CREATE TABLE ... AS SELECT ... UNION 문으로 테이블 생성 시 실패하는 현상(CUBRIDSUS-10105)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	::
	
		CREATE TABLE T1 AS SELECT '1' A UNION SELECT '2' A;
		// 수정 이전 버전에서는 다음 오류를 출력했다.
		ERROR: A domain conflict exists on attribute "".

[검토]
^^^^^^
CHR 함수가 COLLATE 수정자를 지원하지 않는 문제(CUBRIDSUS-9939)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	CHR 함수가 COLLATE 수정자를 지원하지 않는 문제를 수정했다. ::
	
		SELECT * FROM tbl WHERE CHR(65) COLLATE utf8_bin > 'a' LIMIT 1;

[검토]
^^^^^^
로캘 라이브러리 생성 시 LDML 파일의 속성 값 설정 오류를 검증하지 않는 문제(CUBRIDSUS-10000)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	make_locale 도구(Linux 확장자는 .sh, Windows 확장자는 .bat)를 사용하여 로캘 라이브러리 생성 시 de_DE.xml과 같은 LDML(Locale Data Markup Language) 파일의 속성 값 설정 오류를 검증하고, 오류 발견 시 적절한 메시지를 출력하도록 수정했다.
	속성 값을 잘못 설정하는 경우의 예는 다음과 같다.
	
	* 같은 콜레이션 타입을 중복해서 설정하는 경우
	* 콜레이션 ID로 설정할 수 있는 범위(0~255)를 벗어나는 경우
	
	또한, 속성 값에 대해 대소문자를 구분하지 않도록 수정했다.

[검토]		
^^^^^^
SQL 함수 결과 값에 대해 COLLATE 수정자가 정상 적용되지 않는 문제(CUBRIDSUS-10043)	
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	SQL 함수 결과 값에 대해 COLLATE 수정자가 정상 적용되지 않아 잘못된 결과를 출력하는 문제를 수정했다. ::

		CREATE TABLE tbl(col1 CHAR(10) COLLATE utf8_gen_ci, col2 CHAR(10) COLLATE utf8_gen_ai_ci);
		INSERT INTO tbl VALUES('bbb','%Bb_%');
		
		// 수정 이전 버전에서 아래의 질의를 수행하면 1건을 출력하나, 수정 이후 버전에서는 COLLATE 수정자가 정상 적용되어 0건을 출력한다.
		SELECT col1, TRIM(REPLACE(col1,'b','B')), TRIM(col2) FROM tbl WHERE TRIM(REPLACE(col1,'b','B')) COLLATE utf8_gen LIKE TRIM(col2) COLLATE utf8_gen;

[검토]
^^^^^^
Windows에서 "0x"로 시작하는 16진수 숫자를 나타내는 문자열을 부동 소수로 변환하지 못하는 문제(CUBRIDSUS-10384)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	::
	
		SELECT CAST('0x1111' AS float);
		VALUES (1),('123'),('0x75');
		
		//수정 이전 버전에서 위의 질의들을 수행하면 아래의 오류 메시지를 출력했다.
		ERROR: Cannot coerce value of domain "character" to domain "float".

질의 계획 및 최적화
-------------------


질의 계획만 보도록 설정했음에도 불구하고 SELECT 문을 제외한 나머지 질의문들이 실행되는 문제(CUBRIDSUS-9771)(CUBRIDSUS-10352)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	질의 최적화 수준을 질의 계획만 보도록 설정했음에도 불구하고 SELECT문을 제외한 INSERT, UPDATE, DELETE, REPLACE, TRIGGER, SERIAL 문 등이 실행되는 문제가 9.0 베타 버전에 존재했으나 실행이 되지 않게 수정했다. 9.0 베타 이전 버전에서는 응용 프로그램이 비정상 종료되는 문제가 존재했다. SELECT 문을 제외한 나머지 질의문은 질의 계획이 출력되지 않는다. ::
		
		SET OPTIMZATION LEVEL 514;
		REPLACE INTO tbl (col1, col2, col3) VALUES (1, 2, 3);
		
질의 계획을 파일 스트림이 아닌 메모리 스트림에 출력하도록 수정(CUBRIDSUS-9552)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	질의 계획을 파일 스트림이 아닌 메모리 스트림에 출력하도록 수정하여, 성능이 개선되고 /tmp 경로에 대한 접근 권한 문제가 해결되었다.

Improved to apply optimization of the ORDER BY clause if there was no affect on the result order when the column type of the ORDER BY clause was converted (CUBRIDSUS-7418)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	Improved to apply 'skip order by' (optimization of the ORDER BY clause that retrieved the value in the order sorted by index, not by executing sorting) if the result order before converting the column type of the ORDER BY clause was same with the result order after the conversion. 

Improved query optimization of the LIMIT clause (CUBRIDSUS-7661)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	Improved the inefficiency of terminating a query after navigating the N+1st record when a query was executed by using LIMIT N.

	::
	
		SELECT * FROM t1 WHERE a > 0 AND b = 1 LIMIT 3;

[검토]
^^^^^^		
ORDER BY 칼럼이 2개 이상이라도, orderby_num()에 의해 범위가 주어져도 다중 범위 최적화가 가능하도록 개선(CUBRIDSUS-7441)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	ORDER BY 칼럼이 2개 이상이라도, orderby_num()에 의해 범위가 주어져도 중간 값의 정렬을 진행하면서 결과를 수집하는 다중 범위 최적화(multi-range optimization)가 가능하도록 개선했다. ::
	
		SELECT * FROM tbl WHERE a IN (1,2,3) USING INDEX idx ORDER BY col1 DESC, col2 DESC LIMIT 2;
		SELECT * FROM tbl WHERE a IN (1,3) ORDER BY b, c DESC FOR orderby_num() > 2 and orderby_num() <= 5;
		
[검토]
^^^^^^
GROUP BY LIMIT 절을 포함한 질의의 최적화(CUBRIDSUS-6400)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	GROUP BY LIMIT 절을 포한한 질의에서 인덱스 스캔 도중에 그룹핑에 대한 LIMIT 절을 수행할 수 있도록 수정했다. ::

		SELECT DISTINCT rdate
		FROM tbl
		WHERE rdate > -20111121
		GROUP BY rdate LIMIT 4;

[검토]
^^^^^^
분석 함수의 수행 성능이 느린 문제 개선(CUBRIDSUS-8487)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
		
분할
----


[검토]
^^^^^^
특정 분할(partition)에 대해 질의 가능해짐(CUBRIDSUS-9492)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	특정 분할(partition)을 지정하여 질의할 수 있도록 "table_name PARTITION (partition_name)" 구문을 지원하게 되었다.  ::

		SELECT * FROM athlete2 PARTITION (event2);

[검토]
^^^^^^
분할 테이블에서 INCR/DECR을 지원(CUBRIDSUS-9157)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[검토]
^^^^^^
분할 테이블에서 INSERT ... ON DUPLICATE KEY UPDATE 문 지원(CUBRIDSUS-9816)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	분할 테이블에서 INSERT ... ON DUPLICATE KEY UPDATE 문을 지원하도록 수정했다. ::
	
		CREATE TABLE tbl1
			(a BIGINT AUTO_INCREMENT(1,1) PRIMARY KEY, b SMALLINT, c NUMERIC(5,5),
			l FLOAT,m DATE,n CHAR(200) ) 
			PARTITION BY HASH(i) PARTITIONS 5 ;
		
		CREATE TABLE tbl2
			(i INT, j INT, k INT,
			l INT,m DATE,n CHAR(250)) 
			PARTITION BY HASH(j) PARTITIONS 5 ;

		INSERT INTO tbl2 (a,b,c,l,m,n) 
			SELECT b,a,c,l,m,n 
			FROM tbl1 
			ON DUPLICATE KEY UPDATE a = a-1, c = c+1; 
		
		// 수정 이전에 위의 구문을 수행하면 오류 메시지가 발생한다.
		ERROR: The Statements REPLACE INTO... and INSERT ... ON DUPLICATE KEY UPDATE are not allowed for partitioned classes 
			or for classes that are part of an inheritance chain. 

[검토]
^^^^^^
범위 분할 테이블의 질의 조건이 "칼럼 > 최대값"이면 분할 프루닝이 수행되지 않는 문제(CUBRIDSUS-7792)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	범위 분할 테이블의 질의 조건이 "칼럼 > 최대값"이면 범위를 벗어난 데이터는 탐색 대상에서 제외하는 분할 프루닝(partition pruning)이 수행되지 않는 문제를 수정했다. ::

		CREATE TABLE t(i int) PARTITION BY RANGE( i ) (PARTITION p0 VALUES LESS THAN(21));
		SELECT * FROM t WHERE i>=21;
		// 수정 이후 아래의 조건은 위의 조건과 같이 취급하여 분할 프루닝이 수행된다.
		SELECT * FROM t WHERE i>20;


[검토]
^^^^^^
분할 테이블에서 파티션을 제거하면 데이터가 존재함에도 불구하고 COUNT(*) 값으로 0을 출력하는 현상(CUBRIDSUS-9338)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	분할 테이블에 여러 건의 INSERT, UPDATE 또는 DELETE를 수행한 이후에 분할을 제거하면 데이터가 존재함에도 불구하고 COUNT(*) 값으로 0을 출력하는 현상을 수정했다.
	
	::

		CREATE TABLE TBL(i INT PRIMARY KEY) PARTITION BY RANGE(i) 
			(PARTITION p0 VALUES LESS THAN (20)
			,PARTITION p1 VALUES LESS THAN(40)
			,PARTITION p2 VALUES LESS THAN MAXVALUE);
		INSERT INTO tbl SELECT ROWNUM FROM db_class;
		ALTER TABLE tbl REMOVE PARTITIONING;

		SELECT COUNT(*) FROM tbl;

	수정 이전 버전에서 해당 분할 테이블이 있는 데이터베이스는 cubrid checkdb 명령을 수행하면 데이터 불일치로 나타나며, cubrid checkdb -r 명령을 수행해도 데이터가 회복되지 않는 현상이 발생한다.

	::

		$ cubrid checkdb testdb

		Some inconsistencies were detected in your database.
		 Please consult error_log_file /home/CUBRID/log/testdb_checkdb.err for additional information.

 
[검토]
^^^^^^
분할 테이블로 생성한 뷰에 데이터가 입력되지 않는 현상(CUBRIDSUS-10264)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	::
	
		CREATE TABLE tbl(col1 int, col2 int) PARTITION BY RANGE(col1) (
			PARTITION p0 VALUES LESS THAN (5),
			PARTITION p1 VALUES LESS THAN (10)
		);

		CREATE VIEW v1 AS SELECT * FROM tbl PARTITION (p0);
		INSERT INTO v1 values (1,1);
		
		ERROR: Not allowed access to partition: 's1__p__p0'

[검토]
^^^^^^
분할 테이블에서 INCR/DECR 함수 수행이 가능하도록 수정(CUBRIDSUS-10259)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	::
	
		CREATE TABLE s1(i int, j int) PARTITION BY RANGE(i) (
			PARTITION p0 VALUES LESS THAN (5),
			PARTITION p1 VALUES LESS THAN (10)
		);
		INSERT INTO s1 PARTITION(p0) VALUES (1,1);
		SELECT INCR(I) FROM s1 PARTITION(p0); 

[검토]
^^^^^^
분할 테이블에서 분할 키가 칼럼과 다른 문자셋을 가지면 데이터가 정상적으로 분할되지 않는 문제(CUBRIDSUS-9904)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	다음 예와 같이 분할 테이블에서 분할 키가 칼럼과 다른 문자셋을 가지면 데이터가 정상적으로 분할되지 않는 문제가 존재했으나, 칼럼과 다른 문자셋을 가진 분할 키를 허용하지 않도록 수정했다. ::

		CREATE TABLE t(c CHAR(50) COLLATE utf8_bin) PARTITION BY LIST(c) (
			PARTITION p0 VALUES IN(_utf8'xxx'),
			PARTITION p1 VALUES IN(_iso88591'yyy'));

[검토]
^^^^^^
분할 테이블이 아닌 테이블의 이름 끝이 "__p__p1"로 끝나는 경우 분할 테이블로 오인하여 동작하는 문제(CUBRID-10261)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	분할 테이블이 아닌 테이블의 이름이 "<tbl>__p__p1"인 경우 분할 테이블로 오인하여 INSERT INTO <tbl> ... PARTITION, UPDATE <tbl> ... PARTITION, DELETE FROM <tbl> ... PARTITION 등의 질의가 수행되는 문제를 수정했다. ::

		// s1__p__p1은 분할 테이블이 아니다.
		CREATE TABLE s1__p__p1 (col1 INT, col2 INT);
		
		// 수정 이전에는 아래 질의들이 모두 수행되는 문제가 존재했다.
		INSERT INTO s1 PARTITION(p1) VALUES (1,1);
		UPDATE s1 PARTITION(p1) set col1=99;
		DELETE FROM s1 PARTITION(p1);
		TRUNCATE TABLE s1 PARTITION(p1);

[검토]
^^^^^^
분할 테이블의 분할에 직접 INSERT하는 트리거의 생성에 실패하는 문제(CUBRIDSUS-10283)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	분할 테이블의 분할에 직접 INSERT하는 트리거의 생성을 시도하면 오류가 발생하는 문제를 수정했다. ::
		
		CREATE TABLE t1 (col1 INT, col2 INT);
		CREATE TABLE t2 (col1 INT, col2 INT) PARTITION BY LIST (col1) (
			PARTITION p0 VALUES IN (1,3,5,7,9),
			PARTITION p1 VALUES IN (0,2,4,6,8)
		);

		CREATE TRIGGER tri1
		BEFORE INSERT ON t1
		EXECUTE INSERT INTO t2 PARTITION (p0) VALUES (1,1);
		
		// 수정 이전 버전에서 위의 질의를 수행하면 아래 오류가 발생한다.
		ERROR: Error compiling action for "tri1", invalid scope statement
		  scope_statement: SCOPE trigger_action { FROM table_spec_list }

HA 기능 및 HA 데이터 복제
-------------------------


Fixed a problem of repeating restart of the replication log reflection process of a master node when a slave node was changed to the maintenance mode (CUBRIDSUS-9380)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	Fixed a problem of repeating restart of the replication log reflection process of a master node when a slave node was changed to the maintenance mode in the HA environment.


다중 칼럼으로 구성된 기본 키에 DESC 속성이 있는 경우 슬레이브 노드에 데이터가 복제되지 않는 문제(CUBRIDSUS-9774)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

복제 재구축 스크립트 개선(CUBRIDSUS-10327)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	ha_make_slavedb.sh 스크립트 내에 설정된 $repl_log_home 디렉터리가 존재하지 않을 경우 생성하도록 수정했다.
	또한, $CUBRID_DATABASES 와 $repl_log_home이 서로 다르게 생성된 경우 스크립트 수행 도중 예전에 슬레이브 노드로부터 복사해 온 마스터 노드의 복제 로그가 삭제되지 않는 문제를 수정했다.

databases.txt에 설정한 호스트 이름이 여러 개인 경우 뒤의 호스트 이름을 제대로 인식하지 못할 수 있는 문제(CUBRIDSUS-10344)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	HA 환경에서 databases.txt에 설정한 호스트 이름이 여러 개이고 뒤의 호스트 이름이 앞의 호스트 이름을 포함하는 문자열인 경우 뒤의 호스트 이름을 제대로 인식하지 못하는 문제를 수정했다. 예를 들어 수정 이전 버전에서 호스트 이름 리스트가 "node:node1"으로 설정되면 node1을 제대로 인식하지 못하게 되어, "node"가 슬레이브 노드이고 "node1"이 마스터 노드가 되는 경우 RW 브로커 응용 서버(CAS)는 "node1"을 인식하지 못하면서 이에 접속하지 못하게 된다.

HA 스키마 복제
--------------

Fixed a phenomenon in which the ALTER ... CHANGE COLUMN statement has not been reflected to the slave node (CUBRIDSUS-9649)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	Fixed a phenomenon in which the ALTER ... CHANGE COLUMN statement has not been reflected to the slave node. ::
	
		ALTER TABLE t1 CHANGE i2 i0 INTEGER FIRST;

응용 프로그램에서 처음 DB에 접속했던 사용자의 소유로 슬레이브 노드에 스키마가 복제되는 현상(CUBRIDSUS-6511)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	응용 프로그램에서 처음 DB에 접속했던 사용자의 소유로 슬레이브 노드에 스키마가 복제되는 현상으로, 예를 들어 user1 계정으로 DB에 접속했다가 종료한 후 다시 user2 계정으로 접속하여 테이블을 생성하면 슬레이브 노드에는 처음에 접속했던 user1 소유로 테이블이 생성되었다. 이 문제는 브로커 응용 서버(CAS)를 재시작하지 않는 한 지속되었으나, 이를 수정했다.

[검토]
^^^^^^
기본 키가 없는 테이블의 TRUNCATE 수행으로 인해 슬레이브 노드에 복제 반영이 지연되는 현상(CUBRIDSUS-6502)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	기본 키가 없는 테이블은 복제 대상이 아니므로 해당 테이블에 대한 TRUNCATE 문 수행이 복제되지 않도록 하여 슬레이브 노드의 복제 반영이 지연되는 현상을 수정했다.

[검토]
^^^^^^
자동 커밋 모드가 OFF일 때 AUTO_INCREMENT 칼럼이 있는 테이블에 INSERT를 수행하면 해당 시리얼에 복제 불일치 발생(CUBRIDSUS-9045)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	자동 커밋 모드가 OFF일 때 AUTO_INCREMENT 칼럼이 있는 테이블에 INSERT를 수행하면 해당 AUTO_INCREMENT를 관리하는 시리얼에 복제 불일치가 발생하는 현상을 수정했다. AUTO_INCREMENT는 db_serial 시스템 카탈로그 테이블에서 시리얼 값으로 관리되는 것을 확인할 수 있다.

[검토]
^^^^^^
함수 기반 인덱스 중 일부 함수에 대해 복제에 실패하는 문제(CUBRIDSUS-8977)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	함수 기반 인덱스 생성 시 함수 부분이 잘못된 값으로 복제되는 일부 함수들은 함수 기반 인덱스 생성 시 사용할 수 없도록 제한했다.
	
	함수 기반 인덱스 생성 시 허용하는 함수는 :ref:`allowed-function-in-function-index` 을 참고한다.

Sharding
--------


질의문에 두 개 이상의 shard 힌트가 있고 서로 다른 shard를 가리키는 경우 오류 처리하도록 수정(CUBRIDSUS-9395)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	질의문에 두 개 이상의 shard 힌트가 있고 서로 다른 shard를 가리키는 경우 첫번째 힌트의 shard를 사용했으나,
	모두 같은 shard가 아니면 오류 처리하도록 수정했다. ::

		SELECT * FROM student WHERE shard_key = /*+ shard_key */ 250 OR shard_key = /*+ shard_key */ 22

다수의 SHARD에 수행하는 SELECT가 실패하는 문제(CUBRIDSUS-9529)	
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	SHARD 환경에서 각각 독립된 트랜잭션으로 처음에 한 SHARD에 SELECT를 수행하고 난 후 다른 SHARD에 SELECT를 시도하면 실패하는 문제를 수정했다.

CUBRID SHARD의 메타 정보를 출력하는 명령 수행 시 해당 명령이 비정상 종료되는 문제(CUBRIDSUS-10375)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	shard.conf의 MAX_NUM_PROXY 파라미터 값을 2 이상으로 설정하여 다수의 shard proxy를 실행한 상태에서 "cubrid shard status -m"으로 CUBRID SHARD의 메타 정보를 출력하는 명령을 실행하면 해당 명령이 비정상 종료되는 문제를 수정했다.
 
shard.conf의 기본 설정에 PROXY_LOG_FILE로 잘못 지정된 이름을 PROXY_LOG_DIR로 수정(CUBRIDSUS-10381)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


드라이버
--------


[JDBC][CCI]질의 타임아웃 시간 계산 방식 개선(CUBRIDSUS-9585)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	질의를 서버에 전달할 때 질의 타임아웃 시간이 응용 프로그램 단에서 사용한 시간을 제외한 나머지 시간이 되도록 수정하여 실제 기대하는 질의 타임아웃에 맞도록 수정했다.
	
[JDBC][CCI]질의 타임아웃을 설정하면 fetch 도중에 질의 타임아웃이 발생하면서 실패하는 현상(CUBRIDSUS-9043)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	브로커 파라미터 MAX_QUERY_TIMEOUT, JDBC의 setQueryTimeout 메서드, 또는 연결 URL의 queryTimeout 속성으로 질의 타임아웃을 설정하면 fetch 도중에 질의 타임아웃이 발생하면서 실패하는 현상이 있었으나, 질의 execute 시간에만 타임아웃 발생이 가능하게 하고 fetch 도중에는 타임아웃이 발생하지 않도록 수정했다.

	또한, cci_execute_batch 함수와 cci_execute_array 함수에서는 질의 타임 아웃이 동작하지 않도록 수정했다. 

[JDBC][CCI]다중 질의 실행 함수에서 각각의 질의문을 실행하는 도중 교착 상태(deadlock)가 발생해도 이를 무시하고 나머지 질의를 계속 수행하는 문제(CUBRIDSUS-9692)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	JDBC의 PreparedStatement.executeBatch 메서드 또는 CCI의 cci_execute_array, cci_execute_batch와 같은 다중 질의 실행 함수에서 각각의 질의문을 실행하는 도중 교착 상태(deadlock)가 발생했음에도 불구하고 나머지 질의를 계속 수행하는 문제를 수정했다. 일반적인 오류가 발생하는 경우 나머지 질의를 계속 수행한다.

[검토]
^^^^^^
[JDBC][CCI]응용 프로그램에서 SHOW EXEC STATISTICS ALL 구문을 수행할 때 구문의 끝에 세미콜론(;)이 없으면 실패하는 현상(CUBRIDSUS-7430)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	응용 프로그램에서 SHOW EXEC STATISTICS ALL 구문을 수행할 때 구문의 끝에 세미콜론(;)이 없으면 실패하는 현상을 수정했다.
	CUBRID 매니저, 쿼리 브라우저 및 CSQL에서는 수정 이전 버전에서도 해당 현상이 발생하지 않았다.

[JDBC][CCI]CCI_U_TYPE_ENUM 타입 추가 및 ENUM 타입 조회 시 "VARCHAR"로 반환되는 문제 수정(CUBRIDSUS-10236)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	ENUM 타입 컬럼에 대한 CCI의 데이터베이스 타입(u_type)인 CCI_U_TYPE_ENUM을 추가했다.
 
	CCI_U_TYPE_ENUM은 CCI_A_TYPE_STR을 통해 값을 조회하거나 전달할 수 있다. ::
	
		cci_bind_param (req, 1, CCI_A_TYPE_STR, (char*) buffer, CCI_U_TYPE_ENUM, CCI_BIND_PTR);
		cci_get_data (req, 1, CCI_A_TYPE_STR, &buffer, &ind);
	 
	이와 함께 ENUM 타입에 대한 타입 조회 시 "VARCHAR"로 반환되던 문제들을 수정했다.
	
	#. JDBC DatabaseMetaData를 통한 타입 이름 조회 ::
	
		DatabaseMetaData dbmd = conn.getMetaData();
		rs = dbmd.getColumns(null, null, "tbl", null);
		while (rs.next()) {
		 String type = rs.getString("type_name");
		 System.out.println("Column type is:" + type);
		}
	 
	#. CCI의 cci_schema_info와 cci_get_result_info를 통한 타입 형식 조회 ::
	
		res_col_info = cci_get_result_info (req, &stmt_type, &col_count);
		 
		for (i = 1; i <= col_count; i++)
		{
		  printf ("resultset metadata - column type: %d\n",
			CCI_GET_RESULT_INFO_TYPE (res_col_info, i));
		}

[JDBC]예외 발생 시 메시지에 다양한 정보를 출력하도록 수정(CUBRIDSUS-9611)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	JDBC에서 예외 발생 시 메시지에 브로커 응용 서버(CAS) ID, CAS PID, SESSION ID, 연결 URL을 출력하도록 수정했다.

[JDBC]Fixed a phenomenon in which the executeBatch method has failed to be executed(CUBRIDSUS-9496)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	Fixed a phenomenon in which the executeBatch method of JDBC has failed to be executed and the "Cannot communicate with the broker or received invalid packet" error message was returned.

[JDBC]하나의 실행 함수로 여러 개의 질의 수행 도중 질의 계획 실패 등으로 인해 질의가 재시도되는 경우 일부 DML이 두 번 수행되는 현상(CUBRIDSUS-8472)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	하나의 실행 함수로 여러 개의 질의 수행 도중 질의 계획 실패 등으로 질의가 첫번째 질의부터 재시도되는 경우, 앞서 수행되었던 일부 DML이 롤백되지 않아 두 번 수행되는 문제가 발생했다. 수정 버전에서는 중간에 일부 DML이 실패하면 이전에 수행했던 DML도 모두 롤백하도록 하여 해당 문제를 수정했다. ::

		// 아래의 MULTI_STMT는 하나의 작업으로 간주한다.
		String MULTI_STMT = "INSERT INTO T1 VALUES (1, 1); INSERT INTO T1 VALUES (2, 2); UPDATE T2 SET A = 0";
		PreparedStatement p = c.prepareStatement(MULTI_STMT);
		boolean retval = p.execute();

[JDBC]자동 커밋 모드가 ON이고 커서 타입이 TYPE_FORWARD_ONLY인 상태에서 업데이트 가능하게 설정한 결과 셋에 대해 updateRow()를 수행하면 예외 처리되는 문제(CUBRIDSUS-9313)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	자동 커밋 모드가 ON이고 커서 타입이 TYPE_FORWARD_ONLY인 상태에서 업데이트 가능하게 설정한 결과 셋(resultSet)에 대해 updateRow()를 수행하면 "Internal server error"로 예외 처리되는 문제를 수정했다. 수정 이전 버전에서는 커서 타입이 TYPE_SCROLL_SENSITIVE인 경우에만 결과 셋의 업데이트가 가능했으나, 수정 이후 모든 커서 타입(ResultSet.TYPE_FORWARD_ONLY, ResultSet.TYPE_SCROLL_INSENSITIVE, or ResultSet.TYPE_SCROLL_SENSITIVE)에 대해 결과 셋의 업데이트가 가능하게 되었다. ::

		conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_UPDATABLE);
		...
		rs.updateNull("col2");
		rs.updateRow();

[JDBC]연결 URL에서 connectTimeout을 설정해도 altHost로 재연결을 시도하지 않는 문제(CUBRIDSUS-10240)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	JDBC에서 URL에 connectTimeout을 설정해도 connectTimeout으로 인한 altHost 재연결을 시도하지 않고 오류가 발생하는 문제를 수정했다.

[JDBC]응용 프로그램에서 Statement를 닫지 않았음에도 불구하고  PreparedStatement.clearParameter() 메서드 호출 시 예외 발생(CUBRIDSUS-10274)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	JDBC 응용 프로그램에서 사용자가 DB 연결을 종료하지 않았고 Statement를 닫지 않았음에도 불구하고 PreparedStatement.clearParameter() 메서드를 호출하면 'Connection or Statement might be closed' 예외가 발생하는 현상을 수정했다.

[CCI]Modified a phenomenon in which the statement has not been removed from the statement pool when an SQL was prepared twice (CUBRIDSUS-9397)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	When a SQL statement has been prepared twice on one DB connection, the second statement was not closed on the statement pool being used even if the statement was closed. This problem has been fixed.

[CCI]Fixed a phenomenon in which the CCI application has been abnormally terminated when NULL has been entered as the pointer value in the function which used the T_CCI_ERROR structure pointer in the CCI application (CUBRIDSUS-9435)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	Fixed a phenomenon in which the CCI application has been abnormally terminated when NULL has been entered as the pointer value in the function which used the T_CCI_ERROR structure pointer in the CCI application such as cci_datasource_release.
	
[CCI]CCI_EXEC_ASYNC 옵션을 사용해서 SELECT 질의 수행 이후 페치가 완료되면 CCI_NO_MORE_DATA가 아닌 CAS_NO_MORE_DATA 오류가 발생하는 현상(CUBRIDSUS-7170)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	CCI_EXEC_ASYNC 옵션을 사용해서 비동기 모드로 SELECT 질의 수행 이후 페치가 완료되면 CCI_NO_MORE_DATA 오류가 발생해야 하나 CAS_NO_MORE_DATA 오류가 발생하는 현상을 수정했다. ::
	
		res = cci_execute(req, CCI_EXEC_ASYNC, 0, &error);

[CCI] Fixed a phenomenon in which the CCI application for windows infinitely waited when there was no DB server to connect (CUBRIDSUS-9361)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[CCI] 질의를 다중 처리하는 함수들에서 질의 결과를 받는 인자에 NULL이 입력되면 응용 프로그램이 비정상 종료하는 현상(CUBRIDSUS-9600)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	질의를 다중으로 처리하는 cci_execute_batch, cci_execute_array, cci_execute_result 함수들에서 질의 결과를 받는 인자에 NULL이 입력되면 "invalid argument"라는 오류 메시지를 출력하도록 수정했다.

[CCI] CCI_PREPARE_HOLDABLE 플래그 설정을 했는지 여부를 확인하는 함수 추가(CUBRIDSUS-8803)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	cci_prepare 함수에서 CCI_PREPARE_HOLDABLE 플래그 설정을 했는지 여부를 확인하는 cci_is_holdable 함수를 추가했다. ::
	
		holdable = cci_is_holdable(req_handle);

[CCI] double 값이 128자리 이상인 값을 cci_get_data(CCI_A_TYPE_STR)으로 읽는 경우 응용 프로그램이 비정상 종료하는 현상(CUBRIDSUS-9756)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[CCI]datasource에서 사용한 연결을 닫은 후 연결 핸들을 그대로 다시 사용하면 응용 프로그램이 비정상적으로 동작하는 문제(CUBRIDSUS-9586)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	datasource를 사용하는 CCI 응용 프로그램에서 사용한 연결을 닫은 후 연결 핸들을 그대로 다시 사용하면 응용 프로그램이 비정상적으로 동작했으나 오류를 출력하도록 수정했다. ::

		con_1 = cci_datasource_borrow(ds, &error);
		cci_prepare_and_execute(con_1, query, 1, &exec_retval, &error);
		ret = cci_datasource_release(ds, con_1, &error);
		ret = cci_prepare_and_execute(con_1, query, 1, &exec_retval, &error);
		
[검토]
^^^^^^	
[CCI]cci_prepare 함수 호출 과정에서 내부적으로 PREPARE를 재시도하면서 메모리 누수 현상 발생(CUBRIDSUS-10053)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	cci_prepare 함수 호출 과정에서 내부적으로 PREPARE를 재시도하면서 발생하는 메모리 누수 현상을 수정했다.
	
[PHP]웹 페이지 로딩을 중단했음에도 불구하고 서버 단에서는 수행 중이던 질의가 중단되지 않는 현상(CUBRIDSUS-5855)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	PHP 응용 웹사이트에서 페이지 로딩을 중단했음에도 서버 단에서는 수행 중이던 질의가 중단되지 않는 현상을 수정했다. 수정 이전 버전에서 사용자가 장시간의 질의 수행을 요구하는 웹 페이지에 대해 로딩 중단을 반복하면 웹 서버 단에서 해제해도 되는 연결 리소스가 늘어나는 현상이 발생한다.

[CCI]모든 테이블에 대한 트리거 정보를 얻기 위해 cci_schema_info 함수 실행 시 가장 마지막 값을 페치한 이후에 CCI_ER_NO_MORE_DATA 오류를 반환하지 않는 현상(CUBRIDSUS-9438)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	모든 테이블에 대한 트리거 정보를 얻기 위해 cci_schema_info 함수 실행 시 가장 마지막 값을 페치한 이후에 CCI_ER_NO_MORE_DATA 오류를 반환하지 않는 현상을 수정했다. ::
 
		req = cci_schema_info(conn, CCI_SCH_TRIGGER, NULL, NULL, CCI_CLASS_NAME_PATTERN_MATCH, &error); 
 

유틸리티
--------

CSQL에서 결과 출력 시 칼럼의 길이를 제한하는 기능 추가(CUBRIDSUS-9643)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	CSQL에서 결과 출력 시 칼럼의 길이를 제한하는 기능을 추가했다.
	
	* ;STring-width는 문자열 타입과 비트 타입의 칼럼에 한해 출력 길이를 제한하는 CSQL 세션 명령어이다. CSQL 유틸리티 실행 시 --string-width는 옵션으로도 제공한다.
	* ;COLumn-width는 타입 구분 없이 모든 칼럼의 출력 길이를 제한하는 CSQL 세션 명령어이다.

Changed the CSQL line-output setting to be configurable with the CSQL session command and the SQL execution time to be printed out by default (CUBRIDSUS-9537)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	Changed the CSQL --line-output setting to be configurable with the CSQL session command. ::
	
		csql> ;line-output on
		csql> ;line-output off
		
	And, changed to output the query execution time as default.

Fixed to allow additional connection by using --sysadm in the CSQL even when the maximum number of connection to server has been exceeded (CUBRIDSUS-9478)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	Fixed to allow only one connection with the system administrator mode (--sysadm) in the CSQL even when the maximum number of connection to server, which has been set by the value of the system parameter max_clients has been exceeded. ::
	
		csql -u dba --sysadm testdb

[검토]
^^^^^^
Windows에서 CSQL의 ;historylist와 ;historyread 명령 수행 시 지원하지 않는다는 오류를 출력하도록 수정(CUBRIDSUS-10190)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

로컬 호스트 DB에 접속한 CSQL에서 ;database 실행 시 호스트 이름을 출력하도록 변경(CUBRIDSUS-5243)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	로컬 호스트 DB에 접속한 CSQL에서 ;database 실행 시 "localhost"가 아닌 호스트 이름을 출력하도록 변경했다. ::
	
		csql> ;database
		testdb@cubridhost

[검토]
^^^^^^
CSQL에서 커멘트에 작은 따옴표가 홀수 개 존재하면 다음 줄에서 CSQL 세션 명령어가 동작하지 않는 현상(CUBRIDSUS-8999)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	::
	
		csql> --it's a test
		csql> ;exit

[검토]
^^^^^^
CSQL의 라인 입력 루틴에서 메모리 누수 현상(CUBRIDSUS-10293)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[검토]
^^^^^^ 
CSQL 세션 명령어인 ";SC", ";TR"에 각각 스키마 이름과 트랜잭션 이름으로  Ä같은 액센트 문자를 사용할 수 없는 문제(CUBRIDSUS-9923)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	::
	
		CREATE TABLE tÄ(i INT) // Ä는 액센트 문자(accented character)이다.

		// 수정 이전 버전에서 아래 명령을 수행하면 해당 테이블을 찾지 못하는 문제가 발생한다.
		csql> ;sc tÄ
		
CSQL 세션 명령어인 ";read" 수행 시 파일 이름 뒤에 공백 문자가 오면 수행에 실패하는 현상(CUBRIDSUS-10357)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	아래 명령 수행 시 test.txt 뒤에 공백 문자가 오면 오류가 발생하는 현상을 수정했다. ::
		csql> ;read test.txt 
		ERROR: Too many file names have been entered.

[검토]
^^^^^^
Windows용 CSQL에 매우 긴 질의문 수행 시 비정상 종료하는 현상(CUBRIDSUS-9315)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	Windows용 CSQL에 매우 긴 질의문 수행 시 허용되는 스택 메모리 크기를 1M에서 8M로 늘려 스택 사용량이 1M를 초과해도 8M 이내에서 사용되면 비정상 종료되지 않도록 수정했다.

[검토]
^^^^^^
자바 저장 프로시저가 있으면 unloaddb 명령 수행 후 loaddb 수행 시 실패하는 현상(CUBRIDSUS-1520)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	자바 저장 프로시저가 있으면 unloaddb 수행 후 해당 스키마 파일로 loaddb 수행 시 실패하는 현상을 수정했다.

[검토]
^^^^^^
loaddb에 특정 에러를 무시하도록 설정한 경우 제약 조건을 위배하는 데이터가 입력되는 현상(CUBRIDSUS-7650)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	loaddb에 --error-control-file=FILE 옵션을 지정하여 특정 에러를 무시하도록 설정한 경우 제약 조건을 위배하는 데이터가 입력되는 현상, 예를 들어 FILE에 NULL 에러를 무시하도록 -205를 설정했는데, 기본 키 칼럼에 NULL 데이터가 입력되는 현상이 존재했다. 에러가 발생하면 해당 데이터는 입력하지 않도록 수정했다.

[검토]
^^^^^^
loaddb 수행 시 잘못된 오류 위치와 중복된 메시지를 출력하는 현상(CUBRIDSUS-7894)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Modified a phenomenon in which the loaddb schema file has failed or has been loaded with a wrong value when the schema file included a string which has ended with a backslash ("\") (CUBRIDSUS-9109)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

loaddb에서 INTEGER 타입의 범위를 벗어나는 BIGINT 값을 NUMERIC 타입 칼럼에 입력할 때 실행에 실패하는 현상(CUBRIDSUS-7869)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	loaddb에서 INTEGER 타입의 범위를 벗어나는 BIGINT 값을 NUMERIC 타입 칼럼에 입력할 때 NUMERIC 타입의 자릿수(precision)가 19자리 미만이면 "A domain conflict exists on attribute" 오류와 함께 실행에 실패하는 현상을 수정했다. 예를 들어 수정 이전 버전에서 11자리 숫자를 NUMERIC(15) 타입 칼럼에 로드하려고 하면 해당 오류가 발생했다.
	
	::
	
		CREATE TABLE tbl(a NUMERIC(15)); 

		$ vi a.dat
		%class tbl(A)
		12345678901
		
		//수정 이전 버전에서 아래 명령어는 오류와 함께 실행에 실패했다.
		cubrid loaddb -u dba -v -d a.dat demodb 

[검토]
^^^^^^
unloaddb 명령을 수행할 데이터베이스에 역순의 PREFIX 인덱스가 존재하면 실패하는 현상(CUBRIDSUS-9966)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[검토]
^^^^^^
unloaddb 수행 시 db_collation이 시스템 카탈로그 뷰임에도 불구하고 데이터 파일을 생성하는 문제(CUBRIDSUS-10350)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	unloaddb 수행 시 db_collation에 대해 데이터 파일을 생성하는 문제가 존재했으나 생성하지 않도록 수정했다.
	9.0 Beta 버전에서 9.1 버전으로 데이터를 마이그레이션하는 경우 unloaddb/loaddb 명령을 사용하면 시스템 카탈로그 뷰에 대한 데이터 로딩을 시도하면서 오류가 발생할 수 있으므로, 언로드된 파일에서 db_collation 부분을 제거하거나 unloaddb/loaddb 명령 대신 "migrate_90beta_to_91 <db_name>"을 사용할 것을 권장한다.

checkdb 수행 중 ctrl-C를 눌러도 서버에서는 checkdb 작업을 계속 수행하는 문제(CUBRIDSUS-7452)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	레코드 건수가 많은 테이블에 인덱스가 존재할 때 인덱스를 점검하기 시작하면 ctrl-C를 눌러 인터럽트를 발생시켜도 정지하지 않고 인덱스 점검을 지속하는 문제를 수정했다.

killtran 명령으로 트랜잭션을 종료할 때 종료된 트랜잭션의 질의문이 오류를 반환하지 않는 문제(CUBRIDSUS-10133)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	질의를 수행중인 트랜잭션을 killtran으로 종료하면 해당 트랜잭션에서 수행중인 질의문의 결과로 아무런 오류가 반환되지 않는 문제가 존재했으나, killtran으로 종료되는 질의문이 "Has been interrupted" 오류를 반환하도록 수정했다.
	해당 오류 이후 수행되는 질의문은 기존과 마찬가지로 "Your transaction has been aborted by the system due to server failure or mode change" 오류를 반환받는다.

plandump 명령 실행 또는 슬로우 쿼리 로그 출력 시 질의 원문이 포함되지 않는 문제(CUBRIDSUS-9593)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	cubrid plandump 명령을 실행하여 질의 계획 대상이 되는 질의를 출력하거나 서버 에러 로그 혹은 브로커 로그에 슬로우 쿼리(slow query)를 출력할 때 기존에는 재작성된(rewritten) 질의문만 출력했으나 사용자가 입력한 질의 원문도 포함하도록 수정했다.

[검토]
^^^^^^
dumplocale 명령 수행 시 cubrid_locales.txt의 내용에 존재하지 않는 로캘 라이브러리의 로캘이 포함되어도 오류가 발생하지 않는 문제(CUBRIDSUS-10306)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	로캘 라이브러리의 내용을 출력하는 dumplocale 명령 수행 시 cubrid_locales.txt의 내용에 존재하지 않는 로캘 라이브러리의 로캘이 포함되어도 오류가 발생하지 않았으나 오류가 발생하도록 수정했다. 예를 들어 ko_KR 로캘 라이브러리만 존재하는데 cubrid_locales.txt에 ko_KR, de_DE가 설정되어 있으면 수정 이후 버전에서는 de_DE의 로캘 라이브러리가 존재하지 않음을 감지하고 오류 메시지를 출력한다.

Fixed a problem in which the broker is abnormally terminated as executing broker_log_top when ')' came in front of the string binding value as the first character (CUBRIDSUS-9245)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

broker_log_top 의 입력 파일 형식이 잘못될 경우 비정상 종료하는 문제(CUBRIDSUS-10072)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[검토]
^^^^^^
Windows에서 broker_log_top 수행에 실패하는 현상(CUBRIDSUS-10139)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Fixed a problem in which backup could not be stopped when the checkpoint operation was being executed (CUBRIDSUS-9337)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	Fixed a problem in which backup could not be stopped by using INTERRUPT (Ctrl+C) when the checkpoint operation was being executed while executing the backup.

Modified to cancel the checkpoint when it took 1 minute or more to execute termination of the database because of the checkpoint (CUBRIDSUS-6867)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	The database was set to be terminated by force when it took 1 minute or more to execute termination of the database by using the cubrid server stop command. When it took a long time to operate the checkpoint during shutdown, the database server was terminated by force, causing a long time to recover the database when restarting the database. This was fixed to cancel the checkpoint process and terminate the database when a timeout occurred during shutdown.

브로커 상태 정보 출력 시 client wait CAS 개수가 전체 CAS 개수보다 많이 출력되는 현상(CUBRIDSUS-10235)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	cubrid broker status -f 명령으로 브로커 상태 정보를 출력할 때, CAS 개수가 최소 개수보다 늘었다가 줄어들면 CLIENT WAIT 상태의 CAS 개수가 전체 CAS 개수보다 많이 출력되는 현상을 수정했다.

[검토]
^^^^^^
Windows용 CUBRID에서 데이터베이스 생성 명령 실행 도중 ctrl+C로 중단하는 경우 비정상 종료하는 현상(CUBRIDSUS-9332)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

shard_broker_changer를 수행하여 변경하려는 파라미터 값이 잘못된 값으로 변경되는 문제(CUBRIDSUS-9956)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	SQL_LOG, SLOW_LOG, PROXY_LOG 등의 파라미터 값을 shard_broker_changer를 통해 변경하려고 시도하면 잘못된 값으로 설정되는 문제를 수정했다.

브로커 상태 정보 출력 시 "-s N" 옵션을 주면 누적 정보에 해당하는 ERR-Q 정보가 초당 오류 질의 개수로 출력되는 문제(CUBRIDSUS-10391)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	브로커 상태 정보 출력 시 QPS, TPS 정보를 N초마다 갱신하도록 하는 "-s N" 옵션을 주면 ERR-Q 정보에 대해 초당 오류 질의 개수를 출력했으나 N초 동안의 오류 질의 개수를 출력하도록 수정했다.  수정 이후 버전에서도 "-s N" 옵션을 주지 않으면 ERR-Q 정보에 대해 브로커 시작 이후의 누적 정보를 출력한다.

오류 메시지
-----------

[검토]
^^^^^^
Windows에서 CSQL의 ";append" 세션 명령어 수행 시 잘못된 오류 메시지를 출력하는 문제(CUBRIDSUS-10191)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	Windows에서 CSQL의 ";append" 세션 명령어 수행 시 "ERROR: A file name is required."를 출력하도록 수정했다.
	수정 이전 버전에서는 "ERROR: Permission denied" 또는 "ERROR: Too many file names have been entered."를 출력했다.


데이터베이스 생성 시 디스크 여유 공간이 부족할 때 출력하는 메시지 보완(CUBRIDSUS-6623)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	데이터베이스 생성 시 디스크 여유 공간이 부족할 때 출력하는 메시지에 필요한 공간을 출력하도록 수정했다. ::
	
		Creating database with 512.0M size. The total amount of disk space needed is 1.5G.
		Couldn't create database.
		Unable to create volumes for database "ramdiskdb". Please refer "/home1/ptyjj/CUBRID/log/ramdiskdb_createdb.err" for additional information.
		
Modified a phenomenon of outputting a warning message When DML is executed in the environment configured to output a warning(CUBRIDSUS-9458)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	Modified a phenomenon of outputting a warning message when normal INSERT/UPDATE/DELETE was executed in the environment configured to output a warning.
	
일부 에러 메시지에서 64비트 int 값을 출력할 때 32비트 int 보다 큰 값이면 잘못된 값을 출력하는 문제(CUBRIDSUS-8379)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	일부 에러 메시지에서 64비트 int 값을 출력할 때 32비트 int 보다 큰 값이면 잘못된 값을 출력하는, 예를 들어 25782386688을 12582912로 잘못 출력하는 문제를 수정했다.

[검토]
^^^^^^
특정 질의에서 에러 메시지가 여러 번 반복하여 출력되는 현상(CUBRIDSUS-3096)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	::

		CREATE TABLE t1(a int);
		CREATE TABLE t2(a int);
		CREATE VIEW v1 AS SELECT * FROM t1;
		CREATE VIEW v2 AS SELECT * FROM t2;
		DROP TABLE t1, t2;
		SELECT * FROM (SELECT * FROM v1), (SELECT * FROM v2);

		In line 1, column 18,

		ERROR: before '  [t1]'
		Unknown class "t1".


		In line 1, column 15,

		ERROR: before '  [t2]'
		Unknown class "t2".


		In line 1, column 18,

		ERROR: before '  [t1]'
		Unknown class "t1".


		In line 1, column 15,

		ERROR: before '  [t2]'
		Unknown class "t2".

질의 수행 시 오류 로그에 같은 오류 메시지가 중복해서 출력되는 현상(CUBRIDSUS-9885)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	error log level을 notification 으로 설정하고 질의 수행 시 오류 로그에 같은 오류 메시지가 중복해서 출력되는 현상을 수정했다.
		
CUBRID SHARD proxy에서 인증 실패 시 적절한 에러 메시지를 출력하도록 수정(CUBRIDSUS-8839)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	CUBRID SHARD proxy에서 인증 실패 시에도 에러 메시지를 출력하지 않았으나, 적절한 에러 메시지를 출력하도록 수정했다.

	::
		Authorization error.(Address is rejected)

[검토]
^^^^^^
하나의 응용 프로그램에서 20개를 초과하여 PREPARE 문을 수행할 때 발생하는 오류 메시지를 잘못 출력하는 문제(CUBRIDSUS-8998)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	하나의 응용 프로그램에서 20개를 초과하여 PREPARE 문을 수행할 때 "ERROR: Too many prepared statements." 오류 메시지를 출력해야 하나, "ERROR: No error message available."로 잘못 출력하는 문제를 수정했다.

[검토]
^^^^^^
분할 테이블에 대해 생성한 뷰를 지정한 범위를 넘어서 업데이트할 때 오류 메시지를 잘못 출력하는 현상(CUBRIDSUS-9011)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	분할 테이블에 대해 생성한 뷰를 지정한 범위를 넘어서 업데이트할 때 출력하는 오류 메시지에 "2 rows affected."가 잘못 출력되는 현상을 수정했다.

	::
	
		CREATE TABLE t(i INT) PARTITION BY RANGE(i) (PARTITION p0 VALUES LESS THAN(3));
		INSERT INTO t VALUES (1),(2);
		CREATE VIEW v as SELECT * FROM t;
		UPDATE v SET i=i+1;

		// 위의 질의 결과로 출력되는 아래의 오류 메시지 중 "2 rows affected."는 출력되지 않아야 한다.
		2 rows affected.
		ERROR: Appropriate partition does not exist.

[검토]
^^^^^^
DB 생성 시 범위를 벗어난 볼륨 크기를 입력하면 출력하는 오류 메시지 개선(CUBRIDSUS-9761)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	DB 생성 시 범위를 벗어난 볼륨 크기를 입력 단위 없이 입력하면 Byte(B) 단위로 입력되었다는 것을 오류 메시지에 포함하여 출력하도록 수정했다.

	::
		cubrid createdb asdf --db-volume-size=1121
		Couldn't create database.
		The given 'db_volume_size', 1121B is out of range. Choose a size between 20.0M and 20.0G.

[검토]
^^^^^^
CLOB_FROM_FILE 또는 BLOB_FROM_FILE 함수에서 잘못된 경로의 파일이 입력되면 상황에 맞지 않는 오류 메시지를 출력하는 현상(CUBRIDSUS-10320)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	CLOB_FROM_FILE 또는 BLOB_FROM_FILE 함수에서 잘못된 경로의 파일이 입력되면 "해당 경로가 유효하지 않다"는 오류 메시지를 출력하도록 수정했다.
	
	::
	
		SELECT CLOB_FROM_FILE('file:/home/cubrid/databases/lob/ces_722/image_t.00001357286783349177_590');

		// 4.3 이하 버전에서는 다음 오류를 출력했다.
		ERROR: Cannot coerce clob to type unknown data type.

		// 9.0 Beta에서는 다음 오류를 출력했다.
		Attempted to create string with illegal length - 1545942208

[검토]
^^^^^^
Windows에서 서비스가 정상 종료되지 않는 경우에도 메시지가 정상 종료된 것으로 잘못 출력되는 문제(CUBRIDSUS-10143)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	Windows에서 "cubrid service stop" 명령을 수행하면 cubrid.conf의 services에 등록된 프로세스들이 모두 정상 종료되지 않았음에도 "++ cubrid service stop: success" 라는 메시지를 출력하는 문제를 수정했다.

[검토]
^^^^^^
Windows에서 서버가 구동된 상태에서 서버 시작을 실행하면 잘못된 메시지가 출력되는 현상(CUBRIDSUS-10216)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	Windows에서 서버가 구동된 상태에서 "cubrid start"를 실행하면 "cubrid server start: success" 메시지가 출력되었으나 "cubrid server is already running" 메시지가 출력되도록 수정했다.

[CCI]cci_connect_with_url_ex 함수에서 오류 버퍼에 부정확한 오류  메시지가 담기는 현상(CUBRIDSUS-10234)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	cci_connect_with_url_ex 함수에서 오류가 발생하면 정확한 메시지가 오류 버퍼에 저장되지 않고 "DBMS Error"가 저장되는 현상을 수정했다.
	예를 들어 잘못된 암호를 입력하면 "Incorrect or missing password" 오류 메시지가 저장되어야 한다.

브로커 응용 서버(CAS)의 재시작 이전 종료 시점에 해당 프로세스의 메모리 사용량을 CAS 로그에 출력하도록 수정(CUBRIDSUS-10181)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	브로커 응용 서버(CAS)가 메모리 사용량 최대값인 cubrid_broker.conf의 APPL_SERVER_MAX_SIZE 초과로 인해 재시작하기 전 종료 시점에 해당 프로세스의 메모리 사용량을 CAS 로그에 출력하도록 수정했다. ::
 
		01/10 18:43:42.217 (0) CAS MEMORY USAGE (101M) HAS EXCEEDED MAX SIZE (101M)

설정, 빌드 및 설치
------------------

Windows에서 브로커 파라미터의 경로 구분자로 /를 쓸 수 없는 문제 및, ACCESS_CONTROL_FILE 파일 내용에서 "드라이버명:"이 잘못 인식되는 문제(CUBRIDSUS-9318)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	Windows에서 브로커 파라미터의 경로 구분자로 /를 쓸 수 있게 수정했다. ::
	
		D:/dir/dir/file

	또한, ACCESS_CONTROL_FILE 파일 내용을 "db_name:db_user_id:IP_file" 포맷으로 기록할 때 IP_file이 "드라이버명:\경로\파일명"과 같이 기록될 경우, 드라이버명 뒤의 ":"을 값의 구분자로 오인하여 파일을 제대로 인식하지 못하는 문제를 수정했다.
	
정의되지 않은 시스템 파라미터가 cubrid.conf에 존재하면 서버 구동 시 비정상 종료하는 현상(CUBRIDSUS-9765)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

일부 시스템 파라미터를 시스템 운영 중에 변경할 수 있도록 수정(CUBRIDSUS-7625)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	다음의 시스템 파라미터들은 시스템 운영 도중 변경할 수 있도록 수정했다. ::

		index_scan_oid_buffer_size
		sort_buffer_size
		temp_file_memory_size_in_pages
		unfill_factor
		volume_extension_path
		lock_escalation
		checkpoint_every_npages
		async_commit
		access_ip_control
		access_ip_control_file
		index_unfill_factor

	또한, CSQL에서 ;get 명령으로 시스템 파라미터 값을 구할 때 발생하는 다음 현상들을 수정했다.
	
	* ;get access_ip_control_file을 수행하면 CSQL이 비정상 종료
	* ;get unfill_factor을 수행하면 잘못된 결과를 출력
	* 정의되지 않은 시스템 파라미터에 대해 ;get 명령을 수행하여 실패한 후에는 정의된 시스템 파라미터를 가지고 ;get 명령을 수행해도 계속 실패

CUBRID 소스 파일에서 CCI 드라이버만 빌드하는 옵션 추가(CUBRIDSUS-8247)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	CUBRID 소스 파일에서 CCI 드라이버만 빌드할 수 있도록 configure 스크립트에 --with-cci-only 옵션을 추가했다.
	또한, CCI 드라이버만 빌드할 수 있는 소스 패키지를 별도로 배포하게 되었다.

셸 스크립트 설치 패키지 실행 시 라이선스 동의 요청 단계의 입력 방식 수정(CUBRIDSUS-9410)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	셸 스크립트 설치 패키지 실행 시 라이센스 동의를 요청하는 단계에서 엔터를 치면 no를 입력한 것으로 동작했으나 엔터를 쳐도 yes 혹은 no의 입력을 계속 요구하도록 수정했다.

브로커 파라미터 SQL_LOG의 값이 NOTICE로 설정되어 있어도 SQL 로그에 정상 수행된 질의가 가끔 출력되는 현상(CUBRIDSUS-10286)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	cubrid_broker.conf의 SQL_LOG 값이 NOTICE로 설정되어 있어도 정상 수행된 질의가 가끔 출력되는 현상이 발생할 가능성을 줄이도록 수정했다. 

[검토]
^^^^^^
Windows에서 브로커 파라미터 값이 잘못되었음에도 불구하고 브로커 구동 시 정상 구동되었다는 메시지가 출력되는 문제(CUBRIDSUS-9992)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	Windows에서 브로커 파라미터 값이 잘못되었으면 브로커를 구동할 수 없다는 오류 메시지가 정상 출력되도록 수정했다.

[검토]
^^^^^^
Windows에서 DB 서버 구동 시 데이터베이스 섹션에 설정된 파라미터가 정상인지 여부를 확인하지 않는 문제(CUBRIDSUS-10110)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Windows용 CUBRID 설치 시 클라이언트만 설치를 선택했는데 전체 설치되는 문제(CUBRIDSUS-9746)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Windows에서 CUBRID 엔진 설치 중 Java 설치 여부에 따른 알림 메시지 수정(CUBRIDSUS-9917)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	Windows에서 CUBRID 엔진 설치 중 Java 1.6 이상 버전이 설치되지 않았으면 CUBRID Manager를 사용할 수 없다는 메시지를 출력했으나, 이 메시지는 CUBRID 엔진과는 무관한 메시지이므로 이 메시지 대신 자바 저장 프로시저를 사용할 수 없다는 메시지를 출력하도록 수정했다.

기타
----

A problem in which an error log of the broker and the database server was not recreated when it was randomly deleted (CUBRIDSUS-8351)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	There was a problem in which an error log of the broker and the database server was not recreated when it was randomly deleted. It has been fixed and the deleted error log is recreated.

Fixed a problem in which a broker was abnormally terminated when an application connected to the broker with a long broker name (CUBRIDSUS-9392)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	A broker was abnormally terminated when an application connected to the broker with a long broker name (32 characters or longer). The problem was fixed by allowing the length of a broker name to 63 characters and making the broker not to be started when the broker name was longer than 63 characters. 


Modified a problem of sending a wrong error instead of the error which has occurred in the db server when an INTERRUPT has occurred in the broker application server (CUBRIDSUS-9450)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	When an INTERRUPT occurred in the broker application server (CAS), the error which has occurred in the DB server was sent as another error. This problem has been fixed.


CAS가 CLIENT WAIT인 상태에서 동작을 멈추는 현상(CUBRIDSUS-10238)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	
Windows 서비스 프로세스인 CUBRIDService에 설명 추가(CUBRIDSUS-8917)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	CUBRID의 Windows 서비스 프로세스인 CUBRIDService에 다음 설명(description)을 추가했다.
	이 설명은 Windows의 "제어판 > 시스템 및 보안 > 관리 도구 > 서비스 > CUBRIDService"에서 확인할 수 있다. ::

		Service to execute master,broker,database server and manager server processes for CUBRID.
		Service start/stop menu is equal to the command of "cubrid service start/stop".
		If you setup "startup type" of this service to "Disabled", you can't use "cubrid service" command.

응용 클라이언트의 접속 정보는 에러 로그에서 제거하고 접속 로그에 기록하도록 수정(CUBRIDSUS-5962)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	에러 로그에 너무 많은 정보가 기록되어 실제 에러를 파악하기 용이하게 하기 위해, 응용 클라이언트의 접속 정보는 에러 로그에서 제거하고 접속 로그에 기록하도록 수정했다.

중복되는 키가 많아지면서 인덱스 분할 오류로 인해 INSERT 질의에 실패하는 문제(CUBRIDSUS-9829)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

교착 상태를 감지하지 못하고 동작을 멈추는 현상(CUBRIDSUS-10009)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	INSERT와 UPDATE를 동시에 수행하는 도중 교착 상태(deadlock)가 발생하면 이를 감지하지 못하고 모든 트랜잭션이 동작을 멈추는(hang) 현상을 수정했다.

[검토]
^^^^^^
CUBRID 관련 프로세스를 구현한 코드에서 재진입 가능한 함수만 사용하도록 수정(CUBRIDSUS-8374)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	다중 스레드 실행 환경에서 안전한 수행(thread safe)을 위해 CUBRID 관련 프로세스에서 사용되었던 재진입 가능하지 않은  ctime, localtime, rand, drand48, lrand48, strtok 함수들을 모두 재진입 가능한 ctime_r, localtime_r, rand_r, drand48_r, lrand48_r, strtok_r 함수들(reentrant functions)로 대체했다.

[검토]
^^^^^^
CUBRID Manager에서 DB 사용자를 편집하지 못하는 현상(CUBRIDSUS-9971)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	CUBRID Manager에서 DB 사용자의 비밀번호 또는 그룹 변경과 같은 편집 기능을 수행하지 못하는 현상을 수정했다. 이 현상은 9.0 Beta에서만 발견되었다.

체크포인트 이후에도 보관 로그가 정리되지 않는 현상(CUBRIDSUS-9848)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	복구 시간 단축을 위해 데이터를 DB 볼륨에 갱신(flush)하는 체크포인트 수행 이후에도 보관 로그가 정리되지 않는 현상을 수정했다.
	데이터의 갱신이 빈번한 상황에서 체크포인트가 수행되면 이 현상이 발생할 가능성이 높다.
	수정 이전 버전에서는 해당 현상 발생 시 체크포인트 발생 시점이 갱신되지 않아 보관 로그를 유지해야 했으나 수정 이후 체크포인트 발생 시점 이전의 보관 로그는 정리되고 체크포인트 발생 시점은 갱신되게 되었다. 		

주의 사항
=========

신규 주의 사항
--------------

9.1 버전과 9.0 베타 버전 사이에 DB 볼륨 호환 안 됨(CUBRIDSUS-10147)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	9.1 버전과 9.0 베타 버전 사이에 DB 볼륨이 호환되지 않게 됨에 따라 CUBRID 9.0 Beta를 9.1로 업그레이드하는 사용자는 CUBRID 9.1 설치 이후 기존의 DB 볼륨을 9.1용으로 반드시 변환해야 한다.

		migrate_90beta_to_91 <db_name>

9.0 Beta 이전 버전과 DB 볼륨이 호환되지 않음(CUBRIDSUS-5238)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	9.0 Beta 이전 버전과 DB 볼륨이 호환되지 않으므로 cubrid unloaddb/loaddb를 이용하여 데이터를 마이그레이션해야 한다. 보다 자세한 사항은 매뉴얼의 "업그레이드" 절을 참고한다.

.. note:: 9.0 Beta 버전 사용자는 드라이버, 브로커, DB 서버 모두를 반드시 업그레이드해야 하며, DB 볼륨이 9.1과 호환되지 않으므로 반드시 데이터 마이그레이션을 해야 한다.
	업그레이드 및 데이터 마이그레이션은 :doc:`/upgrade` 를 참고한다.
The DB volume is not compatible with the previous versions (CUBRIDSUS-5238)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	As the DB volume is not compatible with the versions before 9.0 Beta, it is necessary to migrate data by using cubrid unloaddb/loaddb. For more information, see :doc:`/upgrade`."

CUBRID_LANG 이 제거되고,  DB 생성에 CUBRID_CHARSET 및 메시지 출력에 CUBRID_MSG_LANG 사용
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	9.1 버전부터 CUBRID_LANG 환경 변수는 더 이상 사용되지 않으며, 
	데이터베이스를 생성하거나 구동할 때 CUBRID_CHARSET 환경 변수를 통해 어떤 문자셋을 사용할 지 결정하므로 CUBRID_CHARSET 환경 변수를 반드시 설정해야 함에 주의한다.
	유틸리티 메시지 및 오류 메시지를 출력할 때는 CUBRID_MSG_LANG 환경 변수를 사용하며 설정하지 않으면 en_US가 기본으로 설정된다.

CCI 응용 프로그램에서 여러 개의 질의를 한 번에 수행한 결과의 배열에 대한 에러 처리 방식 수정(CUBRIDSUS-9364)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	CCI 응용에서 여러 개의 질의를 한 번에 수행할 때 2008 R3.0부터 2008 R4.1 버전까지는 cci_execute_array 함수, cci_execute_batch 함수 또는 cci_execute_result 함수에 의한 질의 수행 결과들 중 하나만 에러가 발생해도 해당 질의의 에러 코드를 반환했으나, 2008 R4.3 버전 및 2008 R9.1 버전부터는 전체 질의 개수를 반환하고 CCI_QUERY_RESULT_* 매크로들을 통해 개별 질의에 대한 에러를 확인할 수 있도록 수정했다.

	수정 이전 버전에서는 에러가 발생한 경우에도 배열 내 각각의 질의들의 성공 실패 여부를 알 수 없으므로, 이를 판단해야 한다.

	::
	
		...
		char *query = "INSERT INTO test_data (id, ndata, cdata, sdata, ldata) VALUES (?, ?, 'A', 'ABCD', 1234)";
		...
		req = cci_prepare (con, query, 0, &cci_error);
		...
		error = cci_bind_param_array_size (req, 3);
		...
		error = cci_bind_param_array (req, 1, CCI_A_TYPE_INT, co_ex, null_ind, CCI_U_TYPE_INT);
		...
		n_executed = cci_execute_array (req, &result, &cci_error);

		if (n_executed < 0)
		{
		  printf ("execute error: %d, %s\n", cci_error.err_code, cci_error.err_msg);

		  for (i = 1; i <= 3; i++)
		  {
			printf ("query %d\n", i);
			printf ("result count = %d\n", CCI_QUERY_RESULT_RESULT (result, i));
			printf ("error message = %s\n", CCI_QUERY_RESULT_ERR_MSG (result, i));
			printf ("statement type = %d\n", CCI_QUERY_RESULT_STMT_TYPE (result, i));
		  }
		}
		...
		
	수정 이후 버전에서는 에러가 발생하면 전체 질의가 실패한 것이며, 에러가 발생하지 않은 경우에 대해 배열 내 각 질의들의 성공 실패 여부를 판단한다.

	::
	
		...
		char *query = "INSERT INTO test_data (id, ndata, cdata, sdata, ldata) VALUES (?, ?, 'A', 'ABCD', 1234)";
		...
		req = cci_prepare (con, query, 0, &cci_error);
		...
		error = cci_bind_param_array_size (req, 3);
		...
		error = cci_bind_param_array (req, 1, CCI_A_TYPE_INT, co_ex, null_ind, CCI_U_TYPE_INT);
		...
		n_executed = cci_execute_array (req, &result, &cci_error);
		if (n_executed < 0)
		{
		  printf ("execute error: %d, %s\n", cci_error.err_code, cci_error.err_msg);
		}
		else {
		  for (i = 1; i <= 3; i++)
		  {
			printf ("query %d\n", i);
			printf ("result count = %d\n", CCI_QUERY_RESULT_RESULT (result, i));
			printf ("error message = %s\n", CCI_QUERY_RESULT_ERR_MSG (result, i));
			printf ("statement type = %d\n", CCI_QUERY_RESULT_STMT_TYPE (result, i));
		  }
		}
		...

기존 주의 사항
--------------

2008 R4.1 버전부터 CCI_DEFAULT_AUTOCOMMIT 의 기본값이 ON으로 바뀜(CUBRIDSUS-5879)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	2008 R4.1 버전부터 CCI 인터페이스로 개발된 응용 프로그램의 자동 커밋 모드에 영향을 주는 브로커 파라미터인 CCI_DEFAULT_AUTOCOMMIT의 기본값이 ON으로 변경되었다. 따라서 CCI 및 CCI로 개발된 인터페이스(PHP, ODBC, OLE DB 등) 사용자는 응용 프로그램의 자동 커밋 모드가 이에 적합한지 살펴보아야 한다.

2008 R4.0 버전부터 페이지 단위의 옵션 및 파라미터가 볼륨 크기 단위로 바뀜(CUBRIDSUS-5136)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	cubrid createdb 유틸리티의 DB 볼륨 크기 및 로그 볼륨 크기를 지정할 때 페이지 단위를 사용하는 옵션들(-p, -l, -s)은 제거될 예정이므로, 2008 R4.0 Beta 이후 새로 추가된 옵션들(--db-volume-size, --log-volume-size, --db-page-size, --log-page-size)을 사용한다.

	cubrid addvoldb 유틸리티의 DB 볼륨 크기를 지정하는 경우에도 페이지 단위를 사용하지 않고 2008 R4.0 Beta 이후 새로 추가된 옵션(--db-volume-size)을 사용한다.
	페이지 단위의 시스템 파라미터들은 추후 제거될 예정이므로 바이트 단위의 새로운 시스템 파라미터를 사용할 것을 권장한다. 관련 시스템 파라미터들에 대한 내용은 아래를 참고한다.

2008 R4.0 Beta 이전 사용자는 DB 볼륨 크기 설정 시 주의(CUBRIDSUS-4222)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	2008 R4.0 Beta 버전부터 DB 생성 시 데이터 페이지 및 로그 페이지의 크기 기본값이 4KB에서 16KB로 변경되었으므로, DB 볼륨을 페이지 개수로 지정하여 생성하는 경우 볼륨의 바이트 크기가 기대와 다를 수 있음에 주의한다. 아무런 옵션도 주지 않을 경우 이전 버전에서는 4KB의 페이지 크기로 100MB의 DB 볼륨을 생성했으나, 2008 R4.0 버전부터는 16KB의 페이지 크기로 512MB의 DB 볼륨을 생성하게 된다.

	그리고, DB 볼륨의 생성 가능한 최소 크기를 20MB로 제한했으므로 이보다 작은 크기의 DB 볼륨은 생성할 수 없다.

2008 R4.0 이전 버전의 일부 시스템 파라미터들의 기본값 변경(CUBRIDSUS-4095)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	2008 R4.0부터 다음 시스템 파라미터들의 기본값이 변경되었다.

	DB 서버가 허용하는 동시 연결 개수를 설정하는 max_clients의 기본값, 인덱스 페이지 생성 시 향후 업데이트를 대비하여 확보하는 여유 공간 비율을 설정하는 index_unfill_factor의 기본값이 변경되었으며, 바이트 단위 시스템 파라미터의 기본값이 기존 페이지 단위 시스템 파라미터의 기본값보다 커져서 별도의 설정을 하지 않는 경우 더 많은 메모리를 사용하게 되었다.

	+-----------------------------+----------------------------+----------------------+--------------------+ 
	| 기존                        | 추가된                     | 기존                 | 변경된             | 
	| 시스템                      | 시스템                     | 기본값               | 기본값             |
	|                             |                            |                      | (단위: 바이트)     | 
	+=============================+============================+======================+====================+ 
	| max_clients                 | 없음                       | 50                   | 100                | 
	+-----------------------------+----------------------------+----------------------+--------------------+ 
	| index_unfill_factor         | 없음                       | 0.2                  | 0.05               | 
	+-----------------------------+----------------------------+----------------------+--------------------+
	| data_buffer_pages           | data_buffer_size           | 100M(페이지 크기=4K) | 512M               | 
	+-----------------------------+----------------------------+----------------------+--------------------+
	| log_buffer_pages            | log_buffer_size            | 200K(페이지 크기=4K) | 4M                 | 
	|                             |                            |                      |                    |
	+-----------------------------+----------------------------+----------------------+--------------------+
	| sort_buffer_pages           | sort_buffer_size           | 64K(페이지 크기=4K)  | 2M                 | 
	|                             |                            |                      |                    | 
	+-----------------------------+----------------------------+----------------------+--------------------+
	| index_scan_oid_buffer_pages | index_scan_oid_buffer_size | 16K(페이지 크기=4K)  | 64K                | 
	|                             |                            |                      |                    | 
	+-----------------------------+----------------------------+----------------------+--------------------+
 
	또한, cubrid createdb로 DB 생성 시 데이터 페이지 크기와 로그 페이지 크기의 최소값이 1K에서 4K로 변경되었다.
 
시스템 파라미터를 잘못 설정하면 DB 서비스, 유틸리티 및 응응 프로그램이 구동되지 않음(CUBRIDSUS-5375)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	cubrid.conf 또는 cubrid_ha.conf에 정의되지 않은 시스템 파라미터를 설정하거나, 페이지 단위의 시스템 파라미터와 바이트 단위의 시스템 파라미터가 동시에 사용되거나, 시스템 파라미터 값이 허용 범위를 벗어나면 이와 관련된 DB 서비스, 유틸리티 및 응응 프로그램이 구동되지 않는다.

CUBRID 32bit 버전에서 data_buffer_size에 2G를 초과하는 값을 설정하면 DB 구동에 실패함(CUBRIDSUS-5349)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	CUBRID 32bit 버전에서 data_buffer_size가 2G를 초과하는 값으로 설정되는 경우 DB 구동에 실패한다. 32bit 버전에서는 OS의 한계로 인해 설정값이 2G를 초과할 수 없음에 주의한다.

	
Windows Vista 이상 버전에서 CUBRID 유틸리티를 사용한 서비스 제어 시 권장 사항(CUBRIDSUS-4186)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	Windows Vista 이상 버전에서 cubrid 유틸리티를 사용하여 서비스를 제어하려면 명령 프롬프트 창을 관리자 권한으로 구동한 후 사용하는 것을 권장한다.

	명령 프롬프트 창을 관리자 권한으로 구동하지 않고 cubrid 유틸리티를 사용하는 경우 UAC(User Account Control) 대화 상자를 통하여 관리자 권한으로 수행될 수 있으나 수행 결과 메시지를 확인할 수 없다.

	Windows Vista 이상 버전에서 명령 프롬프트 창을 관리자 권한으로 구동하는 방법은 다음과 같다.

	* [시작> 모든 프로그램> 보조 프로그램> 명령 프롬프트]에서 마우스 오른쪽 버튼을 클릭한다.

	* [관리자 권한으로 실행(A)]을 선택하면 권한 상승을 확인하는 대화 상자가 활성화되고, "예"를 클릭하여 관리자 권한으로 구동한다.
	
CUBRID 소스 빌드 후 실행 시, 매니저 서버 프로세스 관련 오류 발생(CUBRIDSUS-3553)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	사용자가 직접 빌드하여 설치하는 경우, CUBRID와 CUBRID 매니저를 각각 빌드하여 설치해야 한다. 만약, CUBRID 소스만 checkout하여 빌드 후 cubrid service start 또는 cubrid manager start를 실행하면, cubrid manager server is not installed라는 오류가 발생한다.

2008 R3.0 이하 버전에서 사용하던 GLO 클래스 지원 중단(CUBRIDSUS-3826)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	CUBRID 2008 R3.0 이하 버전은 glo (Generalized Large Object) 클래스를 사용하여 Large Object를 처리했으나, CUBRID 2008 R3.1 이상 버전 glo 클래스를 제거하고 BLOB, CLOB 타입(이하 LOB)을 지원한다. (매뉴얼의 'CUBRID SQL 설명서 > 데이터 타입 > BLOB/CLOB 데이터 타입' 참고)

	기존의 glo 클래스 사용자는 다음과 같이 작업할 것을 권장한다.

	* GLO 데이터를 파일로 저장한 후 어플리케이션 및 DB 스키마에서 GLO를 사용하지 않도록 수정한다.

	* unloaddb, loaddb 유틸리티를 이용하여 DB 마이그레이션을 한다.

	* 변경한 어플리케이션에 맞게 파일을 LOB 데이터로 로딩하는 작업을 수행하도록 한다.

	* 수정한 어플리케이션이 정상 동작하는지 확인한다.


	참고로, cubrid loaddb 유틸리티는 GLO 클래스를 상속받거나 GLO 클래스 타입을 가진 테이블을 로딩하려는 경우 " Error occurred during schema loading " 오류 메시지와 함께 데이터 로딩을 중지한다.

	GLO 클래스의 지원 중단에 따라 각 인터페이스 별로 삭제한 함수는 다음과 같다.

	+------------+----------------------------+
	| 인터페이스 | 삭제한                     |
	|            | 함수                       |
	+============+============================+
	| CCI        | cci_glo_append_data        |
	|            |                            |
	|            | cci_glo_compress_data      |
	|            |                            |
	|            | cci_glo_data_size          |
	|            |                            |
	|            | cci_glo_delete_data        |
	|            |                            |
	|            | cci_glo_destroy_data       |
	|            |                            |
	|            | cci_glo_insert_data        |
	|            |                            |
	|            | cci_glo_load               |
	|            |                            |
	|            | cci_glo_new                |
	|            |                            |
	|            | cci_glo_read_data          |
	|            |                            |
	|            | cci_glo_save               |
	|            |                            |
	|            | cci_glo_truncate_data      |
	|            |                            |
	|            | cci_glo_write_data         |
	|            |                            |
	+------------+----------------------------+
	| JDBC       | CUBRIDConnection.getNewGLO |
	|            |                            |
	|            | CUBRIDOID.loadGLO          |
	|            |                            |
	|            | CUBRIDOID.saveGLO          |
	|            |                            |
	+------------+----------------------------+
	| PHP        | cubrid_new_glo             |
	|            |                            |
	|            | cubrid_save_to_glo         |
	|            |                            |
	|            | cubrid_load_from_glo       |
	|            |                            |
	|            | cubrid_send_glo            |
	|            |                            |
	+------------+----------------------------+

마스터 프로세스와 서버 프로세스 간 프로토콜 변경 및 두 개 버전을 동시에 운영하는 경우 포트 설정 필요(CUBRIDSUS-3564)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	마스터 프로세스(cub_master)와 서버 프로세스(cub_server) 간 통신 프로토콜 변경으로 인해 CUBRID 2008 R3.0 이상 버전의 마스터 프로세스는 하위 버전의 서버 프로세스와 통신할 수 없고, 하위 버전의 마스터 프로세스도 2008 R3.0 이상 버전의 서버 프로세스와 통신할 수 없다. 따라서, 이미 하위 버전이 설치되어 있는 환경에서 새 버전을 추가 설치하여, 두 개 버전의 CUBRID를 동시에 운영하는 경우 각각 서로 다른 포트를 사용하도록 cubrid.conf의 cubrid_port_id 시스템 파라미터를 수정해야 한다.


JDBC에서 연결 정보를 URL 스트링으로 입력하는 경우 물음표를 반드시 명시(CUBRIDSUS-3217)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	JDBC에서 URL 스트링으로 연결 정보를 입력하는 경우 이전 버전에서는 물음표(?)를 입력하지 않더라도 속성(PROPERTY) 정보가 적용되었으나, CUBRID 2008 R3.0부터는 문법에 따라 반드시 물음표를 명시해야 하고 이를 생략할 경우 에러를 출력한다. 또한, 연결 정보 중 USERNAME과 PASSWORD가 없더라도 반드시 콜론( : )을 명시해야 한다.

	::

		URL=jdbc:CUBRID:127.0.0.1:31000:db1:::althosts=127.0.0.2:31000,127.0.0.3:31000 –에러 처리
		URL=jdbc:CUBRID:127.0.0.1:31000:db1:::?althosts=127.0.0.2:31000,127.0.0.3:31000 –정상 처리

DB 이름에 @를 포함할 수 없음(CUBRIDSUS-2828)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	DB 이름에 @이 포함되는 경우 호스트 이름이 명시된 것으로 해석될 수 있으므로 이를 방지하기 위하여 cubrid createdb, cubrid renamedb, cubrid copydb 유틸리티 실행 시 DB 이름에 @를 포함할 수 없도록 수정했다.