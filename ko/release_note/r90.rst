:tocdepth: 3

.. contents::

***************
9.0 릴리스 노트
***************

릴리스 노트 정보
================

본 문서는 CUBRID 9.0 Beta(빌드번호 9.0.0.0478)에 관한 유용한 정보를 포함한다.
9.0 Beta 이전 버전에 대한 정보는 `<http://release.cubrid.org/ko>`_ 에서 확인할 수 있다.

CUBRID 9.0 Beta 이전 버전에 대한 자세한 내용은 CUBRID 2008 R4.1 Patch 7 릴리스 노트를 참조한다.
9.0 Beta 사용자는 9.1로 반드시 업그레이드하기를 권장하며, 9.0 Beta와 9.1은 데이터 볼륨이 서로 호환하지 않으므로 제품 업그레이드 이후 "migrate_90beta_to_91 <db_name>" 툴을 이용하여 데이터베이스를 마이그레이션해야 한다. 9.1 릴리스 노트는 :doc:`r91` 를 참고한다.

릴리스 특징
===========

CUBRID 9.0은 다양한 언어의 문자셋과 콜레이션을 지원하여 국제화를 위한 기능을 추가하고, 분석 함수, MERGE 문, DELETE/UPDATE의 JOIN 지원, ENUM 타입 지원 등 다양한 SQL 구문을 추가하여 사용 편의를 강화했다. 함수 기반 인덱스,  필터링된 인덱스를 지원하며, 인덱스 스킵 스캔 최적화를 제공한다. 분할을 근본적으로 개선하였으며, 성능과 안정성을 크게 향상시켰다. 아울러 CUBRID SHARD 기능을 통해 대용량 데이터 처리 환경의 편의를 제공한다. 그리고 SysBench 벤치마크 기준으로 처리량(throughput)과 응답 시간 모두 3배 이상 향상되었으며, 기본 SELECT 성능이 약 1.6배 향상되었다. 그 외에 수 많은 버그와 성능 이슈 수정을 통해 제품을 안정화했다.

CUBRID 9.0 릴리스는 CUBRID 2008 R4.1 Patch 7 및 하위 버전의 수정 사항들을 모두 포함하며, 주요 특징은 다음과 같다.

다국어 지원
-----------

    현지화에 적합한 데이터베이스 환경을 제공하기 위해 한국어, 영어, 일본어, 중국어, 베트남어, 캄보디아어, 터키어, 독일어, 스페인어, 프랑스어, 이탈리어어 등 다양한 국가 언어의 문자셋, 콜레이션, 캘린더 및 숫자 표기 규칙을 추가했다.

데이터베이스 sharding을 위한 미들웨어 기능 지원
-----------------------------------------------

    다수의 장비로 수평 분할된 데이터베이스 환경을 용이하게 접근하기 위한 미들웨어인 CUBRID SHARD 기능을 제공한다. CUBRID SHARD 기능은 응용 프로그램이 여러 장비에 분산된 데이터베이스를 하나의 데이터베이스로 보이도록 단일 뷰(single view)를 제공하며, 이들을 인지하고 특정 데이터베이스를 접근할 필요 없도록 투명성(transparency)을 제공한다.

OVER 절을 이용한 분석 함수 지원
-------------------------------

    특정 행 집합에 대해 다양한 통계를 얻을 수 있도록 OVER라는 새로운 분석 절을 함께 사용하는 분석 함수들을 추가했다.

INSERT, UPDATE, DELETE 질의를 하나로 통합하는 MERGE 문 지원
-----------------------------------------------------------

    하나 이상의 원본 테이블로부터 하나의 대상 테이블에 데이터를 입력, 수정 또는 삭제할 수 있는 MERGE 문을 추가했다.

UPDATE 문과 DELETE 문의 JOIN 지원
---------------------------------

    UPDATE 문과 DELETE 문에서 JOIN을 지원하게 되었다.

ENUM 타입 지원
--------------

    열거형 문자열 상수들로 정의하는 ENUM 타입을 추가했다. 

함수 기반 인덱스, 필터링된 인덱스, 인덱스 스킵 스캔 등 다양한 인덱스 기능 지원
------------------------------------------------------------------------------

    인덱스를 구성하는 칼럼에 함수 표현을 포함하는 함수 기반 인덱스 기능을 제공하며, 인덱스 구성에 검색 조건을 포함하는 필터링된 인덱스 기능을 추가했다. 다중 칼럼 인덱스의 첫번째 칼럼이 명시되지 않아도 인덱스의 두 번째 칼럼부터 인덱스를 사용할 수 있는 인덱스 스킵 스캔(index skip scan) 최적화를 제공한다.

분할 테이블 기능 안정화, 성능 개선 및 PROMOTE 문 지원
-----------------------------------------------------

    분할 기능의 안정화와 성능 개선을 위해 근본적으로 개선하였다. 질의 컴파일 과정이 아니라 질의 수행 과정에서 분할 프루닝되도록 하여 성능을 개선하였고, 분할 키를 포함하는 기본 키 및 고유 인덱스를 분할 전체에 대해서 유지하지 않고 각 분할별로 유지되도록 변경하였다. 그 외에 많은 안정성 개선 및 성능 개선이 있었다.

    또한, 분할 테이블에서 특정 분할 부분을 일반 테이블로 승격시키는 PROMOTE 문을 추가했다.

HA 안정성 개선 및 운영 편의성 향상
----------------------------------

    데이터 및 스키마의 HA 복제 불일치 등 여러 안정성 이슈를 해결하였으며, HA 관리 프로세스들을 개별적으로 제어할 수 있도록 하였고 HA 운영 과정에서 노드의 동적 추가 및 삭제를 용이하게 수행할 수 있도록 개선하였다.

DEFALUT에 pseudo column 지원
----------------------------

    칼럼의 DEFAULT 속성으로 SYSDATE, USER 등의 시스템 함수를 지정하면 질의 수행 시점을 기준으로 결과 값을 얻어올 수 있도록 했다.

CURSOR HOLDABILITY 지원
-----------------------

    CURSOR HOLDABILITY가 기본으로 동작하게 하여 커밋 이후에도 커서가 유지되게 하여 결과 셋을 유지하면서 DML 커밋이 가능하게 했다.

VALUES 절 추가
--------------

    주로 상수 값으로 구성된 테이블을 표현하기 위해 VALUES 문 이하 표현식에 명시된 행 값들을 출력하는 VALUES 문을 추가했다.

오류 메시지 개선
----------------

    오류 발생 위치를 쉽게 찾아갈 수 있도록 오류 메시지를 강화하였고, 구체적이지 않은 오류 메시지들을 개선하여 오류 원인을 찾기 쉽게 했다.

크고 작은 버그 및 기능들을 수정 또는 개선
-----------------------------------------

    SQL 함수, SQL 구문, 질의 계획, 인덱스, 트리거, 드라이버, 유틸리티 등에서 발견된 크고 작은 버그 및 기능들을 수정 또는 개선했다. 또한 질의 계획, 인덱스 스캔, 잠금, 삽입 및 삭제의 반복 수행, 메모리 누수, 디스크 사용량 등에서 발견된 이슈들을 수정 또는 개선했다. 아울러 HA 스키마 복제 및 데이터 복제 이슈들을 개선 또는 수정했다.

보다 자세한 변경 사항은 아래의 CUBRID 9.0에서 변경된 사항을 참고한다.


기능 추가
=========

SQL
---

MERGE 문(CUBRIDSUS-7080)
^^^^^^^^^^^^^^^^^^^^^^^^

    하나 또는 그 이상의 원본으로부터 행들을 선택하여 하나의 테이블 또는 뷰로 갱신이나 삽입을 수행하기 위해 사용하는 MERGE 문을 추가했다. 대상 테이블 또는 뷰에 갱신할지 또는 삽입할지를 결정하는 조건을 지정할 수 있다.

    .. code-block:: sql
    
        MERGE INTO target_table tt USING source_table st
        ON (st.a = tt.a AND st.b = tt.b)
        WHEN MATCHED THEN UPDATE SET tt.c = st.c
        WHEN NOT MATCHED THEN INSERT VALUES (st.a, st.b, st.c);

OVER 절을 이용하는 분석 함수(CUBRIDSUS-6112)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    행들의 결과에 기반하여 집계 값을 계산하는 분석 함수를 추가했다. 추가된 분석 함수들은 AVG, COUNT, MAX, MIN, RANK, ROW_NUMBER, STDDEV, STDDEV_POP, STDDEV_SAMP, SUM, VAR_POP, VAR_SAMP, VARIANCE, DENSE_RANK이다. 분석 함수는 특정 행 집합에 대해 다양한 통계를 허용하기 위해 기존의 집계 함수들 일부에 OVER라는 새로운 분석 절이 함께 사용된다.

    다음은 demodb에서 nation_code가 'AU'로 시작하는 국가에 대해 연도 별로 획득한 금메달 수와 해당 연도까지의 금메달 누적에 대한 평균 합계를 출력하는 예제이다.

    .. code-block:: sql

        SELECT host_year, nation_code, gold, AVG (gold) OVER (PARTITION BY nation_code ORDER BY host_year) avg_gold
        FROM participant WHERE nation_code LIKE 'AU%';

UPDATE JOIN, DELETE JOIN 문(CUBRIDSUS-5646)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    하나 이상의 테이블에 대해 갱신하거나 삭제할 수 있는 UPDATE JOIN, DELETE JOIN 문을 추가했다.

    .. code-block:: sql

        UPDATE a_tbl INNER JOIN b_tbl ON a_tbl.id = b_tbl.rate_id
        SET a_tbl.charge = a_tbl.charge * (1 + b_tbl.rate)
        WHERE a_tbl.charge > 900.0;

        DELETE a, b FROM tbl1 a INNER JOIN tbl2 b
        WHERE a.idx=b.p_idx AND b.p_idx = 5 AND b.flag = 1;

ENUM 타입
^^^^^^^^^

    열거형 문자열 상수들로 정의하는 ENUM 타입을 추가했다.

    .. code-block:: sql

        CREATE TABLE tbl (
            color ENUM ('red', 'yellow', 'blue')
        );

        INSERT into tbl VALUES ('yellow'), ('red'), (2), ('blue');
        SELECT color FROM tbl ORDER BY color ASC;

    ::
    
        color
        ======================
        red
        yellow
        yellow
        blue

UPDATE 문에 ORDER BY 명시(CUBRIDSUS-6605)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    UPDATE 문의 ORDER BY 절에 따라 순서대로 갱신하는 것이 가능하도록 수정했다. 다음 질의에서 UPDATE문을 수행하면 a 칼럼의 값이 큰 순서대로 b의 값이 갱신된다.

    .. code-block:: sql

        CREATE TABLE t1 (a INT, b INT);
        INSERT INTO t1 VALUES (1, 1), (2, 2), (3, 3), (4, 4);
        SET @tmp = 100;

        UPDATE t1 SET b = (@tmp := @tmp + 1) 
        ORDER BY a DESC;

VALUES 절(CUBRIDSUS-7553)
^^^^^^^^^^^^^^^^^^^^^^^^^

    주로 임시로 실제 테이블을 생성하지 않고 상수 테이블을 생성할 때 사용하는 VALUES 절을 추가했다. VALUES 절은 UNION ALL 문을 연결하여 같은 결과를 얻을 수 있지만 훨씬 간편하다. 대개 SELECT, UPDATE, DELETE 질의 내에서 다른 테이블과 조인되는 형태로 많이 활용된다.

    .. code-block:: sql

        VALUES (1 AS col1, 'first' AS col2), (2, 'second'), (3, 'third'), (4, 'fourth');

        SELECT 1 AS col1, 'first' AS col2
        UNION ALL
        SELECT 2, 'second'
        UNION ALL
        SELECT 3, 'third'
        UNION ALL
        SELECT 4,'fourth';

SHOW CREATE TABLE 문(CUBRIDSUS-6996)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    테이블을 생성하는 SQL 문을 출력해주는 SHOW CREATE TABLE 문을 추가했다.

    .. code-block:: sql

        SHOW CREATE TABLE tbl;

    ::
    
        TABLE    CREATE TABLE
        ============================================
        'tbl'    'CREATE TABLE [tbl]
                ([id] INTEGER DEFAULT 0 NOT NULL, [phone] CHARACTER VARYING(10), CONSTRAINT [pk_tbl_id] PRIMARY KEY ([id]))'

분할 PROMOTE 문(CUBRIDSUS-7629)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    분할 테이블에서 사용자가 지정한 분할 일부를 일반 테이블로 승격시키는 PROMOTE 구문을 추가했다.

    .. code-block:: sql

        CREATE TABLE t(i int) PARTITION BY LIST(i) (
            PARTITION p0 VALUES IN (1, 2, 3),
            PARTITION p1 VALUES IN (4, 5, 6),
            PARTITION p2 VALUES IN (7, 8, 9),
            PARTITION p3 VALUES IN (10, 11, 12)
        );

        ALTER TABLE t PROMOTE PARTITION p1, p2;

테이블, 뷰, 트리거, 저장 프로시저의 소유자를 변경하는 ALTER 문(CUBRIDSUS-7922)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    테이블, 뷰, 트리거, 저장 프로시저의 소유자를 지정하는 ALTER 문을 추가했다. 

    .. code-block:: sql

        ALTER TABLE test_tbl OWNER TO PUBLIC;
        ALTER VIEW test_view OWNER TO PUBLIC;
        ALTER TRIGGER test_trigger OWNER TO PUBLIC;
        ALTER FUNCTION test_function OWNER TO PUBLIC;
        ALTER PROCEDURE test_procedure OWNER TO PUBLIC;

CONNECT BY 절에 LEVEL 칼럼 지원(CUBRIDSUS-7526)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    CONNECT BY 절에서 LEVEL 칼럼을 사용할 수 있게 되었다.

    .. code-block:: sql

        SELECT LEVEL FROM db_root CONNECT BY LEVEL <= 10;

LIMIT 절에 OFFSET 키워드 지원(CUBRIDSUS-7439)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    LIMIT 절에 OFFSET 키워드를 사용할 수 있게 되었다. 아래 두 개의 질의는 같은 결과를 수행한다.

    .. code-block:: sql

        SELECT * FROM tab LIMIT 2, 1;

        SELECT *
        FROM tab LIMIT 1 OFFSET 2;

INET_ATON 함수, INET_NTOA 함수(CUBRIDSUS-8230)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    INET_ATON 함수, INET_NTOA 함수를 추가했다. INET_ATON 함수는 IP 주소를 입력하면 숫자 값을 반환하며, INET_NTOA 함수는 숫자를 입력하면 IP 주소 값을 반환한다.

    .. code-block:: sql

        SELECT INET_ATON('192.168.0.10');

    ::
    
        inet_aton('192.168.0.10')
        ============================
        3232235530

    .. code-block:: sql

        SELECT INET_NTOA(3232235530);
        
    ::
    
        inet_ntoa(3232235530)
        ======================
        '192.168.0.10'


다국어
------


여러 국가의 문자셋과 콜레이션(CUBRIDSUS-7629)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    다국어 지원을 위해 여러 국가의 로캘(문자셋과 콜레이션)을 지원하게 되었다. CUBRID에 추가된 로캘은 영어(en_US), 독일어(de_DE), 스페인어(es_ES), 프랑스어(fr_FR), 이태리어(it_IT), 일본어(ja_JP0, 캄보디아어(km_KH), 한국어(ko_KR), 터키어(tr_TR), 베트남어(vi_VN), 중국어(zh_CN)이다.

    이와 함께 다국어 관련 시스템 파라미터들을 추가했다.

    +------------------------------+---------------------------------------------------------------------------------------------------------+
    | 파라미터 이름                | 설명                                                                                                    |
    +==============================+=========================================================================================================+
    | intl_check_input_string      | 입력되는 문자열이 사용하는 문자셋에 맞게 입력되는지에 대한 검사 여부를 설정. 기본값 no.                 |
    +------------------------------+---------------------------------------------------------------------------------------------------------+
    | string_max_size_bytes        | 문자열 함수 또는 연산에서 문자열 인자로 사용할 수 있는 최대 바이트 크기를 정의. 기본값 1048576bytes.    |
    +------------------------------+---------------------------------------------------------------------------------------------------------+
    | unicode_input_normalization  | 입력할 유니코드를 결합된 상태로 저장할지 여부를 설정. 기본값 yes.                                       | 
    +------------------------------+---------------------------------------------------------------------------------------------------------+
    | unicode_output_normalization | 저장된 유니코드를 분해된 코드로 출력할 것인지 여부를 설정. 기본값 no                                    |
    +------------------------------+---------------------------------------------------------------------------------------------------------+
    | use_locale_date_format       | 문자열을 날짜/시간 형식으로 변환하는 함수에서 입력 인자인 문자열에 대해 지역화된(localized) 날짜/시간   |
    |                              | 형식을 사용할 것인지 여부를 설정. 기본값 CUBRID_LANG 환경 변수.                                         |
    +------------------------------+---------------------------------------------------------------------------------------------------------+
    | use_locale_number_format     | 문자열을 숫자로 또는 숫자를 문자열로 변환하는 함수들에서 입력 또는 출력되는 문자열에 숫자 형식을        |
    |                              | 부여할 것인지 여부를 설정. 기본값 CUBRID_LANG 환경 변수.                                                |
    +------------------------------+---------------------------------------------------------------------------------------------------------+

    또한, 문자셋이 유효한지에 대한 검사 여부를 설정하는 파라미터인 intl_check_input_string이 추가되었다. 이와 함께 single_byte_compare, intl_mbs_support 파라미터는 더 이상 사용되지 않게 되었다. 

Sharding
--------


데이터베이스 sharding을 위한 미들웨어(CUBRIDSUS-4996)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    다수의 장비로 수평 분할된 데이터베이스 환경을 용이하게 접근하기 위한 미들웨어인 CUBRID SHARD 기능을 제공한다. CUBRID SHARD는 다음과 같은 특징을 갖는다.  

    *  기존 응용의 변경을 최소화하기 위한 미들웨어 형태로서, 흔히 사용되는 JDBC와 CUBRID C API인 CCI 인터페이스를 이용하여 sharding된 데이터베이스를 투명하게 접근할 수 있다. 

    *  힌트를 이용하여 실제 질의 수행할 shard를 선택하는 방식으로, 기존 사용하던 질의에 힌트를 추가하여 사용할 수 있다. 

    *  CUBRID뿐만 아니라, MySQL을 backend shard DB로 하여 구성될 수 있다. 

    *  일부 트랜잭션의 특성을 보장한다.



인덱스
------


필터링된 인덱스(CUBRIDSUS-6112)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    특정 조건을 포함하는 필터링된 인덱스(filtered index)를 지원하게 되었다. 전체 인덱스에서 조건에 부합하는 일부 인덱스만 사용되므로 부분 인덱스(partial index)라고도 하며, 필요한 조건의 행만 인덱스를 생성하므로 인덱스의 갱신 부담이 적고 탐색 범위가 작아 검색 성능 향상에 도움이 된다.

    .. code-block:: sql

        CREATE INDEX bugs_per_dev ON bugs(Author) WHERE Closed = 0;

        SELECT * FROM bugs
        WHERE Author= 'madden' AND Subject LIKE '%fopen%' AND Closed = 0
        USING INDEX idx_open_bugs;

    이와 함께, 메모리에 캐시하는 필터링된 인덱스 표현식의 최대 개수를 설정하는 max_filter_pred_cache_entries 파라미터를 추가했다. 기본값은 1000이다. 

함수 기반 인덱스(CUBRIDSUS-6112)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    특정 함수의 결과 값을 포함하는 함수 기반 인덱스(function-based index)를 지원하게 되었다. 특정 함수를 통해 데이터를 정렬하거나 찾고 싶을 때 사용된다.

    .. code-block:: sql

        CREATE INDEX idx_upper_post ON posts_table(UPPER(keyword));

인덱스 스킵 스캔(CUBRIDSUS-5646)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    인덱스의 첫 번째 칼럼이 조건에 없어도 뒤따라오는 칼럼이 조건(주로 =)에 있으면 인덱스의 뒷 부분이 사용되는 것을 허용하는 인덱스 스킵 스캔(index skip scan, ISS) 기능을 추가했다.

    .. code-block:: sql

        CREATE INDEX idx_t_gen_name ON t (gender, name);
        SELECT * FROM t WHERE name = 'SMITH';

드라이버
--------



[JDBC] DatabaseMetaData의 메서드인 getDatabaseMajorVersion(), getDatabaseMinorVersion() 추가(CUBRIDSUS-7530)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    JDBC DatabaseMetaData 인터페이스의 getDatabaseMajorVersion()과 getDatabaseMinorVersion() 메서드는 호출 시 각각 메이저 버전 번호와 마이너 버전 번호를 반환한다.
 
[CCI] 이스케이프 문자열로 변환하는 함수(CUBRIDSUS-8940)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    CUBRID 질의문에서 사용할 수 있는 이스케이프 문자열로 변환해주는 cci_escape_string()을 추가했다.

[CCI] 에러 메시지 출력용 버퍼를 입력 인자로 하는 연결 함수(CUBRIDSUS-5633)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    오류 메시지 출력용 버퍼를 입력 인자로 하는 연결 함수인 cci_connect_ex(), cci_connect_with_url_ex()를 추가했다.
    기존의 연결 함수는 오류 발생 시 하나의 오류 번호를 반환해서 상세한 오류가 무엇인지 알 수 없었으나, 수정 이후 오류 메시지 버퍼를 통해 상세 오류 번호를 확인할 수 있게 되었다. 

    .. code-block:: c

        T_CCI_ERROR error;
        
        connection = cci_connect_ex ("localhost", 33000, "demodb", "dba", "pwd", &error);
        connection = cci_connect_with_url_ex ("cci:cubrid:localhost:33000:demodb:::", "dba", "pwd", &error);

시스템 카탈로그
---------------

HA 카탈로그 테이블에 칼럼 추가 및 삭제(CUBRIDSUS-5456)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    복제 로그 재반영으로 인한 복제 불일치를 방지하고, 보다 상세한 복제 로그 반영 상태 정보를 제공하기 위해 db_ha_apply_info 테이블에 칼럼들을 추가했다.

    +----------------------+---------------------------------------------------------------------------------------------------------------------+
    | 추가된 칼럼          | 설명                                                                                                                |
    +======================+=====================================================================================================================+
    | committed_lsa_pageid | 마지막에 반영한 commit log lsa의 page id                                                                            |
    |                      |                                                                                                                     |
    |                      | * applylogdb 가 재시작해도 last_committed_lsa 이전 로그는 재반영하지 않음                                           |
    +----------------------+---------------------------------------------------------------------------------------------------------------------+
    | committed_lsa_offset | 마지막에 반영한 commit log lsa의 offset                                                                             |
    |                      |                                                                                                                     |
    |                      | * applylogdb 가 재시작해도 last_committed_lsa 이전 로그는 재반영하지 않음                                           |
    +----------------------+---------------------------------------------------------------------------------------------------------------------+
    | committed_rep_pageid | 마지막에 반영한 복제 로그 lsa의 pageid                                                                              |
    |                      |                                                                                                                     |
    |                      | * 복제 반영 지연 여부 확인                                                                                          |
    +----------------------+---------------------------------------------------------------------------------------------------------------------+
    | committed_rep_offset | 마지막에 반영한 복제 로그 lsa의 offset                                                                              |
    |                      |                                                                                                                     |
    |                      | * 복제 반영 지연 여부 확인                                                                                          |
    +----------------------+---------------------------------------------------------------------------------------------------------------------+
    | append_lsa_page_id   | 마지막 반영 당시 복제 로그 마지막 lsa의 page id                                                                     |
    |                      |                                                                                                                     |
    |                      | * 복제 반영 당시 applylogdb 에서 처리 중인 복제 로그 헤더의 append_lsa 를 저장                                      |
    |                      |                                                                                                                     |
    |                      | * 복제 로그 반영 당시의 지연 여부를 확인                                                                            |
    +----------------------+---------------------------------------------------------------------------------------------------------------------+
    | append_lsa_offset    | 마지막 반영 당시 복제 로그 마지막 lsa의 offset                                                                      |
    |                      |                                                                                                                     |
    |                      | * 복제 반영 당시, applylogdb 에서 처리 중인 복제 로그 헤더의 append_lsa 를 저장                                     |
    |                      |                                                                                                                     |
    |                      | * 복제 로그 반영 당시의 지연 여부를 확인                                                                            |
    +----------------------+---------------------------------------------------------------------------------------------------------------------+
    | eof_lsa_page_id      | 마지막 반영 당시 복제 로그 eof lsa의 page id                                                                        |
    |                      |                                                                                                                     |
    |                      | * 복제 반영 당시, applylogdb 에서 처리 중인 복제 로그 헤더의 eof_lsa 를 저장                                        |
    |                      |                                                                                                                     |
    |                      | * 복제 로그 반영 당시의 지연 여부를 확인                                                                            |
    +----------------------+---------------------------------------------------------------------------------------------------------------------+
    | eof_lsa_offset       | 마지막 반영 당시 복제 로그 eof lsa의 offset                                                                         |
    |                      |                                                                                                                     |
    |                      | * 복제 반영 당시, applylogdb 에서 처리 중인 복제 로그 헤더의 eof_lsa 를 저장                                        |
    |                      |                                                                                                                     |
    |                      | * 복제 로그 반영 당시의 지연 여부를 확인                                                                            |
    +----------------------+---------------------------------------------------------------------------------------------------------------------+
    | final_lsa_pageid     | applylogdb 에서 마지막으로 처리한 로그 lsa의 pageid                                                                 |
    |                      |                                                                                                                     |
    |                      | * 복제 반영 지연 여부 확인                                                                                          |
    +----------------------+---------------------------------------------------------------------------------------------------------------------+
    | final_lsa_offset     | applylogdb 에서 마지막으로 처리한 로그 lsa의 offset                                                                 |
    |                      |                                                                                                                     |
    |                      | * 복제 반영 지연 여부 확인                                                                                          |
    +----------------------+---------------------------------------------------------------------------------------------------------------------+
    | required_page_id     | log_max_archives 파라미터에 의해 삭제되지 않아야 할 가장 작은 log page id, 복제 반영 시작할 로그 페이지 번호        |
    +----------------------+---------------------------------------------------------------------------------------------------------------------+
    | required_page_offset | 복제 반영 시작할 로그 페이지 offset                                                                                 |
    +----------------------+---------------------------------------------------------------------------------------------------------------------+
    | log_commit_time      | 마지막 commit log 의 반영 시간                                                                                      |
    +----------------------+---------------------------------------------------------------------------------------------------------------------+

    삭제된 칼럼은 다음과 같다.

    +-------------+-----------------------------------------+
    | 삭제된 칼럼 | 설명                                    |
    +=============+=========================================+
    | page_id     | 슬레이브 DB에 커밋된 복제 로그의 page   |
    +-------------+-----------------------------------------+
    | offset      | 슬레이브 DB에 커밋된 복제 로그의 offset |
    +-------------+-----------------------------------------+

인덱스 카탈로그 테이블 및 뷰에 칼럼 추가
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    필터링된 인덱스 및 함수 기반 인덱스 기능이 추가됨에 따라 다음 카탈로그 테이블 및 뷰에 칼럼이 추가되었다.

    _db_index 카탈로그 테이블에 다음 칼럼이 추가되었다.

    +-------------------+-----------------------------------------+
    | 추가된 칼럼       | 설명                                    |
    +===================+=========================================+
    | filter_expression | 필터링된 인덱스의 조건                  |
    +-------------------+-----------------------------------------+
    | have_function     | 함수 기반 인덱스이면 1, 그렇지 않으면 0 |
    +-------------------+-----------------------------------------+

    DB_INDEX 카탈로그 뷰에 다음 칼럼이 추가되었다.

    +-------------------+------------------------------------------------+
    | 추가된 칼럼       | 설명                                           |
    +===================+================================================+
    | filter_expression | 필터링된 인덱스의 조건                         |
    +-------------------+------------------------------------------------+
    | have_function     | 함수 기반 인덱스이면 'YES', 그렇지 않으면 'NO' |
    +-------------------+------------------------------------------------+


    _db_index_key 카탈로그 테이블에 다음 칼럼이 추가되었다.

    +-------------+--------------------------------+
    | 추가된 칼럼 | 설명                           |
    +=============+================================+
    | func        | 함수 기반 인덱스의 함수 표현식 |
    +-------------+--------------------------------+


    DB_INDEX_KEY 카탈로그 뷰에 다음 칼럼이 추가되었다.

    +-------------+--------------------------------+
    | 추가된 칼럼 | 설명                           |
    +=============+================================+
    | func        | 함수 기반 인덱스의 함수 표현식 |
    +-------------+--------------------------------+

콜레이션 테이블 및 뷰 추가  
^^^^^^^^^^^^^^^^^^^^^^^^^^

    다국어 지원에 따른 콜레이션 기능이 추가됨에 따라 다음 테이블 및 뷰가 추가되었다. 

    _db_collation 테이블

    +--------------+----------------------------------------+
    | 추가된 칼럼  | 설명                                   |
    +==============+========================================+
    | coll_id      | 콜레이션 ID                            |
    +--------------+----------------------------------------+
    | coll_name    | 콜레이션 이름                          |
    +--------------+----------------------------------------+
    | charset_id   | 문자셋 ID                              |
    +--------------+----------------------------------------+
    | built_in     | 제품 설치 시 콜레이션 포함 여부        |
    |              | (0: 포함 안 됨, 1: 포함)               |
    +--------------+----------------------------------------+
    | expansions   | 확장 지원 여부(0: 지원 안함, 1: 지원)  |
    +--------------+----------------------------------------+
    | contractions | 축약 지원 여부(0: 지원 안함, 1: 지원)  |
    +--------------+----------------------------------------+
    | checksum     | 콜레이션 파일의 체크섬                 |
    +--------------+----------------------------------------+
    | uca_strength | 가중치 세기(weight strength)           |
    +--------------+----------------------------------------+


    DB_COLLATION 뷰

    +----------------+-------------------------------------------------------------------------------+
    | 추가된 칼럼    | 설명                                                                          |
    +================+===============================================================================+
    | coll_id        | 콜레이션 ID                                                                   |
    +----------------+-------------------------------------------------------------------------------+
    | coll_name      | 콜레이션 이름                                                                 |
    +----------------+-------------------------------------------------------------------------------+
    | charset_name   | 문자셋 이름                                                                   |
    +----------------+-------------------------------------------------------------------------------+
    | is_builtin     | 설치 시 제품 내 포함 여부                                                     |
    +----------------+-------------------------------------------------------------------------------+
    | has_expansions | 확장 포함 여부                                                                |
    +----------------+-------------------------------------------------------------------------------+
    | contractions   | 축약 포함 여부                                                                |
    +----------------+-------------------------------------------------------------------------------+
    | uca_strength   | 가중치 세기(weight strength)                                                  |
    |                |                                                                               |
    |                | (NOT APPLICABLE, PRIMARY, SECONDARY, TERTIARY, QUATERNARY, IDENTITY, UNKNOWN) |
    +----------------+-------------------------------------------------------------------------------+

설정
----



클라이언트/서버 시스템 파라미터 중 일부에 세션 파라미터 개념(CUBRIDSUS-8193)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    클라이언트/서버 시스템 파라미터들 중 일부에 대해 어느 한쪽의 값이 변경되면 서버와 클라이언트에 같은 값이 반영되게 하는 세션 파라미터 개념을 추가했다. 추가된 세션 파라미터는 default_week_format, string_max_size_bytes, return_null_on_function_errors, alter_table_change_type_strict, plus_as_concat, compat_numeric_division_scale, use_locale_number_format, use_locale_date_format이다.


모니터링
--------
    

실행 통계 정보에 다중 범위 최적화 수행 회수 항목(CUBRIDSUS-6163)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    cubrid statdump 유틸리티와 SHOW EXEC STATISTICS ALL를 통해 확인할 수 있는 실행 통계 정보에 다중 범위 최적화(multi-range optimization)를 수행한 회수 항목을 추가했다.
    


동작 변경
=========

SQL
---



인덱스 추가, 삭제, 변경 시에 이름을 명시하도록 변경(CUBRIDSUS-6112) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    인덱스 추가, 삭제, 변경 시에 이름을 반드시 지정하도록 변경했다. 인덱스 이름을 생략하면 오류가 발생한다.

칼럼의 DEFAULT 속성 값으로 SYSDATE, USER 등의 함수를 지정하면 질의 수행 시점을 기준으로 결과 값을 얻어오도록 변경(CUBRIDSUS-4378)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    칼럼의 DEFAULT 속성 값으로 SYSTIMESTAMP, SYSDATE, SYSDATETIME, USER 함수를 지정했을 때 이전 버전에서는 DEFAULT 값이 테이블 생성 시점의 함수 결과 값으로 고정되었으나, 질의가 수행될 때마다 결과 값을 계산하여 얻어오도록 변경했다.

    .. code-block:: sql

        CREATE TABLE t (ID int, col TIMESTAMP DEFAULT SYSTIMESTAMP);
        ALTER TABLE t add column (uid STRING DEFAULT USER);
        INSERT INTO t (ID) VALUES (1); -- col의 값은 질의 수행 시점에 SYSTIMESTAMP를 수행한 결과 값이 된다.
    
MINUTE, HOUR, SECOND, TIME_TO_SEC 함수들의 입력 인자가 시간 형태의 문자열이 아닌 경우를 허용하지 않도록 수정(CUBRIDSUS-7535)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    MINUTE, HOUR, SECOND, TIME_TO_SEC 함수들과 같이 TIME 타입이 입력 인자인 경우 "YYYY-MM-DD"와 같은 날짜 형식의 문자열은 허용하지 않도록 수정했다.

    수정 이후 아래와 같은 질의는 허용하지 않는다.

    .. code-block:: sql

        SELECT TIME_TO_SEC ('2010-01-01');
        CREATE TABLE foo (col TIME DEFAULT '2000-01-01');

TIME 타입의 값으로 유효하지 않은 시간을 바인딩하면 오류를 출력하도록 수정(CUBRIDSUS-7159)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    TIME 타입의 값으로 "00:00:-1"과 같이 유효하지 않은 시간을 바인딩하면 -1을 무시하고 "00:00:00"으로 받아들였으나, 오류를 출력하도록 수정했다.

시리얼의 시작 값을 변경하면 NEXTVAL을 "설정 값"부터 반환하도록 변경(CUBRIDSUS-8157)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    시리얼의 시작값을 변경하면 시리얼의 NEXTVAL을 "설정 값 + 1"부터 반환했으나 "설정 값"부터 반환하도록 변경했다.

    .. code-block:: sql

        ALTER SERIAL s1 START WITH 10;
        SELECT s1.NEXTVAL; -- return 10

칼럼의 숫자 타입에 저장된 숫자 값의 길이보다 작은 길이의 문자 타입으로 칼럼을 변경할 때 그 값이 문자 타입의 지정 길이를 초과하면 해당 길이만큼을 저장하도록 변경(CUBRIDSUS-8009)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    칼럼의 숫자 타입에 저장된 숫자 값의 길이보다 작은 길이의 문자 타입으로 ALTER TABLE ... CHANGE COLUMN... 을 수행할 때, 해당 칼럼의 값이 문자 타입의 지정 길이를 초과하면 빈 문자열로 처리했으나 해당 길이만큼을 저장하도록 변경했다.

    .. code-block:: sql

        CREATE TABLE t1 (i1 INT);
        INSERT INTO t1 VALUES (1), (-2147483648), (2147483647), (-2147483648), (2147483647);
        ALTER TABLE t1 CHANGE i1 s1 CHAR (4);

내림차순 인덱스 스캔 도중 인터럽트 발생 시 ER_INTERRUPTED 오류를 반환하도록 변경(CUBRIDSUS-7316)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    내림차순 인덱스 스캔 도중 인터럽트 발생 시 ER_DESC_ISCAN_ABORTED 오류를 반환했으나, ER_INTERRUPTED 오류를 반환하도록 변경했다.

SHOW COLUMNS FROM 문의 출력 타입 문자열 변경(CUBRIDSUS-8533)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    SHOW COLUMNS FROM 문에서 STRING(n), VARBIT(n)로 출력되는 타입의 문자열들이 각각 VARCHAR(n), BIT VARYING(n)로 변경되었다.

SHOW COLUMNS ... 결과 출력 시 특정 타입의 DEFALUT 값 출력에 포함된 홑따옴표 제거(CUBRIDSUS-5921)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    테이블 정보를 출력하는 SHOW COLUMNS ... 수행 시 CHAR나 DATETIME 등의 DEFAULT 값 출력에 홑따옴표가 포함되었으나 이를 제외하도록 수정했다. 

응용 프로그램에서 데이터베이스에 DBA로 접속한 이후 재접속 시 암호가 틀려도 정상 접속되는 문제 수정(CUBRIDSUS-7192)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    응용 프로그램에서 데이터베이스에 DBA로 접속한 이후에는 DBA 또는 다른 사용자로 재접속할 때 암호가 틀려도 접속에 성공하는 문제를 수정했다.

login() 메서드의 동작 변경(CUBRIDSUS-6307)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    CSQL 인터프리터를 DBA로 수행한 경우 패스워드 확인 없이 다른 사용자로 연속해서 login()이 허용되었으나, DBA가 아닌 사용자로 login()을 수행한 이후에는 비밀번호 없이 다른 사용자로 login() 수행이 허용되지 않도록 변경했다. 

    ::

        % csql -u dba demodb
        csql> CALL login ('test1', '') ON CLASS db_user; -- dba가 test1에 login()하므로 패스워드 확인 없이 허용 
        csql> CALL login ('test2', '') ON CLASS db_user; -- test1으로 login()한 이후 test2로 login() 시 패스워드 확인 없이는 허용되지 않음

드라이버
--------


[JDBC, CCI] CURSOR HOLDABILITY가 기본으로 동작하도록 변경(CUBRIDSUS-8609)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    JDBC, CCI에서 SELECT 질의 수행 시 커서 유지가 기본으로 동작하도록 변경되었다. 따라서 커서 페치 도중 커밋이 수행되어도 커서는 유지되어 페치를 계속 진행할 수 있다. 사용이 완료된 커서는 반드시 닫아주어야 한다.

[JDBC] NUMERIC 타입의 이름을 DECIMAL이 아니라 NUMERIC으로 반환(CUBRIDSUS-8387)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    DatabaseMetaData.getColumns() 메서드가 NUMERIC 타입의 이름을 DECIMAL로 반환하던 것을 NUMERIC으로 반환한다.

    .. code-block:: java

        //수정 이전 버전에서는 Hibernate를 이용해서 엔티티 간 매핑 설정을 할 때 NUMERIC 타입의 칼럼을 지정하면  
        Caused by: org.hibernate.HibernateException: Wrong column type in mytbl_map for column col2. Found: decimal, expected: numeric(19,0)"  
        와 같은 오류가 발생했다.

        @ManyToMany
        @JoinTable(name="mytbl", joinColumns={@JoinColumn(name="col1", columnDefinition="varchar(255)")}, inverseJoinColumns={@JoinColumn(name="col2", columnDefinition="numeric(19,0)")})

        private Set<MyGroup> accessMyGroups;

[JDBC] getColumnClassName() 메서드의 NUMERIC 타입 칼럼에 대한 JAVA 반환 타입 변경 (CUBRIDSUS-7532) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    ResultSetMetaData.getColumnClassName() 메서드가 NUMERIC 타입 칼럼에 대해 기존의 java.lang.Double대신 java.math.BigDecimal을 반환하도록 수정했다.

[CCI] cci_get_db_parameter() 함수가 반환하는 잠금 타임아웃 값의 단위를 밀리초로 변경(CUBRIDSUS-7538)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    cci_get_db_parameter() 함수가 반환하는 잠금 타임아웃 값의 단위를 초 단위에서 밀리초(msec) 단위로 변경했다.

[CCI] cci_connect_with_url() 함수의 URL 문자열에서 사용하는 autocommit 속성 제거(CUBRIDSUS-7306)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    cci_connect_with_url() 함수의 URL 문자열에서 사용하는 autocommit 속성을 제거했다.

기본 설정 변경  
--------------

레플리카 노드에서는 항상 보관 로그를 삭제하도록 변경(CUBRIDSUS-8556)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    레플리카 노드에서 보관 로그 삭제를 위해서는 시스템 파라미터 force_remove_log_archives의 설정 값을 항상 yes로 변경해야 했다. 설정을 하지 않았을 경우 불필요한 보관 로그가 계속 쌓이면서 문제를 야기시킬 수 있었는데, 9.0 Beta부터 레플리카 노드는 force_remove_log_archives의 설정 값과 상관 없이 항상 보관 로그를 삭제하도록 변경했다. 

설치할 때 보관 로그 파일의 최대 개수를 설정하는 시스템 파라미터의 초기 값을 0으로 설정하도록 수정(CUBRIDSUS-6603) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    CUBRID를 처음 설치할 때 cubrid.conf에 "log_max_archives=0" 설정이 추가되었다.  log_max_archives의 값이 0이면 보관 로그 파일을 보관하지 않으므로, 보관 로그 파일이 디스크 공간을 차지하지는 않지만 저장 매체 장애(media failure)가 발생하면 원하는 시점으로의 복구가 불가능할 수 있다. 저장 매체 장애에 대비하여 데이터베이스를 복구할 수 있도록 하기 위해서는 백업 주기 등을 감안하여 이 파라미터 값을 적절하게 설정해야 한다.

복제 로그 반영 프로세스의 메모리 사용량이 500MB를 넘지 않도록 변경(CUBRIDSUS-6068)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    HA 환경에서 복제 로그 반영 프로세스의 메모리 사용량이 500MB를 넘으면 복제 불일치가 발생할 수 있었으나, 복제 로그 반영 프로세스의 사용량이 500MB를 넘지 않도록 수정했다. 이전 버전에서 cubrid_ha.conf의 ha_apply_max_mem_size 값을 500 이상으로 설정한 사용자는 9.0 Beta 버전 이상으로 업그레이드한 이후 500 이하로 변경해야 함에 주의한다. 

기타
----


오류 번호 범위 변경(CUBRIDSUS-7666) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    브로커 응용 서버(CAS), 브로커 서버, CCI 드라이버, JDBC 드라이버의 오류 번호 범위를 변경했다. CAS는 -10000부터 -10999, 브로커 서버는 -11000부터 -11999, CCI는 -20000부터 -20999, JDBC는 -21000부터 -21999 범위를 에러 번호로 사용한다.

lock_timeout값이 -1이나 0일 때 브로커 응용 서버(CAS)로그와 lockdb 유틸리티의 출력 형식 변경(CUBRIDSUS-8915)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    시스템 파라미터인 lock_timeout 값이 -1(infinite wait)또는 0(no wait)으로 설정되어 있을 때, CAS 로그와 lockdb 유틸리티의 출력 형식을 각각 그 의미대로 "Infinite wait", "No wait"로 출력하도록 변경했다.
    
개선 및 오류 수정 
=================

성능 및 리소스 
--------------



SET 절에 서로 다른 상수를 명시한 UPDATE 문들이 질의 계획 캐시에 별개로 캐시되지 안도록 개선(CUBRIDSUS-8511)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    UPDATE 문의 SET 절에 명시된 상수 값이 다르면 해당 질의들이 질의 계획 캐시에서 같은 패턴임에도 별개로 간주되었으나, 이들 상수들이 호스트 변수로 자동 치환되도록 하여 하나의 패턴만 유지되도록 했다.

ORDER BY 절과 LIMIT 절이 있는 같은 패턴의 질의들이 질의 계획 캐시에 다른 계획으로 별개로 캐시되지 않도록 개선(CUBRIDSUS-8813)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    ORDER BY 절과 LIMIT 절이 있는 같은 패턴의 질의는 LIMIT 절의 상수 값이 다르더라도 질의 계획 캐시에 같은 계획으로 저장되도록 수정했다.

INSERT ON DUPLICATE KEY UPDATE문의 수행 성능 개선(CUBRIDSUS-8287)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    INSERT ON DUPLICATE KEY UPDATE 문의 대상 테이블에 기본 키를 포함한 고유 키가 두 개 이상 존재하는 경우 수행이 느려질 수 있는 현상을 개선했다.

    .. code-block:: sql

        CREATE TABLE x (a INT PRIMARY KEY, b INT, c INT, d INT, UNIQUE (b), UNIQUE (c));
        CREATE SERIAL s;
        INSERT INTO x VALUES (s.NEXT_VALUE, 0, 0, 0) ON DUPLICATE KEY UPDATE d = d + 1;

커버링 인덱스 스캔 성능 개선(CUBRIDSUS-7466)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
잠금 에스컬레이션 성능 개선(CUBRIDSUS-5698) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    레코드 잠금이 일정 개수를 초과하면 테이블 잠금으로 변환하는 작업을 수행하는 잠금 에스컬레이션(lock escalation)의 성능을 개선했다. lock_escalation 파라미터의 값이 5000 이고 100개의 분할을 가진 테이블에 100만 개의 레코드를 입력하는 시험에서 수정 전에 비해 수정 후의 성능이 3.5배 빨라졌다.

키 잠금과 관련하여 롤백 시 데이터 불일치 현상 수정 및 DML 성능 개선(CUBRIDSUS-7080)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    키 잠금(key locking) 방식을 수정하여 인덱스가 있는 행에 INSERT하는 작업의 롤백 등에서 발생할 수 있는 데이터 불일치 현상을 수정했고, 인덱스가 있는 행에 대한 INSERT, DELETE 및 SELECT의 처리 성능을 개선했다.

UNION ALL 질의문의 수행 성능 개선(CUBRIDSUS-8130)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    UNION ALL 질의문의 결과를 만들 때 앞쪽 질의문의 중간 결과 투플을 복사하지 않고 재사용하여 성능을 개선했다. 

    .. code-block:: sql

        -- 다음의 예에서 t1 테이블의 건수가 클수록 수정으로 인한 성능 개선폭이 증가한다. 
        SELECT * FROM t1 UNION ALL SELECT * FROM t2;

DATE_ADD()의 성능 개선(CUBRIDSUS-7464)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

테이블 DROP과 CREATE를 반복할수록 CREATE 시간이 오래 걸리는 문제(CUBRIDSUS-7288)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    테이블 DROP과 CREATE를 반복할수록 CREATE 시간이 오래 걸리는 문제를 수정했다. 참고로 수정 이전 버전에서도 테이블 생성 시 아래의 예와 같이 REUSE_OID 옵션을 지정하면 이러한 현상이 발생하지 않았다.

    .. code-block:: sql

        CREATE TABLE reuse_tbl (a INT PRIMARY KEY) REUSE_OID

INSERT와 DELETE 반복 시 수행 시간이 점차 느려지는 현상(CUBRIDSUS-7654)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    INSERT와 DELETE를 반복 수행하면 수행 시간이 점차 느려지는 현상을 수정했다.

DESC, SHOW INDEX, SHOW COLUMNS 문 수행 성능 개선(CUBRIDSUS-5868)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

TRUNCATE 문을 빈번하게 수행한 이후 INSERT를 비롯한 접근 성능이 현저히 떨어지는 현상(CUBRIDSUS-6499)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    TRUNCATE 문을 빈번하게 수행한 이후에 INSERT 속도가 현저히 떨어지는 현상을 수정했다.

페이지 크기를 넘어가는 레코드들에 대해 UNION 수행 결과 건수가 1건인 경우 메모리 누수 현상(CUBRIDSUS-7158)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    페이지 크기를 넘는 오버플로우 레코드들에 대해 UNION 질의 수행 결과 건수가 1건인 경우 발생하는 메모리 누수(memory leak) 현상을 수정했다. UNION ALL 질의는 메모리 누수 현상이 발생하지 않는다.

하나의 인덱스 키에 중복되는 레코드 값이 많아진 이후 수행되는 INSERT에 대해 볼륨 사용량이 급격히 증가하는 현상(CUBRIDSUS-8375)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    하나의 인덱스 키에 중복되는 레코드 값이 많아 오버플로우 OID 레코드가 생성되면 이후 해당 키보다 작은 값이 입력될 때 항상 새로운 페이지에 키가 입력되어 볼륨 사용량이 급격히 증가하는 문제를 수정했다.

같은 칼럼에 두 개 이상의 외래 키를 정의하고 테이블을 DROP한 이후 일부 공간이 재사용되지 못하는 오류(CUBRIDSUS-8256)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    하나의 칼럼에 이름만 다른 외래 키를 두 개 이상 정의하고 테이블을 DROP하면 일부 공간이 재사용되지 못하는 오류를 수정했다.

    .. code-block:: sql

        CREATE TABLE foo (a INT, PRIMARY KEY (a));
        CREATE TABLE bar (a INT,
            CONSTRAINT con1 FOREIGN KEY(a) REFERENCES foo (a),
            CONSTRAINT con2 FOREIGN KEY(a) REFERENCES foo (a));

        -- INSERT records

        DROP TABLE bar;
        DROP TABLE foo;

INSERT ... SELECT 문으로 대량의 레코드를 입력하면 서버 프로세스의 메모리 사용량이 급격히 증가하는 문제(CUBRIDSUS-8736) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    INSERT ... SELECT 문을 통해서 대량(예를 들어 200만건 정도)의 레코드를 입력할 때에 서버 프로세스의 메모리 사용량이 급격히 증가하는 문제를 수정했다.

INSERT 문의 값으로 질의문 또는 함수를 인자로 사용한 CONCAT_WS 함수를 입력하는 경우 발생하는 오류(CUBRIDSUS-6206)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    INSERT 문의 값으로 질의문 또는 함수를 인자로 사용한 CONCAT_WS 함수를 입력하는 경우 " ERROR: Cannot evaluate ' concat_ws('a', cast ( SYS_DATE as varchar))' " 오류가 발생하는 문제를 수정했다.

    .. code-block:: sql

        INSERT INTO tbl VALUES (1, CONCAT_WS ('a', SYS_DATE()));

OR 절에 부질의가 중첩되어 나타나는 질의 수행 시 장시간 소요되는 현상(CUBRIDSUS-6031) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    OR 절에 부질의(subquery)가 포함된 질의 수행 시 장시간 소요되는 현상을 수정했다.

    .. code-block:: sql

        SELECT col2 
        FROM tab0
        WHERE (A AND B) OR (col3 IN (SELECT i FROM t WHERE X AND Y OR Z AND W) AND D);

DELETE FROM ALL 문이 LOB 파일을 삭제하지 못하는 오류(CUBRIDSUS-5596)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    DELETE FROM ALL 문으로 상속 계층에 대해서 삭제할 때 해당 테이블 및 이를 상속받는 테이블들의 LOB 파일이 삭제되지 않는 오류를 수정했다.

    .. code-block:: sql

        DELETE FROM ALL parent_tbl;

인덱스 생성 시 임시 볼륨 사용량 최적화(CUBRIDSUS-5528)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    인덱스 생성 과정에서 더 이상 사용되지 않는 페이지를 반납하여 임시 볼륨을 필요 이상으로 많이 사용하지 않도록 수정했다.

일시적 임시 볼륨 크기 최적화(CUBRIDSUS-5639)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    일시적 임시 볼륨 추가 시 필요 이상의 큰 볼륨을 생성하지 않도록 수정했다. 

특정 상황에서 인덱스 볼륨 여유 공간이 있어도 일반 볼륨을 생성하는 문제(CUBRIDSUS-5595)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    인덱스 생성 시 여유 공간이 가장 많은 인덱스 볼륨 파일의 여유 공간이 인덱스 생성에 필요한 전체 공간의 25%보다 작으면, 인덱스 볼륨을 사용하지 않고 일반 볼륨을 생성하는 문제를 수정했다. 
 
백그라운드 보관 로그 파일에서 정상 상황임에도 불구하고 파일 I/O sync. 오류 메시지를 잘못 출력하는 현상(CUBRIDSUS-8163)  
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    백그라운드 보관 로그 파일에서 정상 상황임에도 불구하고 파일 I/O sync. 오류 메시지(에러 코드: -599)를 잘못 출력하는 현상을 수정했다.  

    ::

        An I/O error occurred while synchronizing state of volume "/home/cubrid/database/testdb/testdb_lgar_t".... Bad file descriptor  

UPDATE STATISTICS 문 수행으로 인해 다른 트랜잭션의 UPDATE 문이 장시간 대기하는 현상(CUBRIDSUS-6981)  
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    UPDATE STATISTICS 문 수행 도중에 인덱스 페이지에 대한 래치(latch)를 오래 유지하지 않도록 하여 다른 트랜잭션들이 장시간 대기하지 않도록 수정했다.  

연산자와 SQL 함수
-----------------


날짜/시간 함수에서 입력 인자로 YYYYMMDDH 형식을 지원하게 됨(CUBRIDSUS-8622)  
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    TIME , TO_DATETIME 과 같은 날짜/시간 함수에서 입력 인자로 YYYYMMDDH 형식을 지원하도록 수정했다.  

    .. code-block:: sql

        SELECT TIME ('1104209');
        
    ::
    
           time('1104209')  
        ======================
          '09:00:00'

    .. code-block:: sql
          
        SELECT TO_DATETIME ('1104209','YYMMDDH');
        
    ::
    
           to_datetime('1104209', 'YYMMDDH', 'en_US')  
        =============================================  
           09:00:00.000 AM 04/20/2011  

ADDTIME 함수가 잘못된 결과를 반환하는 문제(CUBRIDSUS-8568)  
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    ADDTIME 함수가 잘못된 결과를 반환하는 문제를 수정했다.  

    .. code-block:: sql

        SELECT ADDTIME ('2012-02-02','9:9:9');  

INT 타입의 최소값이 저장된 칼럼에 % 연산, BIT_AND 함수 혹은 BIT_OR 함수 수행 시 오버플로우 오류(CUBRIDSUS-6203)  
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    INT 타입의 최소값인 -2147483648 이 저장된 칼럼에 % 연산, BIT_AND 함수 또는 BIT_OR 함수를 수행하면 " ERROR: Overflow occurred in ... " 오류가 발생하는 문제를 수정했다.  

    .. code-block:: sql

        INSERT INTO tbl VALUES (-2147483648);  
        SELECT i % 1009 FROM tbl;  
        SELECT BIT_AND (i) FROM tbl;  

TRIM 함수가 잘못된 결과를 출력하는 오류(CUBRIDSUS-6591)  
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    SQL 함수인 TRIM 함수가 지정한 삭제 대상 문자열보다 한 글자를 더 삭제하는 오류를 수정했다. 다음 예와 같이 "foook"에서 "foo"를 TRIM하면 "ok"를 출력해야 한다.  

    .. code-block:: sql

        SELECT TRIM ('foo' FROM 'foook');  

INDEX_CARDINALITY 함수의 입력 인자로 소문자인 테이블 이름만 인식하는 오류(CUBRIDSUS-6264)  
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    INDEX_CARDINALITY 함수의 입력 인자로 소문자인 테이블 이름만 인식하는 오류를 수정했다.  

CONCAT 함수와 CONCAT_WS 함수의 입력 인자가 CHAR 타입만 있는 질의 수행 시 오류(CUBRIDSUS-6524)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    CONCAT 함수와 CONCAT_WS 함수의 입력 인자가 CHAR 타입만 주어진 경우 " ERROR: No error message available. " 오류 메시지와 함께 질의 수행에 실패하는 현상을 수정했다.

    .. code-block:: sql

        CREATE TABLE t1 (a int , b char (20) );
        INSERT INTO t1 VALUES (-1, '');

        --below statement will throw "ERROR: No error message available." message.
        SELECT CONCAT (b) FROM t1;

CLOB_TO_CHAR 함수 수행 시 오류(CUBRIDSUS-6520) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    CLOB 칼럼이 있는 테이블에, 고유 인덱스를 스캔하는 REPLACE 문을 수행하고 커밋한 후에 CLOB_TO_CHAR()를 수행하면 " ERROR: External file "xxxx" was not found. " 오류 메시지와 함께 질의 수행에 실패하는 현상을 수정했다.

    .. code-block:: sql

        SELECT id, CLOB_TO_CHAR (text) FROM tbl ORDER BY id;

TIMEDIFF 함수의 입력 인자가 DATE 타입인 질의 수행 시 오류(CUBRIDSUS-8692)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    TIMEDIFF 함수의 입력 인자가 DATE 타입인 경우 " ERROR: Conversion error in time format. " 오류 메시지와 함께 수행에 실패하는 현상을 수정했다.

    .. code-block:: sql

        SELECT TIMEDIFF (TO_DATE ('2012-12-2'), TO_DATE ('2012-11-2'));

CONCAT_WS 함수가 LEFT OUTER JOIN의 조건으로 존재할 때 조인 결과를 적게 출력하는 현상(CUBRIDSUS-6590)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    CONCAT_WS 함수가 LEFT OUTER JOIN의 조건으로 존재할 때 LEFT OUTER JOIN 질의를 최적화하는 과정의 오류로 인해 CONCAT_WS 함수의 입력 인자 값 하나만 NULL이어도 함수의 결과 값을 항상 NULL로 간주하여 조인 결과를 적게 출력하는 현상을 수정했다.

    .. code-block:: sql

        SELECT * 
        FROM t1 LEFT JOIN t2 ON t1.id = t2.id 
        WHERE CONCAT_WS (' ', t1_name, t2_name) LIKE '%In%';

DATE_ADD 함수의 INTERVAL 값을 호스트 변수로 사용하면 질의 수행 시 서버가 비정상 종료되는 현상(CUBRIDSUS-7610)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    질의를 PREPARE할 때 SQL 함수인 DATE_ADD 함수의 INTERVAL 값을 호스트 변수로 사용하면, EXECUTE할 때 서버가 비정상 종료되는 현상을 수정했다. 이와 함께 DATE_ADD 함수의 INTERVAL 단위에 따라 입력 값의 타입으로 INTEGER만 가능했던 동작을 VARCHAR도 가능하게 수정했다.

    .. code-block:: sql

        PREPARE s FROM 'SELECT DATE_ADD (?, INTERVAL ? YEAR_MONTH)';
        EXECUTE s USING '2010-01-01', 1;
        EXECUTE s USING '2010-01-01', '1-1';

집계 함수의 인자 안에 DISTINCTROW가 존재하는 질의가 동작하지 않는 문제(CUBRIDSUS-7414)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    집계 함수의 인자 안에 DISTINCTROW가 존재하는 경우, " Syntax error: unexpected 'DISTINCTROW' " 오류를 출력하면서 해당 질의가 동작하지 않는 문제를 수정했다.

일부 SQL 함수에서 모든 인자가 호스트 변수일 때 값을 바인딩하면서 질의 수행에 실패하는 현상(CUBRIDSUS-7521)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    NULLIF, LEAST, GREATEST 등 일부 SQL 함수에서 모든 인자가 호스트 변수일 때 값을 바인딩하면서 DOUBLE로 타입 변환을 시도하게 되어 질의 수행에 실패하는 현상을 수정했다. 

    .. code-block:: java

        preStmt = conn.prepareStatement("select nullif (?, ?)");
        preStmt.setString(1, "A");
        preStmt.setString(2, "a");
        rs = preStmt.executeQuery();

PREPARE 문에서 DEFAULT 지정 인자를 생략한 DECODE 함수 수행 시 오류(CUBRIDSUS-9134)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    PREPARE 문에서 DECODE 함수 수행 시 DEFAULT 값을 지정하는 세 번째 입력 인자를 생략하면 " ERROR: Attribute "val" cannot be made NULL. " 오류 메시지와 함께 수행에 실패하는 현상을 수정했다.

    .. code-block:: sql

        PREPARE stmt1 FROM 'UPDATE foo SET del_ts = 100, val=DECODE(name,?,val + ?) WHERE name IN (?)';
        EXECUTE stmt1 USING 'seo', 1, 'seo';

SELECT 리스트에 INSERT 함수 혹은 ELT 함수가 있고 그 뒤에 값이 오는 질의 수행 시 오류 (CUBRIDSUS-6577)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    SELECT 리스트에 INSERT 함수 혹은 ELT 함수가 있고 그 뒤에 값이 오면 " ERROR: System error (query result) in ../../src/parser/query_result.c " 오류 메시지와 함께 질의 수행에 실패하는 현상을 수정했다.

    .. code-block:: sql

        SELECT INSERT('test',2,1,'hi'), 5;
        SELECT ELT(2, 1), 5;


부질의 내에 집계 함수가 있는 질의문에 USING INDEX 구문을 포함하면 비정상 종료되는 현상(CUBRIDSUS-8057)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    SELECT 리스트의 부질의(sub-query) 내에 집계 함수를 포함하는 질의문에 USING INDEX 구문을 포함하면 비정상 종료되는 현상을 수정했다. 

SQL 문
------


SELECT ALL/DISTINCT 상수 또는 DISTINCT (칼럼)이 가능해짐(CUBRIDSUS-6080) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    "SELECT ALL 상수" 혹은 "SELECT DISTINCT 상수"가 가능하도록 수정했다.

    .. code-block:: sql

        SELECT ALL 1;
        SELECT DISTINCT 1;

    아울러, 칼럼을 괄호로 감싸거나 상수를 DISTINCT하여 집계 함수를 수행하는 것이 가능하도록 수정했다.

    .. code-block:: sql

        SELECT SUM (DISTINCT (i)) FROM t;
        SELECT SUM (DISTINCT 4) FROM t;

FROM 절의 유도 테이블(derived table) 이름 생략이 가능해짐(CUBRIDSUS-6546) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    반드시 명시해야 했던 FROM 절의 유도 테이블 이름을 생략할 수 있도록 개선했다.

    .. code-block:: sql

        SELECT * FROM (SELECT sysdate FROM db_root);

    .. code-block:: sql
    
        -- 수정 이전 구문
        FROM (subquery) [ AS ] derived_table_name [( column_name [ {, column_name } ... ] )]

        -- 수정 이후 구문 
        FROM (subquery) [ [ AS ] derived_table_name [( column_name [ {, column_name } ... ] )] ]

사용하지 않는 예약어 제거(CUBRIDSUS-6250) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    ALIAS, TYPE, VIRTUAL, TEST, WAIT 등 사용하지 않는 예약어(reserved word)는 제거하여, 해당 예약어를 테이블 이름이나 칼럼 이름 등의 식별자로 사용할 수 있게 개선했다.

    식별자로 사용이 가능해진 기존 예약어들은 다음과 같다.

    +---------+----------+-----------+------------+------------+
    | ALIAS   | ASYNC    | CLUSTER   | COMPLETION | DICTIONARY |
    +---------+----------+-----------+------------+------------+
    | EXCLUDE | LDB      | OID       | OPERATION  | OPERATORS  |
    +---------+----------+-----------+------------+------------+
    | OTHERS  | PENDANT  | PREORDER  | PRIVATE    | PROTECTED  | 
    +---------+----------+-----------+------------+------------+
    | PROXY   | REGISTER | STRUCTURE | SYS_USER   | TEST       |
    +---------+----------+-----------+------------+------------+
    | THERE   | TYPE     | VIRTUAL   | VISIBLE    | WAIT       |
    +---------+----------+-----------+------------+------------+


DO 문에 SELECT 질의문의 입력이 가능해짐(CUBRIDSUS-6528)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    DO문에 SELECT 질의문의 입력이 가능하도록 수정했다. 

    .. code-block:: sql

        DO (SELECT count(*) FROM athlete);

UTF-8 문자셋을 테이블 이름이나 칼럼 이름 등의 식별자로 사용 가능해짐(CUBRIDSUS-7227)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    UTF-8 문자셋을 테이블 이름이나 칼럼 이름 등의 식별자로 사용 가능하도록 개선했다. 자세한 사항은 :ref:`casing-and-identifiers`\ 을 참고한다.

칼럼 이름 변경 시 기존 칼럼 이름과 새 칼럼 이름 사이에 AS 대신 TO도 사용할 수 있게 됨(CUBRIDSUS-7477)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    칼럼 이름 변경 시 AS만 사용 가능했으나 AS 대신 TO도 사용할 수 있도록 추가했다.

    .. code-block:: sql

        CREATE TABLE t (a INT);
        ALTER TABLE t RENAME COLUMN a TO b;

IN, NOT IN 조건의 스칼라 부질의에, ORDER BY 절이 사용되거나 SELECT 리스트의 칼럼 개수가 여러 개인 경우 잘못된 질의 결과를 출력하는 현상(CUBRIDSUS-7700)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    IN, NOT IN 조건의 스칼라 부질의(scalar subquery)에 ORDER BY 절이 사용되거나 해당 질의에 대한 SELECT 리스트의 칼럼 개수가 여러 개인 경우 잘못된 질의 결과를 출력하는 현상을 수정했다.

    .. code-block:: sql

        -- 수정 이전 버전에서 스칼라 부질의에 ORDER BY 절이 사용되면 질의 결과가 항상 0건이 되었다.
        SELECT * FROM tbl WHERE col IN (SELECT col FROM tbl2 ORDER BY b);

        -- 수정 이전 버전에서 스칼라 부질의에 대한 SELECT 리스트의 칼럼이 두 개 이상 사용되면 문법(semantic) 오류가 발생해야 하나, 질의 결과가 0건이 되었다.
        SELECT * FROM tbl WHERE col IN (SELECT a, b FROM tbl2);
        SELECT * FROM tbl WHERE col NOT IN (select a,b from tbl2);

IN 절의 호스트 변수 타입이 날짜/시간인 경우 정상 수행되지 않는 현상(CUBRIDSUS-7916)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    IN 절의 호스트 변수 타입이 날짜/시간인 경우 정상 수행되지 않는 현상을 수정했다.

    수정 이전 버전에서 바인딩할 값의 타입이 날짜 / 시간 타입인 경우 아래의 Q1 은 데이터가 삭제되어 정상 동작했으나 Q2 는 데이터가 삭제되지 않아 비정상적으로 동작했다 .

    .. code-block:: sql

        DELETE FROM TBL WHERE D = ?;    -- Q1

        DELETE FROM TBL WHERE D IN (?);    -- Q2

GROUP BY 절과 연관 부질의, SELECT 리스트에 없는 칼럼으로 정렬하는 ORDER BY가 같이 있으면 잘못된 결과를 출력할 수 있는 현상(CUBRIDSUS-8640)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    GROUP BY와 연관 부질의(correlated subquery) 그리고 ORDER BY 절에 SELECT 리스트에 없는 칼럼이 지정되었을 때 잘못된 결과를 출력하는 현상을 수정했다.

    .. code-block:: sql

        SELECT (SELECT f1.a FROM foo f1 WHERE f1.b = f2.b) as t
        FROM foo f2
        WHERE f2.b >= 1 and f2.b < 10
        GROUP BY f2.c
        ORDER BY f2.c;

GROUP BY 절의 WITH ROLLUP 수정자 지정 시 수행 결과가 잘못될 수 있는 문제(CUBRIDSUS-6518)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    GROUP BY 절의 WITH ROLLUP 수정자를 지정하면 수행 결과가 잘못될 수 있는 문제를 수정했다.

    .. code-block:: sql

        -- 수정 이전 버전에서 다음 질의 수행 시, ROLLUP된 결과 값이 출력되지 않았다.

        SELECT a FROM t1
        GROUP BY A WITH ROLLUP;

        -- 수정 이전 버전에서 다음 질의 수행 시, ROLLUP된 결과 레코드의 a 칼럼 값이 NULL인데 a>1 이므로 출력되지 않아야 하나 출력되었다. 
        SELECT a, COUNT(*) FROM t1 
        GROUP BY a WITH ROLLUP HAVING a > 1;

부질의의 SELECT 리스트 형식이 "\*, 칼럼"인 경우 "," 뒤의 칼럼들을 출력하지 않는 문제(CUBRIDSUS-6589)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    부질의의 SELECT 리스트 형식이 "\*, 칼럼"인 경우 "," 뒤에 명시된 칼럼들을 출력하지 않는 문제를 수정했다.

    .. code-block:: sql

        SELECT b FROM (SELECT *, 'hello' AS b FROM t1) t;

ESCAPE 절에 명시된 이스케이프 문자가 LIKE 패턴의 마지막 문자인 경우에 오류(CUBRIDSUS-6849)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    ESCAPE 절에 명시된 이스케이프 문자가 LIKE 패턴의 마지막 문자인 경우에 " System error " 오류 메시지와 함께 질의 수행에 실패하는 문제를 수정했다.

    .. code-block:: sql

        CREATE TABLE foo (a char (10));
        SELECT * FROM foo WHERE a LIKE 'ab' ESCAPE 'b';

    ::
    
        ERROR: System error (db_compress_like_pattern) in ../../src/optimizer/query_rewrite.c (line: 3291)

SELECT 리스트에 \*를 지정한 질의문과 칼럼 명을 명시한 질의문을 UNION할 때 오류 (CUBRIDSUS-6588)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    SELECT 리스트에 와일드카드(\*)를 지정한 질의문과 칼럼 명을 명시한 질의문을 UNION 등 문장 집합 연산자로 연결한 경우 칼럼 개수가 같음에도 불구하고 " ERROR: The number of columns, 0, in the left query do not match the number of columns, N, in the right query. " 오류 메시지와 함께 질의 수행에 실패하는 현상을 수정했다.

    .. code-block:: sql

        (SELECT * FROM t1) UNION (SELECT a, b FROM t2 );

질의의 비교 조건 절에 호스트 변수가 있는 경우 잘못된 결과 출력(CUBRIDSUS-5843) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    질의의 비교 조건 절에 호스트 변수가 있는 경우, 해당 호스트 변수에 입력되는 값의 타입이 변환되어 질의의 기대와 다르게 결과가 출력되는 문제를 수정했다.

    .. code-block:: sql

        -- 수정 이전 버전에서도 호스트 변수가 아닌 상수를 쓰는 경우에는 결과값이 정상 출력되었다.
        SELECT * FROM foo WHERE a > 2.5;

    ::
    
        a
        =============
        3
        4
        5

    .. code-block:: sql

        -- 칼럼 a의 타입은 INT일 때, 수정 이전 버전에서는 입력되는 값이 2.5이면 INT인 3으로 변환되어 비교되는 오류가 발생했다. 
        PREPARE stmt FROM 'SELECT * FROM foo WHERE a > ?';
        EXECUTE stmt USING 2.5;

    ::
    
        a
        =============
        4
        5

UNION과 LIMIT 절을 포함한 부질의가 있는 질의 수행 시 잘못된 결과를 출력(CUBRIDSUS-6596)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    UNION과 LIMIT 절을 포함한 부질의가 있는 질의를 수행하면 잘못된 결과를 출력하는 문제를 수정했다.

    .. code-block:: sql

        CREATE TABLE t1 (a INT);
        INSERT INTO t1 VALUES (1);

        --수정 이전 버전에서는 다음 질의에 대해 0건을 출력했다.
        SELECT * 
        FROM ((SELECT a from t1) UNION (SELECT a from t1) LIMIT 1) s1;

UNION 절이 있는 부질의가 WHERE 절 조건에 사용되는 질의 수행 시 오류(CUBRIDSUS-6530)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    UNION 절이 있는 부질의가 WHERE 절 조건에 존재하면 " ERROR: '(select t1.i from t1 t1)<>0' is not union compatible with '(select t2.i from t2 t2)'. " 오류 메시지와 함께 질의 수행에 실패하는 현상을 수정했다.

    .. code-block:: sql

        SELECT * 
        FROM t1 
        WHERE EXISTS ((SELECT i FROM t1) UNION ALL (SELECT i FROM t2));

병합 조인 방식으로 OUTER JOIN 질의 수행 시 잘못된 질의 결과를 출력하는 오류(CUBRIDSUS-5703)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    병합 조인(merge join) 방식으로 OUTER JOIN 질의를 수행하면 잘못된 질의 결과를 출력하는 오류를 수정했다.

    .. code-block:: sql

        SELECT /*+ USE_MERGE */ * FROM tab t
        LEFT OUTER JOIN idx i ON t.t = i.t
        LEFT OUTER JOIN col c ON i.i = c.i AND c.c = t.c;

ROWNUM과 ORDERBY_NUM()이 같이 사용된 질의에서 ROWNUM의 행 개수보다 ORDERBY_NUM()의 행 개수가 크면 결과 개수가 잘못되는 현상(CUBRIDSUS-6676)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    ROWNUM으로 행 개수를 제한한 후 정렬된 결과에서 ORDERBY_NUM()으로 행 개수를 제한 출력하는 조건에서 ROWNUM의 행 개수보다 ORDERBY_NUM()의 행 개수가 크면 잘못된 개수의 결과를 출력하는 현상을 수정했다.

    .. code-block:: sql

        SELECT * 
        FROM foo f, bar b 
        WHERE f.a > 0 AND f.a = b.a AND ROWNUM <= 4 
        ORDER BY f.a FOR ORDERYBY_NUM() <= 10;

TIMESTAMP 타입에서 오버플로우 오류 처리가 잘못되는 문제(CUBRIDSUS-6004)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    TIMESTAMP 타입에 대해 아래와 같은 질의에서 오버플로우 오류 처리가 되지 않는 문제를 수정했다. 수정된 버전에서는 아래의 질의를 수행하면 오버플로우 오류를 반환한다.

    .. code-block:: sql

        SELECT timestamp'01/19/2038 12:14:07 pm' - CAST (-32768 AS SMALLINT);

ANY, SOME 한정자의 인자로 ORDER BY 절이 있는 부질의 수행 시 오류(CUBRIDSUS-7799)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    ANY, SOME 한정자의 인자로 ORDER BY 절이 있는 부질의를 수행하면 " ERROR: Aggregate function must have 1 argument: min(t2.id, t2.a). " 오류가 발생하는 문제를 수정했다.

    .. code-block:: sql

        SELECT * 
        FROM t1 
        WHERE id > ANY(SELECT id FROM t2 ORDER BY a);

다중 질의를 한 번에 PREPARE한 이후 반복 실행하면 첫 번째 수행만 정상 수행되는 현상(CUBRIDSUS-7455)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    다중 질의를 한 번에 PREPARE한 이후 반복 실행하면 첫 번째 수행만 정상 수행되고, 두 번째 수행부터는 오류가 발생하는 현상을 수정했다.

    .. code-block:: java

        String MULTI_SELECT = "SELECT A FROM T1 WHERE A = ?; UPDATE T1 SET A = 2 WHERE A = 2; SELECT A, B FROM T1 WHERE A = ?; SELECT A, B, A AS C FROM T1 WHERE A = ?;";
        
        PreparedStatement p = c.prepareStatement(MULTI_SELECT);
        ...
        while(...)
        {
            ...

            p.execute();
            ...
        }

EXISTS 조건과 FOR ORDERBY_NUM() BETWEEN 조건이 있는 질의에서 key limit 최적화가 잘못 적용되는 문제(CUBRIDSUS-9198)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    EXISTS 조건과 FOR ORDERBY_NUM() BETWEEN 조건이 있는 질의에서 적용되지 않아야 할 key limit 최적화가 적용되면서 잘못된 결과 건수를 출력하는 문제를 수정했다.

    .. code-block:: sql

        SELECT cd, tcd, nm
        FROM a
        WHERE EXISTS (SELECT 1 FROM b WHERE a.cd = b.cd
                AND (b.no = 10000 OR b.uno = 10000))
        ORDER BY a.nm
        FOR ORDERBY_NUM() BETWEEN 1 AND 50;

UNION 질의에서 앞쪽 VARCHAR 타입 칼럼의 크기가 뒤쪽 칼럼의 크기보다 작을 때 발생하는 오류(CUBRIDSUS-9148)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    UNION 질의에서 앞쪽 VARCHAR 타입 칼럼의 크기가 뒤쪽 칼럼의 크기보다 작으면 "ERROR: Execute: Query execution failure #1336. " 오류 메시지와 함께 수행에 실패하는 현상을 수정했다. 

    .. code-block:: sql

        CREATE TABLE u1 (a VARCHAR (1));
        CREATE TABLE u2 (a VARCHAR (2));
        INSERT INTO u1 VALUES ('1');
        INSERT INTO u2 VALUES ('22');
        
        SELECT a FROM (SELECT a FROM u1 UNION ALL SELECT a FROM u2) t(a);

PREPARE 구문으로 CASE 또는 DECODE 문 수행 시 오류(CUBRIDSUS-6847)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    PREPARE 구문으로 CASE 또는 DECODE 문 수행 시 모든 인자들이 호스트 변수로 주어지는 등 타입을 결정할 수 없을 때, " ERROR: Semantic: System error (generate var) in ../../src/parser/xasl_generation.c " 오류 메시지와 함께 질의 수행에 실패하는 현상을 수정했다.

    .. code-block:: sql

        PREPARE ST FROM 'SELECT CASE WHEN col = ? THEN ? ELSE ? END FROM tbl;'

'%' 문자를 LIKE 문의 이스케이프 문자로 사용할 때의 오동작(CUBRIDSUS-7211)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    '%' 문자를 LIKE 문의 이스케이프 문자로 사용하면 오동작하는 오류를 수정했다.

    .. code-block:: sql

        -- 다음 질의 수행 시 첫번째 문자는 '%'이며, 두번째 문자 '_'는 아무 문자나 하나가 오고, 세번째 문자 이후는 'cab'인 문자열이 검색된다.
        SELECT * FROM foo 
        WHERE a LIKE '%%_cab' escape '%';

NUMERIC 타입의 범위 내의 피연산자로 나누기 연산을 수행함에도 불구하고 발생하는 오버플로우 오류(CUBRIDSUS-6506)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    NUMERIC 타입의 피연산자로 나누기 연산을 수행할 때, 입력 인자 값이 NUMVER 타입이 허용하는 범위 내의 숫자임에도 불구하고 " ERROR: Data overflow on data type numeric " 오류 메시지와 함께 질의 수행에 실패하는 현상을 수정했다.  

    .. code-block:: sql

        -- 수정 이전 버전에서는 다음의 경우에도 오류를 발생했다.
        SELECT 9/1.2345678901211111111;
        SELECT -9/1.2345678901211111111;

NUMERIC 타입 이외의 숫자 타입, 날짜/시간 타입에 대한 precision과 scale 값 수정(CUBRIDSUS-6967)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    NUMERIC 타입 이외의 숫자 타입, 날짜/시간 타입들은 precision과 scale 값이 모두 0이었으나, 각 타입마다 precision과 scale 값을 반환하도록 수정했다. 예를 들어, INT는 최대 10자리 숫자이므로 precision은 10이고 scale은 0이다. DATETIME은 "hh:mi:ss.fff mm/dd/yyyy"로 나타내므로 precision은 23이고 scale은 3이다.

GROUP BY 절에 상수 지정하여 질의 수행 시 오류(CUBRIDSUS-6268)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    SELECT '' AS group_key FROM tbl GROUP BY group_key와 같이 GROUP BY 절에 상수를 지정하면 " ERROR: xxxxxxxx in sort spec is out of range. " 오류 메시지와 함께 질의 수행에 실패하는 현상을 수정했다.

NOT 과 단항 연산자 +, -를 이용한 조건 질의 수행 시 오류(CUBRIDSUS-6040)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    NOT과 단항 연산자 -를 이용하여 다음과 같은 조건 질의 수행 시 " ERROR: 'unknown opcode' operator is not defined on types integer and integer. " 오류 메시지와 함께 질의 수행에 실패하는 현상을 수정했다.

    .. code-block:: sql

        SELECT * FROM tab WHERE NOT - col0 = - col0;  

    아울러 질의문에 단항 연산자 + 와 - 를 같이 사용하는 경우 발생하는 오류를 수정했다.

    .. code-block:: sql

        SELECT * FROM tab0 WHERE col0 IN (+ - col0);

ORDER BY 절을 포함한 뷰에 대해 특정 칼럼만 조회하는 SELECT 질의를 수행하면 서버 프로세스가 비정상 종료될 수 있는 현상(CUBRIDSUS-7140)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    .. code-block:: sql

        CREATE VIEW va AS SELECT code, name, gender, nation_code FROM athlete ORDER BY nation_code;
        SELECT code, name FROM va;

CHAR 타입 칼럼에 INT 타입을 바인딩하여 INSERT INTO ... SELECT ? ...질의 수행 시 오류(CUBRIDSUS-6563)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    INSERT INTO ... SELECT ? FROM db_root 질의 수행 시 CHAR 타입 칼럼에 INT 타입을 바인딩하면 " ERROR: A domain conflict exists on attribute *noname* " 오류 메시지와 함께 질의 수행에 실패하는 현상을 수정했다.

    .. code-block:: sql

        CREATE TABLE t (a CHAR (1));
        PREPARE s FROM 'INSERT INTO t SELECT ? FROM db_root';
        EXECUTE s USING 1;

IN 또는 EXISTS 표현식의 한 쪽 조건이 조건식으로 된 SELECT 리스트를 가진 부질의인 경우 서버 프로세스가 비정상 종료되는 문제(CUBRIDSUS-6482)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
    IN 또는 EXISTS 표현식의 조건이 단순 비교, ALL, BETWEEN, LIKE, ISNULL 등 조건식으로 된 SELECT 리스트인 경우 서버 프로세스가 비정상 종료되는 문제를 수정했다.

    .. code-block:: sql

        SELECT * FROM t1 WHERE v IN (SELECT (1 = 1));
        SELECT * FROM t1 WHERE v IN (SELECT ('aaa' LIKE 'bbb'));
        SELECT * FROM t1 WHERE EXISTS (SELECT (1 < ALL{1,3,4} ));

스키마 변경 이전으로 부분 롤백 수행 이후 USING INDEX 절을 포함한 질의 수행 시 오류(CUBRIDSUS-6458)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    스키마를 변경하기 전으로 부분 롤백(partial rollback)을 수행한 이후 USING INDEX 절을 포함한 질의를 수행하면 " ERROR: Execute: Query execution failure #10842. " 오류 메시지와 함께 질의 수행에 실패하는 문제를 수정했다.

    .. code-block:: sql

        -- ;autocommit off
        
        CREATE TABLE t (id INTEGER, textlabel VARCHAR(255), description VARCHAR(4096));
        CREATE INDEX i_t_id_text ON t (id, textlabel);
        COMMIT;
        
        SAVEPOINT sp4;
        
        TRUNCATE t;
        
        SELECT * FROM t WHERE id > -1 USING INDEX i_t_id_text(+);
        
        ROLLBACK TO SAVEPOINT sp4;
        
        SELECT * FROM t WHERE id > -1 USING INDEX i_t_id_text(+);

CASE 연산식에 정의되지 않은 칼럼을 사용하거나 서버 프로세스 종료 후 LAST_INSERT_ID() 호출 시 CSQL, CAS가 비정상 종료되는 현상(CUBRIDSUS-5759)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    CASE 연산식에 정의되지 않은 칼럼이 있는 경우 CSQL, CAS가 비정상 종료되는 현상을 수정했다.  

    .. code-block:: sql

        -- 아래 구문에서 a는 정의되지 않은 칼럼이다.
        UPDATE tbl SET col1 = (CASE WHEN EXISTS (SELECT * FROM tbl2 WHERE LENGTH (a) > 0)
                        THEN (SELECT col2 FROM tbl2 WHERE colx = '1')
                        ELSE (SELECT col1 FROM tbl2 WHERE colx = '1') END)

    아울러 서버 프로세스 종료 후 LAST_INSERT_ID() 호출 시 CSQL, CAS가 비정상 종료될 수 있는 문제를 수정했다.

중첩 깊이가 128을 초과하는 부질의를 수행하면 응용 프로그램이 비정상 종료되는 현상(CUBRIDSUS-7826) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    중첩 깊이가 128을 초과하는 부질의(subquery)를 수행하면 응용 프로그램이 비정상 종료되는 현상을 수정했다.

    .. code-block:: sql

        SELECT * FROM (SELECT * FROM (... (SELECT 1)...)...);

DESCRIBE 문 수행 시 STRING 타입에 대해 길이를 잘못 출력하는 오류(CUBRIDSUS-6432)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    테이블 정보를 출력하는 DESCRIBE 문을 수행하면 STRING 타입의 길이를 -1로 잘못 출력했으나 이를 출력하지 않도록 수정했다.

    참고로, STRING(n)으로 출력되는 것은 VARCHAR(n) 타입을 의미한다.

    .. code-block:: sql
    
        DESCRIBE test_tbl;

    ::
    
        Field        Type            Null Key     Default     Extra
        ================================================================
        's_name'     'CHAR(1)'         'YES' '        ' NULL         ''
        'f_name'     'STRING(30)'     'YES' '        ' NULL         ''
        'name'         'STRING'         'YES' '        ' NULL         ''

DECIMAL(p, s) 타입에서 허용 범위를 벗어나는 p와 s의 입력이 가능한 문제(CUBRIDSUS-6505)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    DECIMAL(p, s) 타입의 정밀도 p와 스케일 s를 벗어나는 값의 입력이 허용되는 오류를 수정했다.

    .. code-block:: sql

        CREATE TABLE t1 (col1 DECIMAL (5, 2));

        -- 수정 이전 버전에서는 아래의 질의 수행에 성공하여 1000.00이라는 값이 저장되는 오류가 존재했다.
        INSERT INTO t1 VALUES (999.999);

테이블 생성 시 DEFAULT 표현식에 대한 문법 검사 없이 수행되는 문제(CUBRIDSUS-6761)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    테이블 생성 시 DEFAULT 표현식에 대한 문법 검사가 되도록 수정했다. 아래의 예에서 수정 이전에는 SYSTIMESTAMP 뒤의 - 9999의 입력을 무시하고 테이블이 생성되는 현상이 발생했으나, 수정 이후에는 문법에 맞지 않기 때문에 오류를 출력한다.

    .. code-block:: sql

        CREATE TABLE foo (a TIMESTAMP DEFAULT SYSTIMESTAMP - 9999);
        
    ::
    
        Error: Invalid DEFAULT clause. 'sys_timestamp ' cannot be used in a nested expression.

호스트 변수들 간의 곱셈/나눗셈 연산 수행 시 바인딩되는 문자열이 숫자 타입으로 자동 형 변환이 되지 않는 오류(CUBRIDSUS-5506)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    호스트 변수들 간의 곱셈/나눗셈 연산 수행 시 바인딩되는 문자열이 숫자 타입으로 자동 형 변환이 되지 않는 오류를 수정했다.

    .. code-block:: sql

        CREATE TABLE t1 (i1 INTEGER);
        PREPARE st FROM 'INSERT INTO t1(i1) VALUES (? * ?)'
        EXECUTE st USING '4', '2.2';

UNIQUE 키 위반으로 INSERT 문 수행이 실패한 이후 LAST_INSERT_ID 함수의 값이 잘못 출력될 수 있는 현상(CUBRIDSUS-6450)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    UNIQUE 키 위반으로 INSERT 문 수행이 실패한 이후 LAST_INSERT_ID 함수의 결과 값이 잘못 출력될 수 있는 현상을 수정했다.

    .. code-block:: sql

        CREATE TABLE t1 (k int(11) PRIMARY KEY AUTO_INCREMENT, a INT(11) DEFAULT NULL UNIQUE);
        INSERT INTO t1 (a) VALUES (1);
        INSERT INTO t1 (a) VALUES (2);

        --below sql will fail because of unique constrain in a column.
        INSERT INTO t1 (a) VALUES (1);

        --below should return an old value(2) because of failed insert operation.
        SELECT LAST_INSERT_ID ();

유효하지 않은 ALTER COLUMN 문 수행 시 오류를 출력하지 않는 문제(CUBRIDSUS-6759)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    유효하지 않은 ALTER COLUMN ... SET DEFAULT 문 수행 시 오류를 출력하지 않는 문제를 수정했다. 다음 예에서 칼럼 a는 TIMESTAMP 이므로 DEFAULT 값으로 'aaa'와 같은 문자열을 사용할 수 없다. 

    .. code-block:: sql

        CREATE TABLE foo (a TIMESTAMP);
        ALTER TABLE foo ALTER COLUMN a SET DEFAULT 'aaa';

BIT 타입 칼럼에 setBytes() 메서드로 값을 설정하여 INSERT하면 잘못된 값이 저장되는 문제(CUBRIDSUS-6628)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    JDBC 응용 프로그램에서 BIT 타입 칼럼에 setBytes() 메서드로 호스트 변수의 값을 설정하여 INSERT하면 잘못된 값이 저장되는 현상을 수정했다.

INSERT ON DUPLICATE KEY UPDATE 문 수행 시 기본 키에 NULL 값이 입력될 수 있는 문제(CUBRIDSUS-6448)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    아래의 예와 같이 INSERT ON DUPLICATE KEY UPDATE 문을 수행하면 기본 키에 NULL 값이 입력되는 문제를 수정했다.

    .. code-block:: sql

        CREATE TABLE t1(id int AUTO_INCREMENT NOT NULL, c CHAR(1) NOT NULL, counter INT NOT NULL DEFAULT 1, PRIMARY KEY(id), UNIQUE KEY(c));
        INSERT INTO t1 (id, c) VALUES (NULL, 'a'), (NULL, 'a') 
        ON DUPLICATE KEY UPDATE id = NULL, counter = counter + 1;

INSERT ... SELECT 구문 수행 시 UNIQUE 칼럼의 값이 NULL로 들어갈 경우 COUNT(*) 질의의 결과가 잘못 출력되는 현상(CUBRIDSUS-8338)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    INSERT ... SELECT 구문 수행 시 UNIQUE 칼럼의 값으로 NULL이 입력되는 경우 COUNT(*) 질의의 결과가 잘못되는 현상을 수정했다. COUNT(칼럼 이름)과 같이 칼럼 이름을 명시하여 COUNT를 수행하는 경우에는 이전 버전에서도 정상 동작했다.

    .. code-block:: sql

        CREATE TABLE t1 (id INT AUTO_INCREMENT, mgrid INT UNIQUE, dummy INT);
        INSERT INTO t1 (dummy) VALUES (1);
        INSERT INTO t1 (dummy) SELECT dummy FROM t1;
        INSERT INTO t1 (dummy) SELECT dummy FROM t1;
        SELECT COUNT(*) FROM t1;
    
AUTO_INCREMENT 칼럼으로 리스트 분할된 테이블에 INSERT 수행 시 오류(CUBRIDSUS-6522)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    AUTO_INCREMENT 칼럼으로 리스트 분할된 테이블에 INSERT를 수행하면 " ERROR: Appropriate partition does not exist ." 오류 메시지와 함께 질의 수행에 실패하는 현상을 수정했다.

    .. code-block:: sql

        CREATE TABLE t1 (a INT AUTO_INCREMENT PRIMARY KEY)
        PARTITION BY LIST (a) (PARTITION p0 VALUES IN (1, 2));
        INSERT INTO t1 VALUES (NULL), (NULL);

한 칼럼에 대한 제약조건이 100개 이상인 테이블에 INSERT 혹은 UPDATE 수행 시 서버 프로세스가 비정상 종료되는 현상(CUBRIDSUS-6437)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    한 개의 칼럼에 대한 제약조건, 예를 들어 외래 키 제약 조건이 100개 이상인 테이블에 INSERT 혹은 UPDATE 수행 시 서버 프로세스가 비정상 종료되는 현상을 수정했다.

Windows 64 비트 환경에서 BLOB, CLOB 타입에 문자열 INSERT 시 오류(CUBRIDSUS-6111)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    Windows 64 비트 환경에서 BLOB, CLOB 타입에 문자열을 INSERT하면 " ERROR: Cannot coerce '123' to type clob. " 오류 메시지와 함께 질의 수행에 실패하는 현상을 수정했다.

    .. code-block:: sql

        CREATE TABLE alltypes (blob_col BLOB, clob_col CLOB);
        INSERT INTO alltypes VALUES ('123', '123')

REPLACE 문과 DELETE 문이 각각 다른 트랜잭션으로 수행될 때 데드락 현상이 발생할 수 있는 문제(CUBRIDSUS-5016)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    REPLACE 문과 DELETE 문이 각각 다른 트랜잭션으로 수행될 때 데드락 현상이 발생할 수 있는 문제를 수정했다.

    .. code-block:: sql

        CREATE TABLE t1 (a INT);
        CREATE UNIQUE INDEX i1 ON t1 (a);
        INSERT INTO t1 VALUES (1), (4), (7);
        
        -- set autocommit off
        
        -- T1
        REPLACE t1 (a) VALUES (6);
        
        -- T2
        REPLACE t1 (a) VALUES (7);
        
        -- T1
        DELETE FROM t1 WHERE a = 6;
        
        -- T2
        REPLACE t1 (a) VALUES (5);

REPLACE 문 사용 시 고유 키 위반 오류가 발생할 수 있는 문제(CUBRIDSUS-5786)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    REPLACE 문 사용 시 고유 키 위반(unique key violation) 오류가 발생할 수 있는 문제를 수정했다.

    .. code-block:: sql

        CREATE TABLE t1 (id1 VARCHAR(10) UNIQUE);
        INSERT INTO t1 VALUES ('a'), ('b'), ('f'), ('k');
        COMMIT;    
        
        -- T1
        DELETE FROM t1 WHERE id1 = 'f';
        INSERT INTO t1 VALUES ('g');
        
        -- T2
        INSERT INTO t1 VALUES ('f');
        COMMIT;
        
        -- T1
        ROLLBACK;
        
        -- T3
        REPLACE INTO t1 SET id1 = 'f';

DELETE 문에서 FROM 키워드의 생략이 가능해짐(CUBRIDSUS-6547)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    DELETE 문에서 FROM 절 이하의 테이블이 하나인 경우 키워드의 생략이 가능하도록 수정했다.

    .. code-block:: sql

        DELETE tbl;

하나의 테이블에 UPDATE를 수행하는 동안 다른 스레드가 SELECT를 수행하면 잘못된 결과를 출력하는 현상(CUBRIDSUS-8460)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    하나의 테이블에 UPDATE를 수행하는 동안 트랜잭션 격리 수준이 커밋되지 않은 읽기(uncommitted read)인 다른 스레드가 SELECT를 수행하면 잘못된 결과를 출력할 수 있는 문제를 수정했다.

UPDATE와 SELECT가 동시에 수행되는 상황에서 서버로그에 -46번 오류가 기록되는 현상(CUBRIDSUS-8347)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    동일한 테이블에 대해 격리 수준이 커밋되지 않은 읽기(uncommitted read)인 SELECT와 UPDATE가 함께 수행되는 상황에서 “ Internal error: slot 17 on page 166272 of volume xxx is not allocated. "라는 -46번 오류가 발생할 수 있는 문제가 존재했으나, 해당 오류가 발생하더라도 질의는 정상적으로 진행되므로 Error가 아닌 Warning(경고)을 출력하도록 수정했다.

INSERT 문을 반복 수행하는 도중에 다른 트랜잭션에 의한 테이블 잠금 발생 시에 트랜잭션 일관성이 보장되지 못하는 문제(CUBRIDSUS-8303)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    INSERT 문을 PREPARE한 후에 반복적으로 수행하는 트랜잭션이 첫번째 실행 이후 커밋한 후에 다른 트랜잭션이 해당 테이블에 X-lock을 설정한 후에 다시 INSERT를 수행하게 될 때, 해당 테이블에 대한 IX-lock의 부재로 인해 잠금 처리가 정확하게 되지 않아 결국 트랜잭션들의 일관성이 보장될 수 없는 문제를 수정했다.
    
    이 문제는 2008 R4.1 이상 버전에서 발생할 수 있다.

다른 트랜잭션에 의해 삭제된 테이블에 대한 SELECT 질의가 오류를 출력하지 않고 0건을 반환하는 문제(CUBRIDSUS-7389)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    다른 트랜잭션이 삭제한 테이블에 대해 SELECT 질의를 수행하면 해당 테이블을 찾을 수 없다는 오류를 출력해야 하지만 0건을 반환하는 문제를 수정했다.

클릭 카운터로 인해 교착 상태가 발생하면 서버 프로세스가 동작을 멈출(hang) 수 있는 문제(CUBRIDSUS-7378)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    클릭 카운터(click counter) 함수로 인해 교착 상태가 발생하면 가끔 서버 프로세스가 이를 감지하지 못하고 동작을 멈출 수 있는 문제를 수정했다. 클릭 카운터로 인해 교착 상태가 발생하면 클릭 카운터의 업데이트만 무시되고, 나머지 질의들은 정상적으로 진행되는 것이 일반적인 동작 방식이다.

두 개 이상의 트랜잭션이 동시에 일시적 임시 볼륨을 생성하거나 확장하려고 할 때 latch timeout 오류(CUBRIDSUS-6667)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    두 개 이상의 트랜잭션이 동시에 일시적 임시 볼륨(temporary temp volume)을 생성하거나 확장하려고 할 때 " LATCH ON PAGE(12345|0) TIMEDOUT " 오류 메시지와 함께 질의 수행에 실패하는 현상을 수정했다.

CREATE TABLE ... LIKE 문으로 REUSE_OID 테이블을 복사 생성하면 REUSE_OID 속성 복사가 누락되는 오류(CUBRIDSUS-7371)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    CREATE TABLE ... LIKE 문으로 REUSE_OID 테이블을 복사 생성할 때, 새로 생성된 테이블에 REUSE_OID 속성이 누락되는 오류를 수정했다.

    .. code-block:: sql

        CREATE TABLE src_tbl (i INT) REUSE_OID;
        CREATE TABLE dest_tbl LIKE src_tbl;

AUTO_INCREMENT 속성이 설정된 칼럼에 ALTER 문으로 DEFAULT 속성이 추가되는 문제 (CUBRIDSUS-6407)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    AUTO_INCREMENT 속성과 DEFAULT 속성이 같은 칼럼에 동시에 설정될 수 없음에도 불구하고 ALTER 문으로 DEFAULT 속성을 추가할 수 있었던 오류를 수정했다.

    .. code-block:: sql

        CREATE TABLE tbl (x INT SHARED 3);
        ALTER TABLE tbl ALTER COLUMN x SET DEFAULT 100;

    ::
    
        -- 수정한 버전에서는 다음의 오류를 출력한다.
        SHARED, DEFAULT and AUTO_INCREMENT cannot be defined with each other.
    
ALTER SERIAL문으로 시리얼의 캐시 옵션 설정을 변경하지 못하는 문제(CUBRIDSUS-7120)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    ALTER SERIAL 문으로 캐시 옵션을 활성화 또는 비활성화하지 못하는 문제를 수정했다.

    .. code-block:: sql

        CREATE SERIAL s2 START WITH 5 INCREMENT BY 6 CACHE 5;
        ALTER SERIAL s2 NOCACHE;

기본 키 칼럼에 DEFAULT NULL 제약조건 부여가 가능한 문제(CUBRIDSUS-7348)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    기본 키 칼럼에 DEFAULT NULL 제약조건을 부여하지 못하도록 수정했다.

    .. code-block:: sql

        -- 이전 버전에서는 아래 질의가 수행되는 문제가 존재한다.
        CREATE TABLE t (a INT PRIMARY KEY DEFAULT NULL);

상위 클래스와 서브 클래스에 둘 다 기본 키 선언이 가능한 문제(CUBRIDSUS-9207)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    상위 클래스에 기본 키가 있으면 서브 클래스는 이미 상위 클래스의 기본 키를 상속받으므로 기본 키를 선언할 수 없어야 하나, 이를 허용했던 문제를 수정했다.

    .. code-block:: sql

        CREATE TABLE student (std_id INT PRIMARY KEY);
        CREATE TABLE time_table AS SUBCLASS OF student (std_id INT PRIMARY KEY);
    
REUSE_OID 옵션으로 생성한 테이블을 DROP하는 경우 공간이 반환되지 않을 수 있는 현상(CUBRIDSUS-8140)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    REUSE_OID 옵션을 가지는 테이블을 DROP하는 도중 서버에서 내부적으로 오류가 발생하는 경우에 해당 공간이 반환되지 못하는 문제를 수정했다.

호스트 변수에 값을 바인딩할 때 두 번째 바인딩하는 값의 타입이 첫 번째와 다르면 오류가 발생하는 문제(CUBRIDSUS-7377)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    호스트 변수에 값을 바인딩할 때 두번째 바인딩하는 값의 타입이 첫번째와 다르면 첫 번째 타입으로 바인딩하려고 시도하면서 오류가 발생할 수 있는 문제를 수정했다. 예를 들어 'SELECT ?'에 처음에는 1을 바인딩하고, 이후에 'A'를 바인딩하면 'A'를 INTEGER 타입으로 바인딩하려고 시도하면서 오류가 발생했다.

호스트 변수를 포함한 뷰에 대한 질의 수행 시 서버 프로세스가 비정상 종료되는 현상(CUBRIDSUS-6767)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    호스트 변수를 포함한 뷰에 대한 질의 수행 시 서버 프로세스가 비정상 종료되는 현상을 수정했다. 호스트 변수를 포함한 DDL은 허용되지 않는다.

    .. code-block:: sql

        CREATE TABLE tree (node INT, parentnode INT, name VARCHAR (30));
        INSERT INTO TREE VALUES (1, NULL, '1'), (2, 1, '2'), (3, 1, '3'), (4, 2, '4');
        
        PREPARE stmt FROM 'CREATE VIEW v as SELECT parentnode,node,name FROM tree WHERE node < ? START
        WITH parentnode IS NULL CONNECT BY parentnode=PRIOR node ORDER BY node';
        
        EXECUTE stmt USING 3;
        
        SELECT * FROM v;

뷰 생성 시 DEFAULT 값이 뷰에 복사되지 않는 오류(CUBRIDSUS-6772)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    CREATE VIEW AS SELECT ... 문 수행 시 원본 테이블의 DEFAULT 값이 뷰에 복사되지 않는 오류를 수정했다.

    .. code-block:: sql

        CREATE TABLE foo (a INT DEFAULT 222);
        CREATE VIEW voo AS SELECT * FROM foo;
        INSERT INTO voo VALUES (DEFAULT);

뷰를 구성하는 질의에 FROM 절이 없는 경우 SELECT 질의 수행 시 오류 (CUBRIDSUS-6592)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    뷰를 구성하는 질의에 FROM 절이 없으면 SELECT 질의 수행 시 " ERROR: There are more attributes in class v1 than columns in the query specification. " 오류 메시지와 함께 질의 수행에 실패하는 현상을 수정했다.

    .. code-block:: sql

        CREATE VIEW v1 AS (SELECT 1 a) UNION (SELECT 1 a);
        SELECT * FROM v1;

뷰 생성 또는 뷰 변경 시 SELECT 리스트에 복잡한 수식이 나타나는 경우 질의 수행에 실패할 수 있는 문제(CUBRIDSUS-8970)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    뷰 생성 또는 뷰 변경 시 SELECT 리스트에 복잡한 수식이 나타나는 경우 질의 수행에 실패할 수 있는 문제를 수정했다. 다음 예처럼 SELECT 리스트 중 복잡한 수식에 대해 칼럼 별칭(alias)을 명시하지 않으면 "SQRT(CAST(100 as double))"이 칼럼 별칭이 되는데, 이와 같은 수식을 식별자로 허용하지 않으므로 식별자를 감싸는 부호(큰따옴표, 대괄호 혹은 백틱)가 필요하다. 수정 이후에는 질의 수행 시 내부적으로 식별자를 감싸는 부호를 추가하여 해당 현상이 발생하지 않는다.

    .. code-block:: sql

        CREATE VIEW vw AS SELECT SQRT (CAST(100 as double));
        -- 위의 질의를 수행하면 내부적으로 아래와 같이 수행된다.
        CREATE VIEW vw AS SELECT SQRT (CAST(100 as double)) AS [ SQRT(CAST(100 as double)) ];
    
    수정 이전 버전의 HA 환경에서는 마스터 노드에서 해당 현상이 발생하지 않게 질의문을 작성하더라도, 슬레이브 노드에서 함수 내의 인자 값을 CAST하도록 질의문이 재작성되면서 해당 현상이 발생했다.

    .. code-block:: sql

        -- 아래의 질의문을 수행하면 슬레이브 노드에서는 위 예제의 첫번째 질의 형태로 재작성된다.
        CREATE VIEW vw AS SELECT SQRT(100);

db_user, db_trigger 시스템 카탈로그 테이블의 레코드를 사용자가 임의로 변경하지 못하도록 수정(CUBRIDSUS-8690)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    사용자가 임의로 db_user, db_trigger 시스템 카탈로그 테이블의 레코드를 INSERT, UPDATE 또는 DELETE하지 못하도록 수정했다.

자신을 참조하는 외래 키가 있는 테이블에 값 입력 시 오류(CUBRIDSUS-6216)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    자신을 참조하는 외래 키가 있는 테이블에 값을 입력하면 " ERROR: The constraint of the foreign key 'fk_pkfk_b' is invalid. " 오류 메시지와 함께 질의 수행에 실패하는 문제를 수정했다.

칼럼의 DEFAULT 값 크기가 한 페이지보다 큰 테이블 생성 시도 시 서버 프로세스가 비정상 종료되는 현상(CUBRIDSUS-6510)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    칼럼의 DEFAULT 값 크기가 한 페이지보다 큰 테이블의 생성을 시도하면 서버 프로세스가 비정상 종료되는 현상을 수정했다.

사용자 이름의 길이가 32bytes를 초과하면 해당 사용자로 로그인할 수 없는 문제(CUBRIDSUS-6633)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    사용자 이름의 길이가 32bytes를 초과하면 이후 해당 사용자로 접속하지 못하는 문제가 발생했다. 수정된 버전에서는 DB 사용자 계정 생성 시 계정의 길이를 32bytes로 제한했다.

    .. code-block:: sql

        CREATE USER a12345678901234567890123456789012345678901234567890;

    ::
    
        $ csql -u a1234567890123456789012345678901234567890123456
        ERROR: User "a12345678901234567890123456789012345" is invalid.
    
CONNECT BY 절이 START WITH 절 뒤에 오는 것을 허용하게 됨(CUBRIDSUS-6548)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    계층 질의문에서 CONNECT BY 절이 START WITH 절 뒤에 오는 것을 허용하도록 수정했다.

    .. code-block:: sql

        SELECT * 
        FROM a 
        CONNECT BY PRIOR id = pid 
        START WITH id = 1;
    
ORDER SIBLINGS BY 절을 가진 계층 질의가 부질의로 사용되면 잘못된 질의 결과를 출력하는 문제(CUBRIDSUS-7748)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    ORDER SIBLINGS BY 절이 포함된 계층 질의가 부질의로 사용되면 질의 최적화기에서 질의가 잘못 재작성되어 질의 결과가 잘못되는 문제를 수정했다.

    .. code-block:: sql

        SELECT * FROM tbl
        WHERE id IN (SELECT id FROM tbl WHERE yn = 'Y'
            START WITH id = '100002'
            CONNECT BY NOCYCLE PRIOR id = pid
            ORDER SIBLINGS BY sort_col);
    
ROWNUM 조건이 있는 계층 질의에서 질의 결과의 개수가 틀린 현상(CUBRIDSUS-6365)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    ROWNUM 조건이 있는 계층 질의가 인덱스 스캔으로 처리될 때 질의 결과의 개수가 ROWNUM 조건에 의해 제한되지 못하는 현상을 수정했다.

    .. code-block:: sql

        SELECT oid FROM foo
        WHERE ROWNUM = 1
        START WITH oid = '1234567'
        CONNECT BY PRIOR poid = oid;

일시적 임시 볼륨을 사용하는 질의 수행 중 DB 서버 재시작 시 서버 프로세스가 비정상 종료될 수 있는 문제(CUBRIDSUS-5684)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    일시적 임시 볼륨을 사용하는 질의를 수행하는 도중에 데이터베이스를 재시작하면 서버 프로세스가 비정상 종료될 수 있는 문제를 수정했다.

자동 볼륨 증가 도중 실패한 경우 조치 후에도 질의 수행에 실패하는 문제(CUBRIDSUS-7216)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    자동 볼륨 증가 도중 서버 프로세스가 비정상 종료되어 자동 볼륨 증가에 실패한 중간 파일이 있으면 서버 재시작 등의 조치 후에도 질의 수행에 실패하는 문제를 수정했다.

트리거 수행에 실패하는 현상(CUBRIDSUS-7187)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    다음 예와 같이 트리거를 수행하는 경우 오류를 발생하거나 응용 프로그램이 비정상 종료되면서 수행에 실패하는 현상을 수정했다.

    Case 1) 이전 버전에서 다음과 같은 질의를 수행하면 오류가 발생했다.

    .. code-block:: sql

        CREATE TABLE t1 (a INT);
        INSERT INTO t1 VALUES (1), (2), (3), (4);
        
        CREATE TRIGGER TRIGG1 BEFORE UPDATE ON t1 EXECUTE DELETE FROM t1;
        
        UPDATE t1 SET a = 6;
        
    ::
    
        ERROR: Error evaluating action for "trigg1", Accessing deleted object 0|1100|16.

    Case 2) 이전 버전에서 다음과 같은 질의를 수행하면 응용 프로그램이 비정상 종료되었다.

    .. code-block:: sql

        CREATE TABLE t1 (a INT, b INT);
        INSERT INTO t1 VALUES (2, 2), (3, 3);
        
        CREATE VIEW v1 AS SELECT * FROM t1;
        
        CREATE TRIGGER tri_t1_before_update1 BEFORE UPDATE ON t1 EXECUTE DELETE FROM v1;
        CREATE TRIGGER tri_t2_before_update2 BEFORE UPDATE ON t1 EXECUTE DELETE FROM t1;
        
        --Test: crash happens.
        UPDATE t1 SET t1.a = 10;

다른 사용자가 생성한 테이블에 트리거가 있으면 해당 테이블에 대한 질의 오류가 무시되는 현상(CUBRIDSUS-7336)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    다른 사용자가 생성한 테이블에 트리거가 있는 경우 해당 테이블에 대한 질의 수행에 실패해도 오류가 발생하지 않고, 이후 트랜잭션이 종료될 때 " ERROR: Internal system failure: no more specific information is available. " 오류가 발생하는 문제를 수정했다.

트리거에 의한 UPDATE/INSERT 질의가 실패했음에도 불구하고 트리거를 유발한 질의가 롤백되지 않는 문제(CUBRIDSUS-7239)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    자동 커밋 모드가 OFF일 때 트리거에 의한 UPDATE/INSERT 질의가 실패했음에도 불구하고, 트리거를 유발한 질의가 롤백되지 않는 문제를 수정했다. 아래 예에서, Q6을 수행하면 t2 테이블의 trig1 트리거가 발동하는데, 이때 t1 테이블에 int 타입의 값을 입력할 수 없으므로 에러가 발생하고 이 트리거를 유발한 Q6은 롤백된 상태여야 한다. 즉, Q7 수행 이후에 t1 테이블의 레코드 건수는 1건, t2 테이블의 레코드 건수는 0건이어야 한다. 이전 버전에서는 에러가 발생하면 trig1 트리거를 유발한 Q6 질의가 롤백되지 않는 문제가 존재했다.

    .. code-block:: sql

        -- ;autocommit off
        
        CREATE TABLE t1 (col1 DATE); -- Q1
        CREATE TABLE t2 (col2 INT); --Q2
        CREATE TRIGGER trig1 AFTER INSERT ON t2 EXECUTE INSERT INTO t1 (col1) VALUES (obj.col2); --Q3
        COMMIT; -- Q4
        
        INSERT INTO t1 (col1) VALUES ('2012-04-30'); -- Q5
        INSERT INTO t2 (col2) VALUES (1); -- Q6
        
        ERROR: Error evaluating action for "trig1", Execute: Cannot coerce obj.cold2 to type date.
        
        COMMIT; -- Q7
    
트리거 내에서 CLOB_TO_CHAR()를 호출하면 NULL을 반환하는 오류 (CUBRIDSUS-7246)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    트리거 내에서 CLOB_TO_CHAR()를 호출하면 NULL을 반환하는 오류를 수정했다.

질의 계획 및 최적화
-------------------


질의 계획 캐시에 설정한 제한 개수보다 많은 질의 계획이 저장되는 문제(CUBRIDSUS-8619)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    시스템 파라미터 max_plan_cache_entries를 통해 질의 계획 캐시에 설정한 제한 개수보다 많은 계획이 저장되는 문제를 수정했다. 이 문제로 인해 서버의 메모리 및 임시 볼륨 사용량이 꾸준히 증가하는 현상이 있었다.

질의 최적화 과정에서 ORDER BY 절이 제거될 때 질의문에 ORDERBY_NUM()이 있으면 질의 결과가 0건인 문제(CUBRIDSUS-6060)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    질의 최적화 과정에서 불필요한 ORDER BY 절을 제거할 때 orderby_num()은 그대로 남아있어 값이 항상 0으로 출력되는 오류를 수정했다.

    .. code-block:: sql

        SELECT ORDERBY_NUM(), history.*
        FROM history
        WHERE host_year = '2004'
        ORDER BY host_year FOR ORDERBY_NUM() BETWEEN 1 AND 10;
    
질의 계획 캐시를 사용 안 하도록 설정하고 PREPARE 문 수행 시 응용 프로그램이 비정상 종료되는 현상(CUBRIDSUS-8094)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    시스템 파라미터 max_plan_cache_entries의 값을-1로 설정하여 질의 계획 캐시(plan cache)를 사용 안 하는 경우에 PREPARE 문을 수행하면 응용 프로그램이 비정상 종료되는 현상을 수정했다.

    .. code-block:: sql

        CREATE TABLE t (a INT);
        INSERT INTO t VALUES (1), (2), (3);
        PREPARE STMT FROM 'SELECT COUNT(?) FROM t';
        EXECUTE STMT USING 1;
    
질의 계획 정보 출력 이후 질의 수행 시 잘못된 결과를 출력할 수 있는 문제(CUBRIDSUS-7818)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    ;plan simple 명령어를 실행하여 질의 계획을 출력하면 입력 값에 대응되는 칼럼의 타입으로 입력 값이 변환되어 잘못된 결과를 출력할 수 있는 문제를 수정했다.
    아래의 예제에서 수정 이전 버전에서는 질의 계획을 출력하면서 2.3이라는 입력 값이 2로 변환되어 서버에 전달되어 결국 2가 결과에 포함되지 못하는 문제가 있었다.

    .. code-block:: sql

        CREATE TABLE foo (col INT);
        INSERT INTO foo VALUES (1), (2);
        
        ;plan simple
        
        SELECT * FROM foo WHERE col < 2.3;
    
질의 계획 캐시를 사용하지 않는 질의에서 테이블 이름을 변경한 후 질의 수행 시 이전 테이블에 대해서 질의가 수행되는 문제(CUBRIDSUS-7637)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    테이블 이름을 변경한 후 질의 수행 시 해당 이름을 가지는 새 테이블이 아니라 이름이 변경된 이전 테이블에 대해 질의가 수행되는 문제를 수정했다. 이전 버전에서 INSERT 문은 질의 계획 캐시를 사용하지 않으므로 항상 문제가 발생했으며, 나머지 질의의 경우 시스템 파라미터 max_plan_cache_entries의 값을 -1로 설정하여 질의 계획 캐시 기능을 끄는 경우 문제가 발생했다.

    .. code-block:: sql

        -- insert의 예
        INSERT INTO tbl VALUES (...);
        RENAME TABLE tbl AS tbl_old;
        RENAME TABLE tbl2 AS tbl;
        
        -- 아래 질의 수행 시 tbl_old에 값이 INSERT됨.
        INSERT INTO tbl VALUES (...);
    
특정 OUTER JOIN 질의에 대해서 커버링 인덱스 스캔 질의 실행 시에 발생할 수 있는 오류(CUBRIDSUS-7868)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    OUTER JOIN 조건을 포함한 특정 질의에 대해서 커버링 인덱스 스캔 질의 실행 계획이 잘못되어 실행 과정에서 " Query execution failure #10946. " 오류가 발생하는 문제를 수정했다.

    .. code-block:: sql

        SELECT foo.obj_id, foo.h_id
        FROM foo
        INNER JOIN table_j ON foo.host_id = table_j.host_id
        LEFT OUTER JOIN table_d ON foo.s_id = table_d.svc_no
        LEFT OUTER JOIN table_g ON foo.g_id = table_g.svr_grp_no
        WHERE table_d.svc_no = foo.s_id
        AND foo.s_id = '2152';
    
IN 절에 호스트 변수가 있으면 질의 실행 계획이 출력되지 않는 오류(CUBRIDSUS-6382)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    IN 절이 (?, ?, ...) 형태의 호스트 변수를 포함하면 질의 실행 계획이 출력되지 않는 오류를 수정했다.

    .. code-block:: sql

        ;plan detail
        
        SELECT * FROM tbl WHERE id IN (?, ?, ?);
    
AND와 OR 조건이 여러 개 결합된 질의 수행 시 조건 일부가 누락된 결과를 출력할 수 있는 문제(CUBRIDSUS-9193)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    AND와 OR 조건이 여러 개 결합된 질의 수행 시 질의 계획 버그로 인해 조건 일부가 누락된 결과를 출력할 수 있는 문제를 수정했다.

    .. code-block:: sql

        SELECT *
        FROM it, p
        WHERE
        (
          p_pkey = l_pkey
          AND p_br = 'Br12'
          AND p_ct IN ('CS', 'BX', 'PK', 'PG')
          AND l_qty >= 1 AND l_qty <= 1 + 10
          AND p_sz BETWEEN 1 AND 5
          AND l_sm IN ('A', 'RG')
          AND l_st = 'DIP'
        )
        OR
        (
          p_pkey = l_pkey
          AND p_br = 'Br12'
          AND p_ct IN ('MG', 'MB', 'MPK', 'MPC')
          AND l_qty >= 10 AND l_qty <= 10 + 10
          AND p_sz between 1 AND 10
          AND l_sm IN ('A', 'RG')
          AND l_st = 'DIP'
        )
        OR
        (
          p_pkey = l_pkey
          AND p_br = 'Br12'
          AND p_ct IN ('LG', 'LB', 'LPK', 'LPC')
          AND l_qty >= 20 AND l_qty <= 20 + 10
          AND p_sz BETWEEN 1 AND 15
          AND l_sm IN ('A', 'RG')
          AND l_st = 'DIP'
        );
    
AUTO_INCREMENT가 포함된 칼럼 또는 테이블이 삭제될 때 관련 질의문이 질의 계획 캐시에서 삭제되지 않는 문제(CUBRIDSUS-7872)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    AUTO_INCREMENT가 포함된 칼럼 또는 테이블이 삭제될 때 관련 질의문이 질의 계획 캐시에서 삭제되지 않아 이후 AUTO_INCREMENT와 같은 이름으로 시리얼을 생성하여 해당 시리얼로 질의를 수행하면 " ERROR: Cannot fetch serial object. " 오류 메시지와 함께 수행에 실패하는 현상을 수정했다.

    .. code-block:: sql

        CREATE TABLE tbl (a INT AUTO_INCREMENT); 
        SELECT tbl_ai_a.NEXT_VALUE; 
        DROP TABLE tbl; 
        
        CREATE SERIAL tbl_ai_a; 
        SELECT tbl_ai_a.NEXT_VALUE;

질의 수행 없이 계획만 생성하도록 최적화 수준을 설정하고 REPLACE 문 수행 시 응용 프로그램이 비정상 종료되는 현상(CUBRIDSUS-6614)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    OPTIMIZATION LEVEL을 질의 수행 없이 계획만 생성하도록 2, 258 혹은 514 중 하나로 설정하고 REPLACE 문을 수행하면 응용 프로그램이 비정상 종료되는 현상을 수정했다.

    .. code-block:: sql

        SET OPTIMIZATION LEVEL 2;
        DROP TABLE t;
        
        CREATE TABLE t (col1 INTEGER UNIQUE, col2 VARCHAR(128));
        INSERT INTO t (col1, col2) VALUES (17, 'operators list');
        REPLACE t (col1, col2) VALUES (17, 'personnel list');

뷰 재생성 이후 해당 뷰의 UPDATE 수행에 실패하는 현상(CUBRIDSUS-6942)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    뷰를 재생성한 이후 UPDATE할 때 이전과 같은 UPDATE 문을 수행했을 경우, 이전 질의 계획을 사용하여 DROP했던 뷰를 참조하면서 UPDATE에 실패하는 현상을 수정했다.

    .. code-block:: sql

        CREATE TABLE foo (a INT);
        INSERT INTO foo VALUES (3);
        
        CREATE VIEW v AS SELECT * FROM foo WHERE a < 2;
        UPDATE v SET a = 3;
        
        DROP VIEW v;
        CREATE v AS * FROM foo WHERE a < 2;
        UPDATE v SET a = 3;

ORDER BY 최적화나 GROUP BY 최적화가 가능한 질의 계획들 중 최선을 선택하도록 수정(CUBRIDSUS-6957)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    ORDER BY 최적화(skip ORDER BY) 또는 GROUP BY 최적화(skip GRUOP BY)가 가능한 질의 계획들 중에서 더 나은 계획이 있음에도 불구하고 전체 인덱스 스캔(full index scan)을 선택하는 문제를 개선했다.

LIMIT 0인 경우 곧바로 결과를 반환하도록 수정(CUBRIDSUS-7420)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    LIMIT 0인 경우 질의 수행 없이 곧바로 결과를 반환하도록 수정했다. 이전 버전에서는 질의를 수행한 후에 LIMIT 절을 평가하므로 경우에 따라서 질의 처리에 많은 시간이 소요되었다.

    .. code-block:: sql

        SELECT CAST (dt_col AS DATE)
        FROM article
        WHERE id = '001' AND dt_col < TO_DATE ('20120201', 'YYYYMMDD')
        ORDER BY CAST (dt_col AS DATE) DESC
        LIMIT 0;

분할
----


분할 테이블에 로컬 인덱스 사용할 수 있도록 개선(CUBRIDSUS-7629)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    시스템 내부적으로 정의된 조건에 따라 분할 테이블의 각 분할마다 독립적으로 인덱스를 구성하는 로컬 인덱스를 생성할 수 있도록 수정했다. 모든 외래 키와 모든 비고유 인덱스는 로컬 인덱스이며, 고유 인덱스는 분할 키가 고유 인덱스에 속하는 경우에만 로컬 인덱스이다. 이전 버전에서는 기본 키를 비롯한 고유 인덱스는 모두 글로벌 인덱스로만 관리되었지만, 9.0 Beta부터는 분할 키가 포함되면 로컬 인덱스로 관리된다. 로컬 인덱스를 이용하면 글로벌 인덱스를 이용하는 경우보다 성능이 향상된다.

분할 테이블의 INSERT 성능 저하 개선(CUBRIDSUS-6018)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    분할 테이블에 INSERT를 수행하면 성능이 저하되었던 문제를 개선했다.

분할 테이블에 TRUNCATE 문의 수행을 허용하도록 개선(CUBRIDSUS-6871)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    분할 테이블에 TRUNCATE 문의 수행을 허용하도록 개선했다.

자동 커밋 모드가 OFF이면 영역 분할 테이블의 SELECT 결과가 잘못 출력되는 오류(CUBRIDSUS-7127)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    자동 커밋 모드가 OFF일 때, 영역 분할 테이블에 INSERT 하는 도중에 SELECT하고 추가로 INSERT한 후 다시 SELECT하면, 추가로 INSERT했던 레코드가 출력되지 않는 현상을 수정했다.

    .. code-block:: sql

        ;autocommit off
        CREATE TABLE foo (id1 BIGINT) PARTITION BY RANGE (id1) (
            PARTITION p1 VALUES LESS THAN (3),
            PARTITION p2 VALUES LESS THAN (5),
            PARTITION p3 VALUES LESS THAN (8)
        );
        INSERT INTO foo VALUES (1);
        
        -- 수정 이전 버전에서는 Q1 질의 수행 후 Q2 질의를 수행하면 Q1 수행 이전에 INSERT한 1건의 레코드만 출력되는 현상이 나타났다.
        SELECT * FROM foo; -- Q1
        INSERT INTO foo VALUES (1);
        INSERT INTO foo VALUES (1);
        SELECT * FROM foo; -- Q2

영역 분할 테이블에서 SELECT 수행 시 IS NULL OR IS NOT NULL 조건이 존재하면 잘못된 결과를 출력하는 문제(CUBRIDSUS-4575)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    영역 분할 테이블에서 SELECT 수행 시 IS NULL OR IS NOT NULL 조건이 존재하면 잘못된 결과를 출력하는 문제를 수정했다.

    .. code-block:: sql

        SELECT * FROM tbl
        WHERE a IS NULL OR a IS NOT NULL;

분할 테이블에서 OUTER JOIN 수행 시 잘못된 질의 결과를 출력하는 현상(CUBRIDSUS-6888)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    분할 테이블에서 OUTER JOIN 수행 시 잘못된 질의 결과를 출력하는 현상을 수정했다.

    .. code-block:: sql
    
        CREATE TABLE pt1 (i INT, j INT) PARTITION BY HASH (i) PARTITIONS 4;
        CREATE TABLE pt2 (i INT, j INT) PARTITION BY HASH (i) PARTITIONS 4;
        INSERT INTO pt1 VALUES (1, 1), (2, 2), (3, 3);
        INSERT INTO pt2 VALUES (1, 1);
        CREATE INDEX idx ON pt2 (i);

        -- 아래 질의 수행 시 수정 이전 버전에서는 첫번째 레코드가 "1, 1, NULL, NULL"로 잘못 출력되었다.
        SELECT * FROM pt1 LEFT JOIN pt2 ON pt1.i = pt2.i USING INDEX idx(+);
        
    ::
    
        i j i    j
        =============
        1 1 1    1
        2 2 NULL NULL
        3 3 NULL NULL
    
분할 테이블에서 외래 키 생성 시 제약 조건을 검사하지 않는 문제(CUBRIDSUS-6916)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    분할 테이블에서 외래 키 생성 시 제약 조건을 검사하지 않는 문제를 수정했다.

    .. code-block:: sql

        CREATE TABLE t1 (i INT PRIMARY KEY);
        INSERT INTO t1 VALUES(1);

        CREATE TABLE t2 (i INT, j INT) PARTITION BY HASH (i) PARTITIONS 4;
        INSERT INTO t2 VALUES (2,2);
        
        ALTER TABLE t2 ADD CONSTRAINT FOREIGN KEY t2 (i) REFERENCES t1 (i);
    
AUTO_INCREMENT 칼럼을 분할 키로 하여 해시 분할한 테이블에 데이터 입력 시 하나의 분할 테이블에만 입력되는 문제(CUBRIDSUS-5622)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    AUTO_INCREMENT 칼럼을 분할 키로 하여 해시 분할한 테이블에 데이터를 입력하면 하나의 분할 테이블에만 입력되는 문제를 수정했다.

    .. code-block:: sql

        CREATE TABLE t (i INT AUTO_INCREMENT) 
        PARTITION BY HASH (i) PARTITIONS 3;
        
        INSERT INTO t (i) 
        VALUES (NULL), (NULL), (NULL), (NULL), (NULL), (NULL), (NULL), (NULL);

리스트 분할 테이블에서 분할 키 값을 함수로 입력하면 분할 프루닝이 동작하지 않는 문제(CUBRIDSUS-5777)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    리스트 분할 테이블에서 분할 키 값을 함수로 입력하면 질의 결과에 포함되지 않는 분할을 검색 조건에서 제외시켜주는 분할 프루닝(partition pruning)이 동작하지 않는 문제를 수정했다.

하위 테이블에서 분할 테이블을 생성하는 문제(CUBRIDSUS-8703)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    하위 테이블(child table)의 분할 키로 사용한 칼럼이 상위 테이블(parent table)에 있음에도 불구하고 상위 테이블의 삭제가 가능한 문제가 존재했으나, 이러한 오류를 근본적으로 방지하기 위해 하위 테이블에서 분할 테이블을 생성할 수 없도록 수정했다.

CLOB 칼럼을 가지는 분할 테이블에 대해서 생성된 뷰로 레코드를 삭제하지 못하는 현상(CUBRIDSUS-8216)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    CLOB 칼럼이 있는 분할 테이블에 대해서 생성된 뷰로 레코드를 삭제하는데 오류가 발생하는 현상을 수정했다.

    .. code-block:: sql

        CREATE TABLE t (i INT, c CLOB) PARTITION BY HASH (i) PARTITIONS 4;
        INSERT INTO t SELECT ROWNUM, '1' FROM db_class LIMIT 40;
        CREATE VIEW v AS SELECT * FROM t;
        
        -- 수정 이전 버전에서 다음 질의를 수행하면 "ERROR: Semantic: ..." 오류가 발생한다.
        DELETE FROM v;
        CREATE TABLE t (i INT, c VARCHAR (10)) ;
        CREATE VIEW v AS SELECT * FROM t;

HA 환경에서 분할 테이블 생성 시 슬레이브 노드에 반영되지 않는 현상(CUBRIDSUS-7724)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    HA 환경에서 분할 테이블을 생성할 때 분할 테이블 생성문이 슬레이브 노드에 반영되지 않는 현상을 수정했다.

    .. code-block:: sql

        CREATE TABLE t1 (a int PRIMARY KEY)
        PARTITION BY HASH (a) PARTITIONS 2;

분할 테이블에서 INSERT한 레코드가 트리거의 UPDATE문으로 다른 파티션으로 이동해야 할 때 발생하는 오류(CUBRIDSUS-7520)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    분할 테이블에서 INSERT한 레코드가 트리거의 UPDATE문으로 인해 INSERT한 분할(partition)과 다른 곳으로 이동하지 못하면서 " ERROR: Error evaluating action for "tr2", Not allowed access to partition. " 오류가 발생하는 현상을 수정했다.

    .. code-block:: sql

        CREATE TABLE emp (store_id INT NOT NULL)
        PARTITION BY RANGE (store_id) (
            PARTITION P1 VALUES LESS THAN (10),
            PARTITION P2 VALUES LESS THAN (20)
        );
        
        CREATE TRIGGER tr2 AFTER INSERT ON emp 
        EXECUTE UPDATE emp SET store_id = store_id + 10 WHERE store_id = obj.store_id;
        INSERT INTO emp VALUES (5);
    
인덱스가 있는 분할 테이블을 생성, 롤백한 이후 재생성을 시도하면 실패하는 현상(CUBRIDSUS-7560)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    인덱스가 있는 분할 테이블을 생성하고 롤백한 이후 같은 분할 테이블을 재생성하려고 시도하면 " ERROR: Partition failed. " 오류를 출력하면서 실패하는 현상을 수정했다.

    .. code-block:: sql

        CREATE TABLE tbl (col1 VARCHAR (10), INDEX (col1))
        PARTYTION BY LIST (col1) (
            PARTITION p1 VALUES IN ('cubrid', 'database', 'DBMS')
        );

분할 테이블의 데이터 파일을 가지고 loaddb 수행 시 발생하는 오류(CUBRIDSUS-5815)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    분할 테이블을 포함하는 데이터 파일을 가지고 loaddb 수행 시 분할 테이블 위치에 데이터가 존재하면 " Partitioned failed " 오류 메시지와 함께 수행에 실패하는 현상을 수정했다.

    .. code-block:: sql

        -- 분할 테이블
        CREATE TABLE record (
          host_year INTEGER NOT NULL,
          event_code INTEGER NOT NULL,
          score VARCHAR(20)
        )
        PARTITION BY RANGE (host_year) (
          PARTITION before_1996 VALUES LESS THAN (1996),
          PARTITION after_1996 VALUES LESS THAN MAXVALUE
        );
        
    ::
    
        -- loaddb 용 데이터 파일. class [record] 이하에 데이터가 존재할 수 있도록 수정되었다.
        %class [record] ([host_year] [event_code] [score])
        1992 20288 '22.3'
        2000 20101 '04:04.5'
        2004 20341 '272.5'

영역 분할 재정의 수행 시 기존 분할에 LESS THAN MAXVALUE 조건이 있으면 재정의에 실패하는 오류(CUBRIDSUS-6379)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    영역 분할 재정의 수행 시 기존 분할에 LESS THAN MAXVALUE 조건이 있으면 재정의에 실패하는 문제를 수정했다.

    .. code-block:: sql

        CREATE TABLE t1(id int) PARTITION BY RANGE (id) (
          PARTITION l10 VALUES LESS THAN (10),
          PARTITION l100 VALUES LESS THAN (100),
          PARTITION lar VALUES LESS THAN MAXVALUE
        );
        
        ALTER TABLE t1 REORGANIZE PARTITION l100, lar
        INTO (PARTITION lar VALUES LESS THAN MAXVALUE);

리스트 분할 테이블에서 IN 조건절에 대해 분할 프루닝 오류(CUBRIDSUS-9189)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    리스트 분할 테이블에서 IN 조건절에 2개 이상의 분할이 포함되면 분할 프루닝 과정이 무한 반복될 수 있는 오류를 수정했다.

외래 키가 있는 분할 테이블에서 DELETE CASCADE가 동작하지 않는 현상(CUBRIDSUS-8085)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    DELETE CASCADE 동작을 지정한 외래 키가 있는 분할 테이블이 존재할 때, 기본 키가 있는 테이블의 레코드를 삭제하면 외래 키가 있는 분할 테이블 쪽에서 " ERROR: The instance having the foreign key 'f' cannot be dropped. " 오류가 발생하는 현상을 수정했다.

    .. code-block:: sql

        CREATE TABLE dp (i INT PRIMARY KEY);
        INSERT INTO dp SELECT ROWNUM FROM db_class LIMIT 40;
        
        CREATE TABLE f (i INTEGER, orderdatekey INTEGER NOT NULL) PARTITION BY RANGE (i) (
          PARTITION p0 VALUES LESS THAN (200), 
          PARTITION p1 VALUES LESS THAN (400),
          PARTITION p2 VALUES LESS THAN (600), 
          PARTITION p3 VALUES LESS THAN MAXVALUE
        );
        
        ALTER TABLE f ADD CONSTRAINT FOREIGN KEY f (i) REFERENCES dp (i) ON DELETE CASCADE;
        INSERT INTO f SELECT ROWNUM , ROWNUM FROM db_class LIMIT 40;
        
        -- record (4) should be deleted in both table dp and f;
        DELETE FROM dp WHERE i = 4;
    
AUTO_INCREMENT 칼럼으로 영역 분할된 테이블이 있는 데이터베이스를 백업한 이후 SELECT 수행 시 서버 프로세스가 비정상 종료되는 현상(CUBRIDSUS-6390)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    AUTO_INCREMENT 칼럼으로 영역 분할된 테이블이 있는 데이터베이스를 백업한 이후 SELECT를 수행하면 서버 프로세스가 비정상 종료되는 현상을 수정했다.

    .. code-block:: sql

        CREATE TABLE u1 (id INT AUTO_INCREMENT, v VARCHAR(5))
        PARTITION BY RANGE (id) (
          PARTITION l5 VALUES LESS THAN (5),
          PARTITION l10 VALUES LESS THAN (10),
          PARTITION l20 VALUES LESS THAN (20),
          PARTITION l100 VALUES LESS THAN (100)
        );
        
        INSERT INTO u1 VALUES (NULL, ''), (6, ''), (NULL, '');
    
    ::
    
        $ cubrid backupdb testdb
    
AUTO_INCREMENT 칼럼으로 영역 분할된 테이블에 질의 수행 시 서버 프로세스가 비정상 종료되는 문제(CUBRIDSUS-6373)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    AUTO_INCREMENT 칼럼으로 영역 분할된 테이블에 질의를 수행하면 서버 프로세스가 비정상 종료되는 문제를 수정했다.

    .. code-block:: sql

        CREATE TABLE u (id int AUTO_INCREMENT, v VARCHAR (5))
        PARTITION BY RANGE (id) (
          PARTITION l5 VALUES LESS THAN (5),
          PARTITION l10 VALUES LESS than (10),
          PARTITION l20 VALUES LESS than (20),
          PARTITION l100 VALUES LESS than (100)
        );
        
        INSERT INTO u VALUES (0,';jf;dfj iouer'), (5,' fdfd'), (10, 'dfd '), (15, 'fdf'), (20, 'a');

테이블의 분할에 대한 통계 정보가 업데이트되지 않아 인덱스 스캔이 되지 않는 현상 (CUBRIDSUS-7741)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    UPDATE STATISTICS 문으로 분할 테이블의 통계 정보 업데이트를 시도하면 테이블의 각 분할에 대한 통계 정보가 업데이트되지 않는 오류로 인해 검색 질의 수행 시 인덱스 스캔이 되지 않는 현상을 수정했다.

자동 커밋 모드가 OFF일 때 분할 테이블에서 값을 삭제한 이후 OID로 해당 레코드를 검색하면 값이 출력되는 현상(CUBRIDSUS-2183)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    자동 커밋 모드가 OFF일 때 분할 테이블에서 값을 삭제한 이후 OID(Object ID)로 해당 레코드를 검색하면 삭제 이전의 값이 출력되는 현상을 수정했다.

    .. code-block:: sql

        ;autocommit off
        
        CREATE TABLE tbl (id INT)
        PARTITION BY RANGE (id + 1) (
          PARTITION p0 VALUES LESS THAN (2),
          PARTITION p1 VALUES LESS THAN MAXVALUE
        );

        INSERT INTO tbl VALUES (-1);
        INSERT INTO tbl values (3);
        INSERT INTO tbl values (99) into :xx;
        
        SELECT :xx.id FROM db_root;
        COMMIT;

        SELECT :xx.id FROM db_root;
        DELETE FROM tbl WHERE id = 99;
        SELECT :xx.id FROM db_root;
        
        -- 수정 이전 버전에서는 위에서 레코드를 삭제했는데도 아래 질의를 수행하면 삭제 이전의 값이 출력된다.
        SELECT :xx.id FROM db_root;

ALTER TABLE ... PARTITION으로 테이블 재분할 시 정상 수행되지 않는 문제(CUBRIDSUS-1408)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    ALTER TABLE ... PARTITION으로 테이블 재분할을 수행하면 기존의 분할 정보가 제거되지 않고 유지되는 문제를 수정했다.

    .. code-block:: sql

        CREATE TABLE participant2 (host_year INT, nation CHAR(3), gold INT, silver INT, bronze INT)
        PARTITION BY RANGE (host_year)    (
            PARTITION before_2000 VALUES LESS THAN (2000),
            PARTITION before_2008 VALUES LESS THAN (2008)
        );

        ALTER TABLE participant2 REORGANIZE PARTITION before_2000 INTO (
            PARTITION before_1996 VALUES LESS THAN (1996),
            PARTITION before_2000 VALUES LESS THAN (2000)
        );
    
loaddb 유틸리티로 많은 분할을 가진 테이블의 생성을 시도하면 분할이 되지 않는 문제(CUBRIDSUS-5833)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    loaddb 유틸리티로 많은 분할을 가진 테이블을 생성하려고 시도하면 정상적으로 분할이 생성되지 않는 문제를 수정했다.

    .. code-block:: sql

        ALTER CLASS [col_day]
        PARTITION BY LIST ( [yyyymmdd] ) (
            PARTITION [p_20110701] VALUES IN ('20110701'),
            PARTITION [p_20110702] VALUES IN ('20110702'),
            PARTITION [p_20110703] VALUES IN ('20110703'),
            PARTITION [p_20110704] VALUES IN ('20110704'),
            PARTITION [p_20110705] VALUES IN ('20110705'),
            PARTITION [p_20110706] VALUES IN ('20110706'),
            PARTITION [p_20110707] VALUES IN ('20110707'),
            ....
            PARTITION [p_20111231] VALUES IN ('20111231') 
        );

인덱스
------



인덱스 생성 후 데이터를 삭제한 테이블에서 MAX 함수나 ORDER BY DESC를 사용한 질의 수행 시 발생하는 오류(CUBRIDSUS-7988)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    테이블에 데이터가 존재하는 상태에서 인덱스 생성하고 데이터를 모두 삭제한 이후, 이 테이블에 MAX 함수나 ORDER BY DESC를 사용하는 등 인덱스의 마지막 리프 페이지를 찾는 질의를 수행하면 " ERROR: An I/O error occurred while reading page 65536 of volume (null).... Bad file descriptor " 오류가 발생하는 현상을 수정했다.

    .. code-block:: sql

        CREATE TABLE tb2 (col1 INT PRIMARY KEY, col2 VARCHAR (16));
        INSERT INTO tb2 VALUES (1, '1');
        
        CREATE INDEX i_tb2 ON tb2 (col1, col2);
        DELETE FROM tb2;
        
        SELECT * FROM tb2 ORDER BY 1 DESC, 2 DESC;
    
PREFIX 인덱스가 생성된 칼럼에서 집계 함수 수행 시 오동작(CUBRIDSUS-6579)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    PREFIX 인덱스가 생성된 칼럼에서 집계 함수를 수행하면 집계 대상 칼럼의 타입이 CHAR인 경우 " ERROR: No error message available. " 오류가 발생하고, VARCHAR인 경우 잘못된 결과를 출력하는 현상을 수정했다.

    .. code-block:: sql

        CREATE TABLE t1 (id INT PRIMARY KEY, b CHAR (16), INDEX (b (4)));
        INSERT INTO t1 VALUES (1, 'xxxxbbbb'), (2, 'xxxxaaaa');
        
        -- 수정 이전 버전에서 다음 질의 수행 시 오류 발생
        SELECT MAX(b) FROM t1;
        CREATE TABLE t1 (id int PRIMARY KEY, b VARCHAR (16), INDEX (b (4)));
        INSERT INTO t1 VALUES (1, 'xxxxbbbb'), (2, 'xxxxaaaa');
        
        -- 수정 이전 버전에서 다음 질의 수행 시 'xxxx'가 결과 값으로 나옴
        SELECT MAX(b) FROM t1;
    
인덱스 생성 시 동일한 키를 가지는 인덱스가 생성되어 있으면 B-Tree를 공유하게 됨(CUBRIDSUS-6430)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    인덱스 생성 시 동일한 키의 인덱스가 이미 생성되어 있으면 인덱스를 생성할 수 없다는 오류가 발생했으나, 물리적으로 인덱스를 중복하여 생성하지 않고 기존 인덱스를 공유하도록 변경했다. 아래 예에서 외래 키를 생성하는 b 칼럼에는 이미 인덱스가 정의되어 있어 외래 키를 위한 B-Tree를 별도로 생성할 필요가 없다.

    .. code-block:: sql

        CREATE TABLE t1 (
            a INT PRIMARY KEY,
            b INT, 
            KEY(b),
            CONSTRAINT fk FOREIGN KEY (b) REFERENCES t1 (a)
        );
    
검색 조건에 클래스 OID로 검색하는 조건이 있고 그 외 나머지 조건들은 모두 커버링 인덱스 조건을 만족할 때 서버가 비정상 종료되는 오류(CUBRIDSUS-7585)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    검색 조건에 클래스 OID로 검색하는 조건이 있고 그 외 나머지 조건들은 모두 커버링 인덱스 조건(인덱스에 SELECT 리스트의 칼럼과 WHERE 조건의 칼럼을 모두 포함)을 만족할 때 질의 수행 과정에서 서버가 비정상 종료되는 오류를 수정했다.

    .. code-block:: sql

        CREATE TABLE a (class_of OBJECT, class_name VARCHAR (200));
        CREATE TABLE c (class_name VARCHAR (200), i INT);
        CREATE INDEX i ON c (class_name);
        INSERT INTO a VALUES (INSERT INTO c VALUES ('aa', 1), 'aa');
        
        SELECT c.class_name
        FROM a, c
        WHERE a.class_of = c AND c.class_name = a.class_name;

USING INDEX 절이 유효하지 않은 경우 응용 프로그램이 비정상 종료될 수 있는 현상 (CUBRIDSUS-7672)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    다음 예와 같이 USING INDEX 절이 유효하지 않은 경우 응용 프로그램이 비정상 종료될 수 있는 현상을 수정했다.

    .. code-block:: sql

        CREATE TABLE t1 (a INT, b CHAR(3), c INT);
        CREATE TABLE t2 (a INT, b CHAR(3), c INT);
        CREATE INDEX i1 ON t1 (a, c);
        CREATE INDEX i2 ON t2 (a, c);
        
        SELECT * FROM (t1, t2) s WHERE c = 9 USING INDEX i1;

외래 키 생성 시 CONSTRAINT ... REFERENCES ... 구문 사용이 가능해짐(CUBRIDSUS-6556)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    외래 키 생성 시 이전 버전에서는 FOREIGN KEY REFERENCES ... 형태의 구문만 사용 가능했으나, CONSTRAINT constraint_이름 REFERENCES ...도 사용 가능하도록 수정했다.

    .. code-block:: sql

        CREATE TABLE tbl (id INT CONSTRAINT pk_id PRIMARY KEY);
        CREATE TABLE tbl2 (id INT FOREIGN KEY REFERENCES tbl (id))
        CREATE TABLE tbl3 (id INT CONSTRAINT fk_id REFERENCES tbl (id));
    
ALTER ... CHANGE COLUMN 구문 수행 시 기본 키 칼럼의 NOT NULL 제약 조건이 제거되는 문제(CUBRIDSUS-7966)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    ALTER ... CHANGE COLUMN 구문을 수행하면 기본 키 칼럼의 NOT NULL 제약 조건이 제거되는 문제를 수정했다.

    .. code-block:: sql

        CREATE TABLE t1_add_default (a INT PRIMARY KEY, b INT);
        ALTER TABLE t1_add_default CHANGE COLUMN a a INT DEFAULT 2;
        INSERT INTO t1_add_default (a, b) VALUES (NULL, 1);
    
다수의 트랜잭션이 오버 플로우 키가 존재하는 인덱스에 대한 입력/삭제를 동시에 수행하는 도중, 한 트랜잭션의 롤백으로 다른 트랜잭션이 실패하는 오류(CUBRIDSUS-8838)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    오버 플로우 키가 존재하는 인덱스에 여러 트랜잭션이 동시에 입력/삭제를 수행하는 환경에서, 한 트랜잭션이 롤백되면 다른 트랜잭션들에 " Query execution failure " 에러가 발생할 수 있는 현상을 수정했다.

오버플로우 키가 seperator로 사용된 인덱스에 대해 통계 정보를 갱신하면 서버 프로세스가 비정상 종료되는 문제(CUBRIDSUS-8865)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

HA 기능 및 HA 데이터 복제
-------------------------



칼럼 타입 변경 이후 복제 불일치 문제(CUBRIDSUS-7386)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    트랜잭션 복제 로그 반영 프로세스가 재시작하면서, 스키마 변경 이전 로그를 재반영하여 복제 불일치가 발생하는 문제를 해결했다.

매우 긴 트랜잭션을 끝까지 반영하지 못하는 문제(CUBRIDSUS-7638)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    트랜잭션 복제 로그 반영 프로세스가 매우 긴 트랜잭션 반영 시 무한 재시작하며 끝까지 반영하지 못하는 문제를 해결했다.

새 명령어들 추가(CUBRIDSUS-5468)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    데이터베이스의 트랜잭션 로그 복사/복제 로그 반영 프로세스를 구동/정지하는 cubrid heartbeat copylogdb/applylogdb <start|stop> db_name peer_host 명령이 추가되었다.
    로그 다중화가 불가능한 상태(노드간 데이터 동기화가 불가능한 상태)에서 단독으로 서버 프로세스만 실행되는 것을 방지하기 위해, HA 모드로 설정된 데이터베이스 서버 프로세스를 cubrid server start/stop 명령으로 시작/정지할 수 없도록 했다. 

    수정 이전 버전에서 사용되었던 act, deact, deregister 명령은 더 이상 사용되지 않는다.

DELETE 복제 성능 개선(CUBRIDSUS-6436)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    HA 복제에서 DELETE 복제 성능을 개선하여 초당 복제 건수가 이전 버전 대비 약 1.7배 향상되었다.

트랜잭션 복제 로그 반영 프로세스의 CPU 사용량을 줄이도록 개선(CUBRIDSUS-6118)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

정상 상황일 때 슬레이브 노드에 발생 가능한 오류에 대해 오류 수준을 Warning으로 변경(CUBRIDSUS-8937)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    HA 환경에서 슬레이브 노드에 " Internal error: fetching deallocated pageid 0 of volume /CUBRID/databases/testdb_lgat " 오류는 정상 상황일 때 발생할 수 있으므로 오류 수준을 Error에서 Warning으로 변경했다.

시스템 파라미터 값의 구분자로 ","와 ":" 두 가지 모두 사용 가능하도록 개선(CUBRIDSUS-5647)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    ha_node_list, ha_replica_list, ha_db_list, ha_copy_sync_mode, ha_ping_hosts 등 HA 관련 시스템 파라미터의 값들에 대한 구분자로 콤마(',')와 콜론(':') 두 가지 모두 사용할 수 있도록 개선했다.

마스터 노드가 슬레이브 노드의 연결을 대기 중인 to-be-active 상태에서 TCP 연결이 끊어지면 오류 처리하지 않는 문제(CUBRIDSUS-7154)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    HA 환경에서 마스터 노드가 슬레이브 노드의 연결을 대기 중인 to-be-active 상태에서 연결을 요청한 클라이언트의 TCP 연결이 끊어지는 경우에도 HA 상태를 확인하는 프로세스(cub_master)에 연결 대기 정보가 남아있는 문제가 존재했으나, 이러한 경우 오류 처리하도록 수정했다.

트리거가 존재하는 경우 트리거에 의해 변경된 데이터가 복제 반영되었음에도 불구하고 슬레이브 노드에서 다시 트리거를 수행하는 문제(CUBRIDSUS-8165)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    마스터 노드의 트리거 동작 결과가 슬레이브 노드에 복제되었음에도 불구하고 슬레이브 노드에서 동일한 트리거 동작이 반복 수행되어 질의 결과가 잘못될 수 있는 문제를 수정했다.

핑 호스트가 설정된 HA 환경에서 슬레이브 서버와 핑 호스트 모두 연결 불가능한 상황이 발생하면 상황 복구 이후에도 응용 프로그램이 마스터 서버에 연결 불가능한 현상(CUBRIDSUS-7183)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    핑 호스트(ping host)가 설정된 HA 환경에서 슬레이브 서버와 핑 호스트 모두 마스터 서버와 연결 불가능한 상황이 발생하면 연결 가능하도록 복구한 이후에도 응용 프로그램이 마스터 서버에 연결 불가능한 현상을 수정했다. 핑 호스트가 존재하는 HA 구성에서는 마스터 서버가 핑 호스트로 연결이 되지 않으면 마스터의 역할을 유지할 수 없다고 판단하기 때문에 슬레이브로 역할 변경을 하게 되고, 응용 프로그램은 읽기 전용으로만 사용이 가능하게 된다.

failover 후 마스터가 된 노드에서 CUBRID HA 기능을 정지하면 이후 HA 기능을 구동했을 때 비정상 종료되는 현상(CUBRIDSUS-8906)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    failover 후 마스터가 된 노드에서 cubrid heartbeat stop으로 CUBRID HA 기능을 정지하면 이후 cubrid heartbeat start로 HA 기능을 구동했을 때 비정상 종료되는 현상을 수정했다.

레플리카 노드 설정을 삭제한 후 reload 명령을 수행해도 레플리카 노드가 구성 정보에 남아있는 문제(CUBRIDSUS-8107)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    cubrid_ha.conf의 ha_replica_list를 삭제한 이후 cubrid heartbeat reload 명령을 수행했음에도 불구하고 레플리카 노드가 구성 정보에서 삭제되지 않고 남아있는 문제를 수정했다.

테이블의 분할 조건에 음수가 포함된 경우 조건이 양수로 바뀌는 문제(CUBRIDSUS-8461)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    HA 환경에서 테이블의 분할 조건에 음수가 포함된 경우 조건이 양수로 바뀌는 문제를 수정했다. 수정 이전 버전에서 아래의 예를 수행하면 분할 조건 (-2, 1)이 (2, 1)로 잘못 생성되었다.

    .. code-block:: sql

        CREATE TABLE t1 (a INT AUTO_INCREMENT (-2, 3) PRIMARY KEY) 
        PARTITION BY LIST (a) 
        (PARTITION p0 VALUES IN (-2, 1));

슬레이브 노드에 쓰기 요청 시 실패한 요청을 무한히 재시도하는 현상(CUBRIDSUS-6266)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    슬레이브 노드에 INCR(), UPDATE 등 쓰기 요청 시 쓰기에 실패했다는 오류 메시지를 출력해야 하나 응용 프로그램에서는 실패한 요청을 무한히 재시도하고, CSQL 인터프리터에서는 " ERROR: Your transaction has been aborted by the system due to server failure or mode change. " 메시지를 두 번 출력한 후 CSQL 인터프리터를 종료하는 현상을 수정했다.

슬레이브 노드에서 페이지 버퍼 크기를 초과하는 칼럼으로 정렬하는 SELECT 질의 수행에 실패하는 현상(CUBRIDSUS-9272)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    HA 환경의 슬레이브 노드에서 페이지 버퍼 크기(기본 16K)를 초과하는 칼럼으로 정렬하는 SELECT 질의를 수행하면 " Attempted to update the database when updates are disabled. " 오류 메시지와 함께 실패하는 현상을 수정했다.

to-be-active 상태의 서버에 클라이언트가 수 차례 접속을 시도한 상태에서 서버의 종료를 시도하면 서버 프로세스가 비정상 종료되는 현상(CUBRIDSUS-7756)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    HA 환경에서 to-be-active 상태의 서버에 CSQL 등의 클라이언트가 cubrid.conf의 max_clients 개수 이상 접속 시도를 반복한 상태에서, 서버의 정상 종료를 시도하면 서버 프로세스가 비정상 종료되는 현상을 수정했다.

서버 프로세스 장애 이후 재시작된 상태에서 HA 기능 종료를 수행하면 HA 관리 프로세스가 비정상 종료될 수 있는 문제(CUBRIDSUS-6878)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    HA 환경에서 서버 프로세스(cub_server) 장애 이후 프로세스가 재시작된 상태에서 cubrid heartbeat stop을 수행하면 HA를 관리하는 cub_master 프로세스가 비정상 종료될 수 있는 문제를 수정했다.

HA 기능 정지 도중 로그 반영 프로세스가 비정상 종료될 수 있는 현상(CUBRIDSUS-6974)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    cubrid heartbeat stop으로 HA 기능 정지 도중 로그 반영 프로세스가 비정상 종료될 수 있는 현상을 수정했다.

슬레이브 노드의 복제 재구축 후 복제 로그 반영 프로세스가 비정상 종료될 수 있는 문제(CUBRIDSUS-9166)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    HA 환경에서 슬레이브 노드의 복제 재구축 후 반영해야 할 보관 로그의 로그 페이지를 찾지 못하는 오류로 인해 applylogdb 프로세스가 비정상 종료될 수 있는 문제를 수정했다.

ASYNC 모드로 동작하는 트랜잭션 복제 로그 복사 프로세스와 연결되는 서버 프로세스에서 ETIMEOUT 오류는 정상 동작임에도 오류 로그를 기록하는 문제(CUBRIDSUS-6248)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    ASYNC 모드로 동작하는 트랜잭션 복제 로그 복사 프로세스와 연결되는 서버 프로세스에서 " pthread_cond_wait() failed. " (ETIMEOUT) 오류 발생 시 오류 로그를 기록하지 않도록 수정했다. ETIMEOUT 오류는 서버 프로세스에서 트랜잭션 로그를 기록하는 스레드가 동작 대기 시간을 초과하면서 발생하는 오류이며 ASYNC 모드에서 이 오류가 발생하는 것은 정상임에도 불구하고, 이전 버전에서는 이를 오류 로그 파일에 기록하여 불필요한 디스크 I/O를 초래했다.

shell prompt가 길면 HA 복제스크립트가 실패하는 문제(CUBRIDSUS-7524)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    슬레이브 노드 재구성 스크립트인 ha_make_slavedb.sh에서 다른 노드의 환경 변수 체크 결과를 전달받는 부분이 실패하는 문제를 수정했다.

HA 스키마 복제
--------------


WITH CHECK OPTION 절이 슬레이브 노드에 반영되지 않는 현상(CUBRIDSUS-8367)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    HA 환경에서 뷰의 WITH CHECK OPTION 절이 슬레이브 노드에 반영되지 않는 현상을 수정했다.

    .. code-block:: sql

        CREATE TABLE vc_tb (a INT PRIMARY KEY);
        CREATE VIEW fbo_view AS SELECT * FROM vc_tb WHERE a > 5 WITH CHECK OPTION;
    
DROP TABLE 문의 IF EXISTS 절이 슬레이브 노드에 반영되지 않는 현상(CUBRIDSUS-8901)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    HA 환경에서 DROP TABLE 문의 IF EXISTS 절이 슬레이브 노드에 반영되지 않는 현상을 수정했다.

    .. code-block:: sql

        DROP TABLE IF EXISTS tbl1;
    
뷰의 칼럼으로 논리 표현식이 포함된 경우 슬레이브 노드에 반영되지 않는 현상(CUBRIDSUS-7927)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    HA 환경에서 뷰의 SELECT 리스트에 논리 표현식이 포함된 경우 슬레이브 노드에 반영되지 않는 현상을 수정했다.

    .. code-block:: sql

        CREATE VIEW v(a, b, c) AS SELECT a, b, (b = 'aaa') c FROM t;
    
뷰가 마스터 노드와 슬레이브 노드에서 서로 다르게 보이는 문제(CUBRIDSUS-8366)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    마스터 노드에서 생성한 뷰를 슬레이브 노드에서 시스템 카탈로그 테이블 db_vclass로 출력하면 WHERE 조건 일부에 괄호가 추가되어 보이는 문제를 수정했다.

    .. code-block:: sql

        CREATE TABLE vc_tb1 (a INT PRIMARY KEY);
        
        -- 수정 이전 버전에서 위의 뷰를 슬레이브 노드의 db_vclass에서 출력하면 WHERE 조건이 괄호로 감싸였다.
        CREATE VIEW vtb1 (a INT) AS SELECT * FROM vc_tb1 WHERE a >= 1;
    
CREATE .... AS SELECT 문으로 테이블 생성 시 슬레이브 노드에 잘못된 칼럼 순서로 복제될 수 있는 문제(CUBRIDSUS-8071)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    HA 환경에서 CREATE .... AS SELECT 문으로 테이블 생성 시 슬레이브 노드에 잘못된 칼럼 순서로 복제될 수 있는 문제를 수정했다.
    
    .. code-block:: sql

        -- 마스터 노드에서 다음을 수행
        CREATE TABLE t2 (a INT PRIMARY KEY, b INT, c INT)
        AS SELECT t1.c AS a, t1.a AS b, t1.b AS c FROM t1;

        -- 슬레이브 노드에서 다음과 같이 칼럼 순서가 잘못 복제됨
        CREATE TABLE [t2] ( [a] INTEGER, [b] INTEGER, [c] INTEGER, PRIMARY KEY ([a]) )
        AS SELECT [t1].[c], [t1].[a], [t1].[b] FROM [t1];
    
인덱스를 CREATE/DROP하고 테이블을 DROP 하면 슬레이브 노드에서 -414번 오류가 발생하는 현상(CUBRIDSUS-8634)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    하나의 트랜잭션에서 인덱스를 CREATE/DROP하고 테이블을 DROP한 후 커밋하면 슬레이브 노드에서 정상 상황임에도 불구하고 " ERROR CODE = -414 ... Unknown class identifier " 오류가 발생하는 현상을 수정했다.

SELECT 문을 동반한 DDL 문이 슬레이브 노드에 복제되지 않는 문제(CUBRIDSUS-8992)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    HA 환경에서 CREATE TABLE ... SELECT, CREATE VIEW ... SELECT 와 같이 SELECT 문을 동반한 DDL 문이 복제되지 않는 문제를 수정했다.

    .. code-block:: sql

        CREATE TABLE t1 (a INT PRIMARY KEY, b INT)
        AS SELECT * FROM (SELECT 1 AS a, (SELECT 1) b FROM db_root) tt; 

인덱스 생성 시 슬레이브 노드에 반영되지 않는 문제(CUBRIDSUS-6818)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    HA 환경에서 인덱스를 생성할 때 인덱스 생성문이 슬레이브 노드에 반영되지 않는 현상을 수정했다.

    .. code-block:: sql

        CREATE TABLE tab (a INT AUTO_INCREMENT(1, 1) PRIMARY KEY, c VARCHAR (32));
        CREATE INDEX i_tab_c ON tab (c);
    
생성하려는 인덱스의 이름이 예약어인 경우 슬레이브 노드에 반영되지 않는 현상 수정(CUBRIDSUS-8054)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    HA 환경에서 생성하려는 인덱스의 이름이 예약어인 경우 " Internal system failure: [t2,'create class [t2] ( [a] integer, [b] integer, index none ([a]) ) '] In line 1, column 44 before ' ([a]) ) ' " 오류 메시지와 함께 슬레이브 노드에 반영되지 않는 현상을 수정했다.

    .. code-block:: sql

        CREATE TABLE t2 (a INT, b INT, INDEX "none" (a));

AUTO_INCREMENT 필드가 있는 테이블에 대해 TRUNCATE 수행 시 슬레이브 노드에 반영되지 않는 현상(CUBRIDSUS-7810)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    HA 환경에서 AUTO_INCREMENT 필드가 있는 테이블에 대해 TRUNCATE를 수행하면 슬레이브 노드에서 " Accessing Delete Object " 오류 메시지와 함께 슬레이브 노드에 반영되지 않는 현상을 수정했다.

AUTO_INCREMENT 칼럼이 있는 테이블의 DROP 이후에도 슬레이브 노드에 AUTO_INCREMENT에 의한 시리얼이 남아있는 문제(CUBRIDSUS-8885)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    HA 환경의 마스터 노드에서 AUTO_INCREMENT 칼럼이 있는 테이블의 DROP 이후에도 슬레이브 노드에 AUTO_INCREMENT에 의한 시리얼이 남아있는 오류로 인해, 마스터 노드에서 같은 테이블 이름과 칼럼 이름으로 AUTO_INCREMENT를 재생성을 시도하면 슬레이브 노드에 테이블이 생성되지 않는 문제를 수정했다.

    .. code-block:: sql

        CREATE TABLE t1 (id INT PRIMARY KEY AUTO_INCREMENT, a INT);
        DROP TABLE t1;
        CREATE TABLE t1 (id INT PRIMARY KEY AUTO_INCREMENT, b INT);
    
AUTO_INCREMENT 칼럼 속성 또는 이름을 변경하면 슬레이브 노드에 반영되지 않는 현상(CUBRIDSUS-7830)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    HA 환경에서 AUTO_INCREMENT 칼럼 속성 변경 또는 AUTO_INCREMENT 칼럼 속성 추가와 함께 이름을 변경하면 슬레이브 노드에 반영되지 않는 현상을 수정했다.

    .. code-block:: sql

        -- 속성 변경
        CREATE TABLE foo (a INTEGER PRIMARY KEY AUTO_INCREMENT, b CHAR(10), c DATETIME);
        ALTER TABLE foo MODIFY ATTRIBUTE a BIGINT AUTO_INCREMENT;

        -- 이름 변경
        CREATE TABLE boo (i int PRIMARY KEY);
        ALTER TABLE boo ADD COLUMN ai INT AUTO_INCREMENT, RENAME TO u, AUTO_INCREMENT = 100;

ALTER SERIAL 문이 슬레이브 노드에 반영되지 않는 현상(CUBRIDSUS-8727)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    HA 환경에서 ALTER SERIAL 문이 슬레이브 노드에 반영되지 않는 현상을 수정했다.

    .. code-block:: sql

        ALTER SERIAL s1 START WITH 2;
    
DROP SERIAL 문이 슬레이브 노드에 반영되지 않는 현상(CUBRIDSUS-8673)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    HA 환경에서 DROP SERIAL 문이 슬레이브 노드에 반영되지 않는 현상을 수정했다.

시리얼 생성 혹은 변경에서 NOCACHE 옵션 지정 시 슬레이브 노드에 반영되지 않는 현상(CUBRIDSUS-9225)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    HA 환경에서 CREATE SERIAL 또는 ALTER SERIAL 문에 NOCACHE 옵션이 지정되면 슬레이브 노드에 반영되지 않는 현상을 수정했다.

ALTER INDEX ... REBUILD 구문이 슬레이브 노드에 반영되지 않는 현상(CUBRIDSUS-8090)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    HA 환경에서 ALTER INDEX ... REBUILD 구문 수행 시 " log applier: failed to apply schema replication log. class: "-", schema: 'alter index i_t_b on () rebuild', internal error: -492. " 오류 메시지와 함께 슬레이브 노드에 반영되지 않는 현상을 수정했다.

    .. code-block:: sql

        ALTER INDEX i_t_b REBUILD;
    
ALTER... CHANGE COLUMN 구문이 슬레이브 노드에 반영되지 않는 현상(CUBRIDSUS-8023)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    HA 환경에서 ALTER... CHANGE COLUMN 구문이 슬레이브 노드에 반영되지 않는 현상을 수정했다.

    .. code-block:: sql

        ALTER TABLE coo CHANGE col1 col1 INT AFTER col3;
        
    ::
    
        -- 위의 질의를 수행하면 슬레이브 노드에서 아래와 같은 오류가 발생했다.
        log applier: failed to apply schema replication log. class: "coo", schema: "'alter class [coo] change attribute [col1] [col1] integerafter [col3] '", internal error: -492.
        
    .. code-block:: sql

        ALTER TABLE t1 ALTER COLUMN a set DEFAULT 1;
    
    ::
    
        -- 위의 질의를 수행하면 슬레이브 노드에서 아래와 같은 오류가 발생했다.
        "alter class [t1] alter column [b] set default default 1", this SQL statement is illegal. So there is something wrong with the "parser_print_xxx" function.
    
ALTER .. CHANGE 문으로 칼럼의 DEFAULT 값을 변경하면 슬레이브 노드에 반영되지 않는 현상(CUBRIDSUS-8021)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    HA 환경에서 ALTER .. CHANGE 문으로 DEFAULT 값을 변경하면 " log applier: failed to apply schema replication log. class: "t1", schema: "'alter class [t1] alter column [a] set default default 1'", internal error: -492. " 오류 메시지와 함께 슬레이브 노드에 반영되지 않는 현상을 수정했다.

    .. code-block:: sql

        ALTER TABLE t1 ALTER COLUMN a SET DEFAULT 1;
    
ALTER .... AUTO_INCREMENT 구문이 슬레이브 노드에 반영되지 않는 현상(CUBRIDSUS-8203)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    HA 환경에서 ALTER .... AUTO_INCREMENT 구문이 " log applier: failed to apply schema replication log. class: "t", schema: "'alter class [t] auto_increment = 5'", internal error: -1056. " 오류 메시지와 함께 슬레이브 노드에 반영되지 않는 현상을 수정했다.

    .. code-block:: sql

        ALTER TABLE t AUTO_INCREMENT = 5;

ALTER 문으로 테이블 분할 시 슬레이브 노드에 반영되지 않는 현상(CUBRIDSUS-5266)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    HA 환경에서 ALTER 문으로 테이블 분할을 수행하는 경우 슬레이브 노드에 반영되지 않는 현상을 수정했다.

    .. code-block:: sql

        ALTER TABLE range_tbl
        REORGANIZE PARTITION p2 INTO
        (PARTITION p3 VALUES LESS THAN (25), PARTITION p4 VALUES LESS THAN (30));

PREFIX 칼럼에 DESC INDEX 생성 시 슬레이브 노드에 반영되지 않는 현상(CUBRIDSUS-8980)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    HA 환경에서 PREFIX 칼럼에 DESC INDEX 생성 시 슬레이브 노드에 반영되지 않는 현상을 수정했다.

    .. code-block:: sql

        ALTER TABLE c2 ADD INDEX i_c (c (5) DESC);
    
트리거, 시리얼, 저장 함수 및 프로시저의 소유자가 슬레이브 노드에 잘못 반영되는 현상(CUBRIDSUS-8723)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    트리거, 시리얼, 저장 함수 및 프로시저의 소유자가 슬레이브 노드에 항상 "DBA"로 잘못 반영되는 현상을 수정했다.

자동 커밋 모드가 OFF일 때 DROP TABLE IF EXISTS 문을 수행하면 슬레이브 노드에 반영되지 않는 현상(CUBRIDSUS-8582)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    자동 커밋 모드가 OFF일 때 DROP TABLE IF EXISTS 문을 수행하면 " SYNTAX ERROR ... ERROR CODE = -493 " 오류 메시지와 함께 슬레이브 노드에 반영되지 않는 현상을 수정했다.

    .. code-block:: sql

        DROP TABLE IF EXISTS m1;
        CREATE TABLE m1 (i INT, j INT PRIMARY KEY);
        COMMIT;
    
분할 테이블이 슬레이브 노드에 반영되지 않을 수 있는 문제(CUBRIDSUS-8985)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    HA 환경에서 분할 테이블의 파티션 데이터가 내부적으로 타입 변환이 일어나는 경우, 슬레이브 노드에 복제되지 않는 문제를 수정했다. 

    .. code-block:: sql

        CREATE TABLE t1 (i INT PRIMARY KEY)
        PARTITION BY RANGE (i) (
          PARTITION p1 VALUES LESS THAN (-2147483648),
          PARTITION p2 VALUES LESS THAN MAXVALUE
        );


드라이버
--------

[JDBC] 예외 오류 메시지 출력 시 연결 URL을 출력하도록 개선(CUBRIDSUS-7781)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    JDBC 예외 오류 메시지를 출력할 때 연결 URL 정보도 같이 출력하도록 개선했다.

    ::

        cubrid.jdbc.driver.CUBRIDException: jdbc:cubrid:localhost:33300:testdb:dba:********:
        Syntax: Syntax error: unexpected END OF STATEMENT
    
[JDBC] iBatis에서 자바 저장 프로시저의 Resultset을 조회할 수 없는 문제(CUBRIDSUS-7383)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    iBatis에서 자바 저장 프로시저를 호출한 결과 값을 칼럼 이름으로 resultMap을 구성하여 ArrayList로 전달받을 수 있게 되었다.

[JDBC] ResultSetMetaData.isAutoIncrement() 메서드가 정상 동작하지 않는 문제(CUBRIDSUS-7531)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    JDBC의 ResultSetMetaData.isAutoIncrement() 메서드 호출 시 어떤 칼럼의 AUTO_INCREMENT 설정 여부와 무관하게 false를 반환했으나, AUTO_INCREMENT 설정 여부에 맞게 동작하도록 수정했다.

[JDBC] 응용 프로그램에서 브로커 로그에 연결 URL을 잘못 출력하는 오류(CUBRIDSUS-7956)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    JDBC 응용 프로그램에서 브로커 로그에 연결 URL을 출력할 때 "?"를 추가로 잘못 출력하는 오류를 수정했다.
    다음은 수정 이전 버전에서 브로커 로그 파일에 URL을 잘못 출력한 예이다. dba:: 뒤에 나타나는 "?" 는 하나만 출력되어야 한다.

    ::

        jdbc:cubrid:10.0.0.1:33000:demodb:dba::??queryTimeout=60000001&connectTimeout=10000
    
[JDBC] Date나 Time 객체 값을 받을 때 밀리초가 0으로 리셋되지 않은 채로 반환되는 문제(CUBRIDSUS-7352)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    java.sql.Date나 java.sql.Time 객체의 값이 밀리초 부분의 값이 0으로 리셋되지 않은 상태로 반환되는 문제를 수정했다.

    .. code-block:: java

        ResultSet rs = connection.createStatement().executeQuery("select time '12:15:00'");
        rs.next();
        System.out.println(rs.getTime(1).getTime());

[JDBC] 응용 프로그램에서 음수년도의 입력을 허용하는 오류(CUBRIDSUS-8844)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    JDBC 응용 프로그램에서 Datetime 데이터를 bind 할 때 허용 범위(1-9999)를 벗어난 년도의 입력을 허용하는 오류를 수정했다.

[JDBC] Connection이 종료되거나 DatabaseMetaData가 close()된 이후 호출되는 DatabaseMetaData의 일부 메서드에서 NullPointerException이 발생하는 오류(CUBRIDSUS-7807)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    JDBC의 Connection에서 DatabaseMetaData를 얻어온 후 Connection이 종료되거나 DatabaseMetaData가 close() 된 경우에 DatabaseMetaData의 getTables(), getColumns(), getTablePrivileges(), getPrimaryKeys(), getForeignKeys() 메서드를 호출하면 NullPointerException이 발생하는 오류를 수정했다.

[JDBC] 같은 Statement 객체를 반복 사용하여 여러 개의 질의를 수행하면 도중에 발생할 수 있는 예외를 처리하지 못하는 문제(CUBRIDSUS-9015)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    JDBC 응용 프로그램에서 같은 Statement 객체를 반복 사용하여 여러 개의 질의를 수행하면 도중에 예외 발생 시 사용 중이던 서버 핸들을 종료하지 못하여 에러 코드 -26번이 반복하여 발생할 수 있는 문제를 수정했다.

    .. code-block:: java

        public void run(ArrayList<String> sqlList, int max) throws SQLException {
            this.sqlList = sqlList;
            Connection conn = getConnection();
            Statement stmt = conn.createStatement();
            String sql;
            int i = 0;
            while (true) {
                sql = getNextLine();
                if (sql == null)
                break;
                try {
                    stmt.execute(sql);
                } catch (Exception e) {
                    log(e, i, sql);
                }
                i++;
            }
            stmt.close();
            conn.close();
        }
    
[JDBC] /\*+ RECOMPILE \*/ 힌트가 있는 SELECT 문을 여러 스레드에서 동시에 실행하면 "Statement Pooling" 오류가 발생하는 문제(CUBRIDSUS-7616)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    JDBC 응용 프로그램에서 /\*+ RECOMPILE \*/ 힌트가 있는 SELECT 문을 여러 스레드에서 동시에 실행하면 " cubrid.jdbc.driver.CUBRIDException: Statement Pooling " 오류가 발생하는 문제를 수정했다.

[JDBC] ResultSet.TYPE_SCROLL_SENSITIVE 옵션이 사용될 때 시스템 카탈로그 뷰에 대한 SELECT 질의에 실패하는 문제(CUBRIDSUS-7076)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    JDBC의 ResultSet.TYPE_SCROLL_SENSITIVE 옵션이 사용될 때 db_class와 같은 시스템 카탈로그 뷰에 대한 SELECT 질의를 수행한 뒤 fetch를 수행하면 " Semantic: System error (generate attr) in ../../src/parser/xasl_generation.c " 오류가 발생하는 문제를 수정했다.
    ResultSet.TYPE_SCROLL_SENSITIVE 옵션은 현재 지원하지 않으므로 ResultSet.TYPE_SCROLL_INSENSITIVE로 설정할 것을 권장한다.

[JDBC] 2.4E+2와 같은 과학적 표기법의 값을 BigDecimal로 바인딩하는데 실패하는 문제(CUBRIDSUS-7943)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    JDBC 응용 프로그램에서 2.4E+2와 같은 과학적 표기법(scientific notation)으로 표현된 값을 BigDecimal로 바인딩하는데 실패하는 문제를 수정했다.

    .. code-block:: java

        BigDecimal x = new BigDecimal("240.0");
        x = x.stripTrailingZeros(); // 과학 형식의 값으로 지정
        p.setBigDecimal(1, x);
    
[JDBC] prepare한 질의에 유효하지 않은 값을 바인딩하여 실행한 후 다시 유효한 값을 바인딩하여 실행하면 Exception이 발생하는 현상(CUBRIDSUS-7648)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    JDBC 응용프로그램에서 prepare한 질의에 유효하지 않은 값을 바인딩하여 실행한 후 다시 유효한 값을 바인딩하여 실행하면 Exception이 발생하는 현상을 수정했다.
    ::
    
        // 수정 이전 버전에서는 다음과 같이 Exception이 발생했다.
        No error message available.
        cubrid.jdbc.driver.CUBRIDException: No error message available.
        at cubrid.jdbc.driver.CUBRIDConnection.createCUBRIDException(CUBRIDConnection.java:829)
        at cubrid.jdbc.driver.CUBRIDStatement.checkExecuteError(CUBRIDStatement.java:941)
        at cubrid.jdbc.driver.CUBRIDStatement.executeCoreInternal(CUBRIDStatement.java:830)
        at cubrid.jdbc.driver.CUBRIDStatement.executeCore(CUBRIDStatement.java:791)
        at cubrid.jdbc.driver.CUBRIDPreparedStatement.executeQuery(CUBRIDPreparedStatement.java:107)
        at cubrid_262_error.main(cubrid_262_error.java:26)
    
[JDBC] 백슬래시를 이스케이프 문자로 사용하도록 설정하면 JDBC getColumns() 메서드 수행 시 발생하는 오류(CUBRIDSUS-8080)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    시스템 파라미터 no_backslash_escape 의 값을 no로 설정하여 백슬래시를 이스케이프 문자로 사용하도록 설정하면 getColumns() 메서드로 테이블의 칼럼 정보를 얻을 때 " unterminated string " 오류가 발생하는 현상을 수정했다.

    .. code-block:: sql

        CREATE TABLE t2 (col1 INT, col2 VARCHAR(20));
    
[JDBC] 응용 프로그램에서 Statement.close()를 수행하기 전에는 Resultset.close()를 수행해도 결과 셋의 메모리를 해제하지 않는 문제(CUBRIDSUS-9206)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    JDBC 응용 프로그램에서 Statement.close()를 수행하기 전까지는 Resultset.close()를 수행해도 결과 셋의 메모리를 해제하지 않는 문제로 인해 메모리 사용량이 증가할 수 있는 현상을 수정했다.

[CCI] Linux용 CCI 라이브러리는 파일만으로도 드라이버의 버전 확인이 가능하게 개선(CUBRIDSUS-6954)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    Linux용 CCI 라이브러리는 파일만으로도 드라이버의 버전 확인이 가능하게 개선했다.

    ::

        $ strings /home/usr1/CUBRID/lib/libcascci.so | grep VERSION
        VERSION=9.0.0.0001
        
    참고로, cci_get_version(major, minor, patch) 함수를 사용해도 드라이버의 버전 확인이 가능하다.

[CCI] 디버깅용 로그를 기록하도록 설정하는 연결 URL 속성 추가(CUBRIDSUS-6377)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    CCI 연결 URL에 디버깅용 로그 기록을 설정하는 기능을 추가했다. logSlowQueries와 slowQueryThresholdMillis는 슬로우 쿼리의 로그 기록을, logTraceApi는 CCI 함수가 호출될 때 각 함수의 시작과 끝을, logTraceNetwork은 CCI 함수의 Network 데이터 전송 내용을 로그 파일에 기록한다.
    
    ::

        url = "cci:cubrid:localhost:33000:demodb:::?logSlowQueries=true&slowQueryThresholdMillis=1000&logTraceApi=true&logTraceNetwork=true"

    아울러, CCI 연결 URL에 디버깅용 로그 파일의 경로를 지정하는 logBaseDir의 동작 방식을 수정했다. 이전 버전에서는 logBaseDir 값과 logFile이 같이 있으면 logBaseDir 프로퍼티를 무시했으나 수정 이후 경로를 포함한 파일 이름을 "logBaseDir/logFile"로 지정하도록 바뀌었다.
    
[CCI] cci_schema_info()에서 트리거 정보를 얻을 때 테이블 이름을 지정했는데도 전체 데이터베이스의 트리거 정보를 출력하는 오류(CUBRIDSUS-7675)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    cci_schema_info()에서 트리거 정보를 얻을 때 테이블 이름을 지정했는데도 전체 데이터베이스의 트리거 정보를 출력하는 오류를 수정했다. 이와 함께, 트리거 정보를 얻을 때 입력할 테이블 이름 또는 칼럼 이름을 LIKE 절의 패턴 매칭으로 검색할 수 있는 기능을 추가했다.

    .. code-block:: c

        req = cci_schema_info(conn, CCI_SCH_TRIGGER, "tbl%", NULL, CCI_CLASS_NAME_PATTERN_MATCH, &error);
    
[CCI] cci_get_attr_type_str()의 반환 값이 잘못된 문제(CUBRIDSUS-7910)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    cci_get_attr_type_str()의 반환 값에서 제일 마지막 문자가 잘리는 문제를 수정했다.

    .. code-block:: c

        // 소스 예제
        char *attr_infos[][2] =
        {
            {"aa", "character(1)"},
            {NULL, NULL}
        };
         ...
        res = cci_get_attr_type_str(conn, class_name, attr_infos[i][0], buf, buf_size, &error);
        ...
        fprintf(LOG_FD, "%s attr: %s\n\n", attr_infos[i][0], buf);
         // 수정 이전 출력 화면
        aa attr: character(1
    
[CCI] 서버 재시작 이후에도 cci_prepare() 함수를 호출하면 정상 수행되지 않고 여전히 오류가 발생하는 문제(CUBRIDSUS-8907)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    데이터베이스 서버 종료로 인해 cci_prepare() 함수에서 오류가 발생한 이후 서버를 재시작해도 cci_prepare() 함수를 호출하면 정상 수행되지 않고 여전히 오류가 발생하는 문제를 수정했다.

[CCI] 잠금 타임아웃이 발생했을 때 CCI 함수에서 잘못된 오류 코드를 반환하는 문제 (CUBRIDSUS-7226)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    cci_prepare() 및 cci_execute() 함수에서 잠금 타임아웃(lock timeout)이 발생했을 때 오류 코드 -75를 오류 코드 -493으로 래핑(wrapping)하여 반환하던 것을 -75번 오류가 직접 전달되도록 수정했다.

[JDBC, CCI] 응용 프로그램에서 트랜잭션 진행 중 특정 시점 이후 일부 질의만 커밋되는 문제 (CUBRIDSUS-8563)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    JDBC 또는 CCI 응용 프로그램에서 트랜잭션 진행 중 서버의 재시작, CAS의 강제 재시작 등 특정 시점 이후 일부 질의만 커밋되는 문제를 수정했다.

[CCI] cci_prepare_and_execute() 함수 실행 시 CAS가 재시작되면 오류가 발생할 수 있는 문제(CUBRIDSUS-9278)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    cci_prepare_and_execute() 함수 실행 시 재시작된 CAS에 재접속하는 루틴이 존재하지 않아 " Cannot communication with broker " 오류가 발생하는 문제를 수정했다.

[CCI] 질의 타임아웃 값을 매우 작게 설정하면 cci_prepare_and_execute() 함수에서 질의 타임아웃이 발생하지 않는 현상(CUBRIDSUS-8102)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    질의 타임아웃 값을 3밀리 초와 같이 아주 작게 설정하면 cci_prepare_and_execute() 함수에서 질의 타임아웃이 발생하지 않는 현상을 수정했다. 이와 함께 CAS로그에 보여지는 query timeout 설정값이 다음과 같이 밀리초 단위로 나타나도록 수정했다.

    ::

        07/11 11:34:52.933 (2) set query timeout to 3000 milliseconds (from app)

[CCI] 동시 다중 스레드 실행 환경에서 cci_connect_with_url()의 연결 URL에 호스트 명을 주면 응용 프로그램이 비정상 종료될 수 있는 현상(CUBRIDSUS-8318)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    여러 개의 스레드가 동시에 실행되는 환경에서 cci_connect_with_url() 함수의 연결 URL에 IP가 아닌 호스트 명을 주면 응용 프로그램이 비정상 종료될 수 있는 현상을 수정했다.

[CCI] cci_schema_info()의 수행 결과 페치 시 칼럼의 인덱스 여부에 대해 잘못된 정보를 출력하는 오류(CUBRIDSUS-7174)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    cci_schema_info()의 수행 결과를 페치(fetch)하는 경우 어떤 칼럼에 인덱스 존재 여부를 나타내는 값을 잘못 출력하는 오류를 수정했다.

[JDBC, CCI] 응용 프로그램에서 연결 URL이 잘못되었음에도 불구하고 오류가 발생하지 않는 문제 (CUBRIDSUS-7967)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    JDBC/CCI 응용 프로그램에서 연결 URL이 잘못되는 경우 오류를 발생하도록 수정했다. 이 수정으로 인해, 수정 이전 버전에서는 DB 이름 뒤에 ":" 두 개가 생략될 수 있었으나, 수정 이후 버전에서는 이를 허용하지 않게 되었다.

    ::

        URL=jdbc:CUBRID:192.168.0.1:33000:demodb:::?altHosts=192.168.0.2:33000,192.168.0.3:33000
        
    그리고, 수정 이후 Linux용 버전에서는 URL의 데이터베이스 이름에 "?"를 포함할 수 있게 되었다.

[JDBC, CCI] Windows용 CUBRID에서 JDBC 또는 CCI 응용 프로그램으로 VARCHAR 칼럼에 ""인 값을 바인딩하면 발생하는 precision 오류 (CUBRIDSUS-9306)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    JDBC 또는 CCI 응용 프로그램으로 VARCHAR 타입 칼럼에 공백 문자열("")을 바인딩하면 발생하는 precision 오류를 수정했다. 이 문제는 Windows 버전에서만 발생하는 문제이다.

유틸리티
--------

CSQL에서 질의문과 ; 다음에 주석이 존재하면 질의 수행에 실패하는 문제(CUBRIDSUS-6381)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    CSQL 인터프리터에서 질의문과 세미콜론(;) 다음에 주석이 존재할 때 주석 제일 뒤에 세미콜론을 추가하지 않으면 질의 수행에 실패하는 문제를 수정했다.

    .. code-block:: sql

        SELECT 1; --
        
CSQL 세션 명령어를 UP 커서 키로 재입력 가능하도록 개선(CUBRIDSUS-8646)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    CSQL 인터프리터에서 세션 명령어는 UP 커서 키로 재입력되지 않았으나, 이를 가능하도록 수정했다.

    ::

        csql> ;sc tbl
        // UP 커서 키로 방금 전 실행한 세션 명령어를 재입력할 수 있게 되었다.
        csql> ;sc tbl
    
CSQL -i 옵션을 이용하여 파일로 질의문 입력 시 질의문이 매우 길거나 여러 라인으로 작성되면 질의문이 잘못 변경될 수 있는 문제(CUBRIDSUS-7848)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    CSQL 인터프리터에서 -i 옵션을 이용하여 파일로 질의문을 입력할 때 질의문이 매우 길거나 여러 라인으로 작성되면, 긴 질의를 나누어 저장하는 버퍼의 끝 또는 라인의 끝에 나타나는 빈 문자열을 잘라냄으로 인해 질의문이 변경되어 의도하지 않은 값이 입력되거나 에러가 발생할 수 있는 문제를 수정했다.

CSQL에서 ;를 두번 입력해야 특정 질의가 수행되는 현상(CUBRIDSUS-5963)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    시스템 파라미터인 no_backslash_escapes의 값을 no로 설정한 환경에서, " INSERT INTO t VALUES(1,'\'') "와 같이 이스케이프 문자가 포함된 질의문을 CSQL 인터프리터에서 입력할 경우 세미콜론(;)을 한번 더 입력해야만 질의가 수행되는 문제를 수정했다.

CSQL에서 질의 계획 보기 수행 중 Ctrl+C한 후 스키마 내용을 조회하면 비정상 종료되는 현상(CUBRIDSUS-8456)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    CSQL 인터프리터에서 ;info plan으로 질의 계획 보기 수행 중 Ctrl+C한 후 ;sc <table> 명령으로 스키마 내용을 조회하면 비정상 종료되는 현상을 수정했다.

데이터베이스 서버 종료 후 질의를 재차 수행 시 CSQL이 비정상 종료되는 현상(CUBRIDSUS-6256)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    데이터베이스 서버 종료 후 CSQL 인터프리터에서 질의 수행 시 처음에는 " ERROR: Your transaction has been aborted by the system due to server failure or mode change. "라는 정상 오류를 출력하나, 질의를 다시 수행하면 CSQL 인터프리터가 비정상 종료되는 현상을 수정했다.

Windows 용 CSQL에서 테이블 혹은 칼럼 명에 특수문자가 포함된 질의를 수행하면 CSQL 인터프리터가 비정상 종료되는 현상(CUBRIDSUS-9054)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    Windows 버전의 CSQL 인터프리터에서 테이블 혹은 칼럼 명에 '%'와 같은 특수문자가 포함된 질의를 수행하면 CSQL 인터프리터가 비정상 종료되는 현상을 수정했다.

    .. code-block:: sql

        SELECT * FROM [as%];

broker_log_runner 실행 이후 출력 파일에 질의 수행 시간 포함(CUBRIDSUS-8237)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    broker_log_runner 실행 이후 -o 옵션으로 지정한 출력 파일에 질의 수행 시간을 포함하도록 수정했다.

    ::

        // broker_log_runner로 수행하면 prepare/execute/end tran 시간이 추가로 표시된다. 
        -------------- query ----------------- 
        SELECT * FROM xx; 
        cci_prepare exec_time : 0.000 
        cci_execute exec_time : 0.000 
        cci_execute:1
        ---------- query plan --------------
         ... 
        ---------- query result --------------
         ... 
        cci_end_tran exec_time : 0.000 

        // 수행중 에러가 발생하면 에러 메세지도 같이 표시된다. 
        -------------- query ----------------- 
        INSERT INTO t1 VALUES (DATE '11/11/1994'); 
        cci_prepare elapsed time : 0.000 
        replay_sqllog.txt: 
        server error : -493 Syntax: before ' VALUES (DATE '11/11/1994'); ' Unknown class "t1". insert into t1 values (date '11/11/1994') 
        cci_end_tran elapsed_time : 0.000


loaddb 유틸리티에서 --error-control-file 옵션을 사용하여 수행할 때의 성능 개선(CUBRIDSUS-7424)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    loaddb 유틸리티 수행 시 --error-control-file 옵션이 설정되어 있을 때 데이터베이스 서버에 한 번에 하나의 행만 전송하도록 했으나 한 번에 여러 개의 행을 전송할 수 있도록 수정하여, 해당 옵션을 사용할 때의 성능이 개선되었다. 

    고유 키 위반 에러를 무시하도록 --error-control-file에 -670 에러 번호를 설정하고 한 테이블에 50만건의 데이터를 로딩하는 시험에서 고유 키 위반 에러 개수가 5만 건일 때, 수정 이전 대비 수정 이후 버전에서 약 1.5배의 성능이 향상되었다.

loaddb 유틸리티의 --error-control-file 옵션이 정상 동작하지 않는 문제(CUBRIDSUS-7484)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    loaddb 유틸리티 수행 중 특정 에러는 무시하고 계속 진행하도록 --error-control-file 옵션을 설정했음에도 불구하고, 해당 에러가 발생하면 수행을 종료하는 문제를 수정했다.

    ::

        cubrid loaddb -u dba -c 10000 -d tbl.ldb --error-control-file=error_lst testdb
        
        Time: 04/04/12 20:05:47.066 - WARNING *** file ../../src/storage/heap_file.c, line 9678 CODE = -48 Tran = 1, EID = 16661
        Accessing deleted object 2|607786|233.
    
loaddb 수행 중 서버에서 Warning이 발생하면 계속 수행하지 않고 종료하는 문제(CUBRIDSUS-6647)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    loaddb 수행 중 서버에서 Warning이 발생하면 커밋되지 않은 레코드들을 모두 롤백하면서 loaddb의 수행을 종료하는 문제가 존재했으나, Warning 이후에도 계속 수행하도록 수정했다.

CLOB 칼럼이 있는 데이터 파일을 로드 시 loaddb 프로세스가 비정상 종료되는 문제(CUBRIDSUS-6330)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    CLOB 칼럼이 있는 unloaddb 데이터 파일을 가지고 loaddb 유틸리티를 수행하면 loaddb 프로세스가 비정상 종료되는 문제를 수정했다.

alterdbhost 유틸리티의 오류 메시지가 잘못 출력되는 문제(CUBRIDSUS-7790)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    cubrid alterdbhost 유틸리티에서 호스트 이름을 잘못 입력할 경우 오류 메시지가 " No error message available. "로 잘못 출력되었으나 상황에 맞는 메시지를 정상 출력하도록 수정했다.

    ::

        $ cubrid alterdbhost --host=my_wrong_host_name

데이터베이스 생성 도중 ctrl+C로 작업 취소 시 비정상적인 오류를 출력하는 문제(CUBRIDSUS-8864)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    cubrid createdb 실행 도중 ctrl+c를 눌러서 작업을 취소하면 " * FATAL ERROR * Internal error: logical log page -9 may be corrupted." 오류가 발생하는 문제를 수정했다.

cubrid heartbeat status 수행 시 출력되는 프로세스 상태 정보 변경(CUBRIDSUS-5212)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    cubrid heartbeat status 수행 시 프로세스 상태 정보가 더 상세히 출력되도록 수정했다.

    +----------------------------------------+---------------+------------------------------------------------------+ 
    | 프로세스 현황                          | 상태          | 출력  정보                                           | 
    |                                        |               +-----------------------+------------------------------+ 
    |                                        |               | 수정 이전             | 수정  이후                   | 
    +----------------------------------------+---------------+-----------------------+------------------------------+ 
    | cub_server가 HA  프로세스로 등록됨     | standby       | registered            | registered_and_standby       | 
    +----------------------------------------+---------------+-----------------------+------------------------------+ 
    | cub_server가 heartbeat 리소스로 등록됨 | to_be_standby | registered            | registered_and_to_be_standby | 
    +----------------------------------------+---------------+-----------------------+------------------------------+
    | cub_server가 heartbeat 리소스로 등록됨 | to_be_active  | registered_and_active | registered_and_to_be_active  | 
    +----------------------------------------+---------------+-----------------------+------------------------------+

DB 생성 직후 백업한 볼륨으로 -d 옵션을 사용하여 복구 시도 시 실패하는 현상(CUBRIDSUS-7527)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    DB 생성 직후 cubrid backupdb를 수행하여 백업한 볼륨에 -d 옵션으로 백업 시간을 지정하여 cubrid restoredb를 실행하면 실패하는 현상을 수정했다.

    ::

        cubrid backupdb -S demodb
        csql -S demodb -c "create table x"
        cubrid restoredb -d backuptime demodb
        
        FATAL ERROR ***
        No error message available.
        Please consult error_log file = /home1/user1/CUBRID/log/demodb_restoredb.err for additional information
        ... ABORT/EXIT IMMEDIATELY ...<<<---
    
서버 프로세스 강제 종료 후 데이터베이스 복구 도중 서버 프로세스가 멈추는(hang) 현상(CUBRIDSUS-7217)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    장시간 트랜잭션 수행 중에 서버 프로세스를 강제 종료한 후, 재시작하여 데이터베이스 복구 도중 멈추는 현상을 수정했다.

브로커 상태를 주기적으로 출력하는 옵션이 오동작하는 오류(CUBRIDSUS-6413)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    cubrid broker status 명령에서 -s 옵션으로 초를 설정했음에도 불구하고 1초로 설정한 경우를 제외하고는 설정한 값대로 동작하지 않는 오류를 수정했다.

CS 모드로 cubrid checkdb 유틸리티 수행 시 DB 서버 프로세스가 비정상 종료될 수 있는 문제(CUBRIDSUS-7434)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    중복 값이 매우 많은 비고유(non-unique) 인덱스가 존재하는 상황에서 CS 모드로 cubrid checkdb 유틸리티 수행 시 DB 서버 프로세스가 비정상 종료될 수 있는 문제를 수정했다.

CUBRID Manager에서 질의 편집기 수행 종료 이후, cubrid.conf에서 설정한 잠금 타임아웃 값이 줄어들 수 있는 오류(CUBRIDSUS-7462)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    CUBRID Manager에서 질의 편집기를 수행하면 잠금 타임아웃이 내부적으로 1초로 설정되는데, 이 질의 편집기를 종료하면 이것과 연결되었던 CAS는 시스템 파라미터인 lock_timeout_in_secs에서 설정한 값으로 잠금 타임아웃을 재설정한다. 이때 해당 CAS의 잠금 타임아웃이 설정 값의 1/1000로 줄어드는 오류로 인해 이 CAS에 연결되는 다른 응용 프로그램이 줄어든 잠금 타임아웃을 사용하는 문제를 수정했다. 이 CAS는 재시작될 때까지 줄어든 잠금 타임아웃을 유지한다.
    단, lock_timeout_in_secs가 기본값인 -1로 설정된 경우 이 오류는 발생하지 않았다.

64-bit Windows용 CUBRID에서 압축 백업 수행 시 오류(CUBRIDSUS-9253)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    64-bit Windows용 CUBRID에서 "cubrid backupdb -z"으로 압축 백업 시 " No error message available. " 오류 메시지와 함께 수행에 실패하는 현상을 수정했다.

Windows용 CUBRID에서 2G 초과 파일을 포함하는 볼륨을 백업한 데이터베이스 복구에 실패하는 문제(CUBRIDSUS-7588)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    Windows용 CUBRID에서 2G 초과 파일을 포함하는 볼륨을 백업한 데이터베이스를 복구하는 경우 " Trying to format disk volume xxx with an incorrect value [xxx] for number of pages .", " Restoredb cancelled or an error occurred. " 오류 메시지와 함께 수행에 실패하는 문제를 수정했다.

CUBRID 유틸리티에서 나타나는 DB 사용자 이름이 항상 대문자로 출력되도록 수정(CUBRIDSUS-8198)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    cubrid 유틸리티에서 나타나는 DB 사용자 이름이 항상 대문자로 출력되도록 수정했다.

오류 메시지
-----------

데이터베이스 로그 처리 중 치명적인 오류 발생 시 오류 로그 파일에 정보를 남기도록 개선(CUBRIDSUS-8652)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    데이터베이스 로그를 처리하는 작업 중 발생하는 치명적인 오류에 대해 관련 정보를 오류 로그 파일에 남기도록 수정했다.

고유 키 위반 오류 메시지 출력 시 테이블, 인덱스 이름, 키 값을 출력하도록 개선(CUBRIDSUS-6885)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    고유 키를 위반한 오류 메시지를 오류 로그에 출력할 때 테이블, 인덱스 이름, 키 값을 함께 출력하도록 수정했다.

문법 에러(syntax error)나 의미 에러(semantic error) 발생 시에 에러 발생 위치를 좀 더 쉽게 찾아갈 수 있도록 에러 메시지 개선
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

잘못된 구문으로 시리얼 생성 시 출력되는 오류 메시지 개선(CUBRIDSUS-7119)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    시리얼 이름으로 예약어를 사용하거나 범위를 벗어난 값을 사용하는 등 잘못된 구문으로 시리얼 생성 시 출력되는 오류 메시지에서 잘못된 부분의 위치를 가리킬 수 있도록 수정했다.

    .. code-block:: sql

        CREATE SERIAL s START WITH 5 INCREMENT BY 3 cache -10;
    
    ::
    
         -- 수정 이전 버전의 오류 메시지
        In line 1, column 52,
        ERROR: invalid create serial
        CREATE SERIAL identifier {START WITH integer} {INCREMENT BY integer}
        serial_min_max {CYCLE|NOCYCLE} {CACHE unsigned_integer|NOCACHE}

    ::
    
         -- 수정 이후 버전의 오류 메시지
        ERROR: In line 1, column 52 before '10; '
        Syntax error: unexpected '-', expecting UNSIGNED_INTEGER

인덱스 이름이 잘못된 경우 출력되는 오류 메시지 개선 (CUBRIDSUS-7122)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    인덱스를 생성할 때 출력되는 인덱스 이름이 잘못된 경우 출력되는 오류 메시지에 오류 원인이 되는 인덱스 이름을 출력하도록 수정했다.

    .. code-block:: sql

        CREATE TABLE t(i int);
        CREATE INDEX INDEX ON t(i);
        
    ::
    
        ERROR: In line 1, column 14 before ' on t(i); '
        Syntax error: unexpected 'index'
    
데이터베이스 구동 시 호스트 IP 주소가 잘못된 경우 이를 확인할 수 있는 에러 메시지를 출력하도록 개선(CUBRIDSUS-6189)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    데이터베이스 구동 시 호스트 이름에 매핑되는 IP 주소가 잘못된 경우 이를 확인할 수 있는 에러 메시지를 서버 에러 로그 파일에 출력하도록 수정했다.

DDL문 방지 파라미터 혹은 WHERE 절이 있는 질의 방지 파라미터를 yes로 설정하면 상황이 구체적으로 나타나도록 오류 메시지 개선(CUBRIDSUS-8096)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    DDL문 방지 파라미터인 block_ddl_statement 혹은 WHERE 절이 있는 질의 방지 파라미터인 block_where_statement 를 yes로 설정하면 " Authorization failure. "라는 오류 메시지를 출력했으나, 상황이 구체적으로 나타나도록 오류 메시지를 수정했다.

    ::

        DDL statement is not allowed by configuration (block_ddl_statement=yes).
        Statement without WHERE clause is not allowed by configuration (block_nowhere_statement=yes).
    
분할 테이블 이름을 이미 존재하는 다른 분할 테이블 이름으로 RENAME할 때 잘못된 오류 메시지(CUBRIDSUS-7176)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    분할 테이블 이름을 이미 존재하는 다른 분할 테이블 이름으로 RENAME 할 때 오류 메시지의 분할 테이블 이름이 잘못 출력되는 문제를 수정했다.

    .. code-block:: sql

        CREATE TABLE pt1 (i INT) PARTITION BY HASH (i) PARTITION 5;
        CREATE TABLE pt2 (i INT) PARTITION BY HASH (i) PARTITION 5;
        RENAME pt1 AS pt2;

    ::
    
        -- 수정 이전 버전에서 위의 질의 수행 시 분할 테이블 이름을 출력했다.
        ERROR: Class "pt2__p__p0" already exists
    
    ::
    
        -- 수정 이후 다음과 같이 테이블 이름을 정상 출력한다.
        ERROR: Class "pt2" already exists
    
2008 R2.2 CCI 드라이버로 접속 시 비정상적인 에러코드와 메시지(CUBRIDSUS-8924)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    2008 R2.2 CCI 드라이버로 데이터베이스 서버에 접속하면 에러코드와 메시지를 비정상적으로 출력하는 문제를 수정했다.

    ::

        // 정상 오류 메시지의 예
        execute error - err_code : -670, err_msg : Operation would have caused one or more unique constraint violations.

        // 비정상 오류 메시지의 예
        execute error - err_code : -2, err_msg : yyybOperation would have caused one or more unique constraint violations

ADDDATE, SUBDATE 함수에 적합하지 않은 인자 입력 시 부적절한 오류 메시지(CUBRIDSUS-8437)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    ADDDATE , SUBDATE 함수에 적합하지 않은 인자를 입력하면 출력하는 상황에 맞지 않는 오류 메시지를 수정했다.

    .. code-block:: sql

        SELECT ADDDATE ('1991-01-01 00:00:00', -10000000);

    ::
    
        -- 수정 이전 버전에서는 아래와 같이 부적절한 오류 메시지를 출력했다.
        ERROR: before ' , -10000000); '
        No error message available.

    .. code-block:: sql
    
        SELECT SUBDATE (SYSDATE, 9999999);
        
    ::
    
        -- 수정 이전 버전에서는 아래와 같이 부적절한 오류 메시지를 출력했다.
        ERROR: Execute: Query execution failure #931.
    
SHARED 속성 칼럼에 인덱스 생성 시 부적절한 오류 메시지(CUBRIDSUS-7132)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    SHARED 속성 칼럼에 인덱스 생성 시 출력하는 상황에 맞지 않는 오류 메시지를 수정했다.

    .. code-block:: sql

        CREATE TABLE t1 (i INT SAHRED 10);
        CREATE INDEX i1 ON t1 (i);
        
    ::
    
        -- 수정 이전 에러 메시지
        ERROR: before ' ); ' i is not defined.
        
    ::
    
        -- 수정 이후 에러 메시지
        ERROR: Cannot create index on attribute "i", defined with a shared value.
    
유효하지 않은 최대값 또는 최소값으로 시리얼 생성 시도 시 잘못된 오류 메시지(CUBRIDSUS-7150)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    유효하지 않은 최대값 또는 최소값으로 시리얼 생성을 시도하면 출력하는 잘못된 오류 메시지를 수정했다.

    .. code-block:: sql

        -- 수정 이전 버전에서 무효한 최대값인 경우 "Minimum value is invalid" 라고 오류를 잘못 출력했다.
        CREATE SERIAL s START WITH 3 INCREMENT BY 1 MAXVALUE 1;

        -- 수정 이전 버전에서 무효한 최소값인 경우 "Maximum value is invalid" 라고 오류를 잘못 출력했다.
        CREATE SERIAL s START WITH 3 INCREMENT BY 1 MINVALUE 5;
    
잠금 타임아웃 발생 시 서버 오류 메시지에 한 트랜잭션의 종료를 대기 중이던 전체 트랜잭션 정보를 출력하도록 개선(CUBRIDSUS-7272)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    잠금 타임아웃 오류 메시지에 해당 트랜잭션의 종료를 대기 중이던 다른 트랜잭션 정보를 모두 출력하도록 개선했다. 이와 함께, 잠금 타임아웃의 메시지 출력 포맷을 설정하던 lock_timeout_message_type 파라미터는 더 이상 사용하지 않는다.

    ::

        Your transaction (index 2, user1@host1|9808) timed out waiting on IX_LOCK lock on class tbl. 
        You are waiting for user(s) user1@host1|csql(9807), user1@host1|csql(9805) to finish.
    
잠금 대기 중에 질의 타임아웃이 발생했음에도 불구하고 잠금 타임 아웃 오류가 발생하는 문제(CUBRIDSUS-7215)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    잠금 대기 중에 질의 타임아웃(query timeout)이 발생했음에도 불구하고 질의 타임아웃 오류가 발생하지 않고 잠금 타임아웃(lock timeout) 오류가 발생하는 문제를 수정했다.

설정, 빌드 및 설치
------------------

특정 오류 번호에 대해 콜 스택 출력 여부를 설정하는 시스템 파라미터의 동적 변경을 허용하도록 개선(CUBRIDSUS-5717)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    데이터베이스 구동 중에 특정 오류 번호에 대해 콜 스택(call stack) 출력 여부를 설정하는 시스템 파라미터인 call_stack_dump_activation_list, call_stack_dump_deactivation_list 의 동적 변경을 허용하도록 개선했다. 또한, 치명적인 에러들은 call_stack_dump_activation_list 에 별도의 설정이 없어도 기본적으로 포함되도록 수정했다.

cub_master, cub_broker 프로세스의 유닉스 도메인 소켓 파일의 위치를 바꿀 수 있도록 수정(CUBRIDSUS-6910)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    Linux용 CUBRID에서 cub_master, cub_broker 프로세스 수행 시 생성되는 유닉스 도메인 소켓(unix domain socket) 파일의 위치를 CUBRID_TMP 환경변수를 통해 변경할 수 있도록 수정했다. cub_master의 유닉스 도메인 소켓 파일의 위치는 기존에는 /tmp였으며 수정 이후에도 CUBRID_TMP 환경 변수를 설정하지 않으면 기존 위치와 같다. cub_broker의 유닉스 도메인 소켓 파일의 위치는 기존에는 $CUBRID/var/CUBRID_SOCK이었으며, 수정 이후에도 $CUBRID_TMP를 설정하지 않으면 기존 위치와 같다. CUBRID_TMP 환경 변수를 통해 다음과 같은 두 가지 문제를 회피할 수 있다.

    1. cub_broker용 유닉스 도메인 소켓 파일을 저장하는 $CUBRID/var/CUBRID_SOCK 경로의 최대 길이는 108인데, CUBRID의 설치 경로가 길어서 경로 길이가 108을 넘는 경우가 있다.

    2. /tmp는 Linux에서 임시 파일을 저장하는 공간으로 어떤 관리자는 이 공간을 주기적으로 임의 정리하는 경우가 있다.

32bit 버전에서 시스템 파라미터인 data_buffer_size의 최대값을 2G로 제한(CUBRIDSUS-6257)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    32bit 버전에서 시스템 파라미터인 data_buffer_size의 최대값을 2G로 제한하도록 수정했다.

인덱스 스캔 관련 OID 버퍼 파라미터 설정 값의 크기가 1K일 때 데이터베이스를 구동하지 못하는 현상(CUBRIDSUS-8958)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    인덱스 스캔 관련 OID 버퍼 파라미터인 index_scan_oid_buffer_size 설정 값의 크기가 1K일 때 데이터베이스를 구동하지 못하는 현상을 수정했다.

데이터베이스 서버 프로세스의 버퍼 크기 설정 값이 장비의 물리적 메모리 용량보다 크면 데이터베이스 생성에 실패하는 현상(CUBRIDSUS-7763)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    데이터베이스 서버 프로세스가 메모리 내에 캐시하는 데이터 버퍼의 크기를 설정하는 시스템 파라미터인 data_buffer_size의 값이 물리적 메모리 용량보다 크더라도 데이터베이스를 생성할 수 있도록 수정했다.

시스템 파라미터인 data_buffer_size의 크기를 시스템의 가용 크기보다 크게 설정하면 서버 프로세스가 비정상 종료되는 현상(CUBRIDSUS-6350)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    시스템 파라미터인 data_buffer_size의 크기를 시스템의 가용 크기보다 크게 설정한 후 구동하면 서버 프로세스가 비정상 종료되는 현상을 수정했다.

시스템 파라미터인 ha_node_list 에 구분자인 @이 없으면 HA 시작 시 서버 프로세스가 비정상 종료되는 문제(CUBRIDSUS-6474)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    HA 환경에서 cubrid_ha.conf의 ha_node_list에 그룹 이름과 멤버 호스트 이름을 구분하는 @이 없으면 cubrid heartbeat start 수행 시 서버 프로세스가 비정상 종료되는 문제를 수정했다.

Windows 용 CUBRID에서 ha_mode 파라미터의 값을 yes로 설정하면 CUBRID 서비스 종료를 시도해도 종료되지 않는 문제(CUBRIDSUS-6982)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    Windows 용 CUBRID에서 ha_mode 파라미터의 값을 yes로 설정하면 cubrid service stop 을 수행해도 CUBRID 서비스가 종료되지 않는 문제를 수정했다.

    참고로, HA 기능은 Linux 용 CUBRID만 지원한다.

cubrid_broker.conf 파일 없이 브로커 유틸리티를 수행하면 잘못된 오류 메시지를 출력하는 문제(CUBRIDSUS-8932)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    cubrid_broker.conf 파일 없이 브로커를 시작하면 브로커의 구동에 실패하면서 "The socket path is too long (>108): /home/CUBRID/var/CUBRID_SOCK/ "이라는 비정상적인 오류 메시지를 출력했으나 정상적인 오류 메시지를 출력하도록 수정했다.

    cubrid_broker.conf 파일 없이 cubrid broker status, cubrid broker stop 를 수행하면 오류 메시지를 "cubrid broker is not running."으로 잘못 출력했으나, 정상적인 오류 메시지를 출력하도록 수정했다.

데이터베이스 서버에 동시 접속을 허용하는 최대 접속 개수를 10000개로 늘림(CUBRIDSUS-7233)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    데이터베이스 서버에 동시 접속을 허용하는 최대 개수를 설정하는 max_clients 시스템 파라미터의 최대값 제한을 1024에서 10000으로 늘렸다. 참고로, 클라이언트의 DB 접속 여부에 관계 없이 max_clients의 개수를 크게 설정할수록 메모리 사용량이 증가하므로 이에 주의하도록 한다.

브로커 파라미터 값이 잘못되었을 때 부적절한 오류 메시지를 출력하는 문제(CUBRIDSUS-9280)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    브로커 파라미터 값이 잘못되었을 때 "Error: can't find cubrid_broker.conf"라는 부적절한 오류 메시지를 출력하는 문제를 수정했다.

브로커 파라미터의 SLOW_LOG 설정을 동적으로 변경하면 각 CAS의 SQL_LOG 설정이 변경되는 문제(CUBRIDSUS-7592)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    broker_changer로 SLOW_LOG 설정을 동적으로 변경하면 각 CAS의 SQL_LOG 설정이 변경되는 문제를 수정했다.

    ::

        % broker_changer query_editor SLOW_LOG ON
    
브로커 접속을 제한하는 ACCESS_CONTROL_FILE파일의 작성 형식 확장(CUBRIDSUS-5449)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    브로커에 접속하는 응용 클라이언트를 제한하는 ACCESS_CONTROL_FILE 파일에 같은 데이터베이스 이름과 같은 데이터베이스 사용자에 대하여 여러 개의 IP 목록 파일을 한 줄 또는 여러 줄에 작성할 수 있도록 했다.

    ::

        dbname:dbuser1:IPread.txt, IPwrite.txt
        dbname:dbuser2:IPread.txt
        dbname:dbuser2:IPwrite.txt
        dbname:dbuser2:IPexternal.txt
    
TMPDIR 환경 변수 설정 시 Linux sh 패키지로 CUBRID 설치에 실패하는 문제(CUBRIDSUS-8005)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    TMPDIR 환경 변수의 값이 설정되어 있으면 Linux sh 패키지를 이용하여 CUBRID를 설치하는데 실패하는 문제를 수정했다.

RPM 패키지의 의존성 오류(CUBRIDSUS-7809)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    RPM 패키지 설치 시 의존성(dependencies) 오류를 수정했다.

CUBRID RPM 빌드 시 반드시 필요한 라이브러리를 모두 검사하도록 수정(CUBRIDSUS-7611)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    CUBRID RPM 빌드 시 필요한 라이브러리 중 누락된 일부를 검사 대상에 포함하도록 수정했다.

Windows 버전 설치 후 "제어판 > 프로그램 제거" 화면의 버전 명에 빌드 번호 명기(CUBRIDSUS-9282)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    Windows 버전 설치 후 "제어판 > 프로그램 제거" 화면의 버전 명에 빌드 번호를 명기했다. 수정 이전에는 9.0.0과 같이 출력되었으나 수정 이후 9.0.0.xxxx와 같이 출력된다.

Ubuntu에서 CUBRID 소스를 빌드할 때 Warning이 발생하는 현상(CUBRIDSUS-7812)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    Ubuntu에서 configure를 수행할 때 automake 1.11.3을 쓰게 되면서 Warning이 발생하는 현상을 수정했다.

기타
----


CAS에 보낸 SIGTERM이 다른 응용 프로그램에 전달될 수 있는 문제(CUBRIDSUS-6693)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    CAS 재시작을 위해 브로커가 CAS에 보낸 SIGTERM 시그널이 다른 응용 프로그램에 전달될 수 있는 문제를 수정했다.

질의 수행 시 영향 받는 행의 개수를 잘못 출력하는 경우(CUBRIDSUS-7135)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    질의 수행 시 영향을 받는 행의 개수를 잘못 출력하는 경우가 존재했으나 이를 수정했다.

    .. code-block:: sql

        INSERT INTO t1 SELECT ROWNUM FROM db_class;
        
    ::
    
        -- 수정 이전 1 출력
        1 row affected.

    ::
    
        -- 수정 이후 정상 출력
        52 rows affected.

주의 사항
=========

신규 주의 사항
--------------

9.0 Beta 이전 버전과 DB 볼륨이 호환되지 않음 (CUBRIDSUS-5238)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    9.0 Beta 이전 버전과 DB 볼륨이 호환되지 않으므로 cubrid unloaddb/loaddb를 이용하여 데이터를 마이그레이션해야 한다. 보다 자세한 사항은 :doc:`/upgrade` 절을 참고한다.

기존 주의 사항
--------------

2008 R4.1 버전부터 CCI_DEFAULT_AUTOCOMMIT 의 기본값이 ON으로 바뀜 (CUBRIDSUS-5879)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    2008 R4.1 버전부터 CCI 인터페이스로 개발된 응용 프로그램의 자동 커밋 모드에 영향을 주는 브로커 파라미터인 CCI_DEFAULT_AUTOCOMMIT의 기본값이 ON으로 변경되었다. 따라서 CCI 및 CCI로 개발된 인터페이스(PHP, ODBC, OLE DB 등) 사용자는 응용 프로그램의 자동 커밋 모드가 이에 적합한지 살펴보아야 한다.

2008 R4.0 버전부터 페이지 단위의 옵션 및 파라미터가 볼륨 크기 단위로 바뀜 (CUBRIDSUS-5136)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    cubrid createdb 유틸리티의 DB 볼륨 크기 및 로그 볼륨 크기를 지정할 때 페이지 단위를 사용하는 옵션들(-p, -l, -s)은 제거될 예정이므로, 2008 R4.0 Beta 이후 새로 추가된 옵션들(--db-volume-size, --log-volume-size, --db-page-size, --log-page-size)을 사용한다.

    cubrid addvoldb 유틸리티의 DB 볼륨 크기를 지정하는 경우에도 페이지 단위를 사용하지 않고 2008 R4.0 Beta 이후 새로 추가된 옵션(--db-volume-size)을 사용한다.
    페이지 단위의 시스템 파라미터들은 추후 제거될 예정이므로 바이트 단위의 새로운 시스템 파라미터를 사용할 것을 권장한다. 관련 시스템 파라미터들에 대한 내용은 아래를 참고한다.

2008 R4.0 Beta 이전 사용자는 DB 볼륨 크기 설정 시 주의 (CUBRIDSUS-4222)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    2008 R4.0 Beta 버전부터 DB 생성 시 데이터 페이지 및 로그 페이지의 크기 기본값이 4KB에서 16KB로 변경되었으므로, DB 볼륨을 페이지 개수로 지정하여 생성하는 경우 볼륨의 바이트 크기가 기대와 다를 수 있음에 주의한다. 아무런 옵션도 주지 않을 경우 이전 버전에서는 4KB의 페이지 크기로 100MB의 DB 볼륨을 생성했으나, 2008 R4.0 버전부터는 16KB의 페이지 크기로 512MB의 DB 볼륨을 생성하게 된다.

    그리고, DB 볼륨의 생성 가능한 최소 크기를 20MB로 제한했으므로 이보다 작은 크기의 DB 볼륨은 생성할 수 없다.

2008 R4.0 이전 버전의 일부 시스템 파라미터들의 기본값 변경 (CUBRIDSUS-4095)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    2008 R4.0부터 다음 시스템 파라미터들의 기본값이 변경되었다.

    DB 서버가 허용하는 동시 연결 개수를 설정하는 max_clients의 기본값, 인덱스 페이지 생성 시 향후 업데이트를 대비하여 확보하는 여유 공간 비율을 설정하는 index_unfill_factor의 기본값이 변경되었으며, 바이트 단위 시스템 파라미터의 기본값이 기존 페이지 단위 시스템 파라미터의 기본값보다 커져서 별도의 설정을 하지 않는 경우 더 많은 메모리를 사용하게 되었다.

    +-----------------------------+----------------------------+----------------------+--------------------+ 
    | 기존                        | 추가된                     | 기존                 | 변경된             | 
    | 시스템                      | 시스템                     | 기본값               | 기본값             |
    |                             |                            |                      | (단위: 바이트)     | 
    +=============================+============================+======================+====================+ 
    | max_clients                 | 없음                       | 50                   | 100                | 
    +-----------------------------+----------------------------+----------------------+--------------------+ 
    | index_unfill_factor         | 없음                       | 0.2                  | 0.05               | 
    +-----------------------------+----------------------------+----------------------+--------------------+
    | data_buffer_pages           | data_buffer_size           | 100M(페이지 크기=4K) | 512M               | 
    +-----------------------------+----------------------------+----------------------+--------------------+
    | log_buffer_pages            | log_buffer_size            | 200K(페이지 크기=4K) | 4M                 | 
    |                             |                            |                      |                    |
    +-----------------------------+----------------------------+----------------------+--------------------+
    | sort_buffer_pages           | sort_buffer_size           | 64K(페이지 크기=4K)  | 2M                 | 
    |                             |                            |                      |                    | 
    +-----------------------------+----------------------------+----------------------+--------------------+
    | index_scan_oid_buffer_pages | index_scan_oid_buffer_size | 16K(페이지 크기=4K)  | 64K                | 
    |                             |                            |                      |                    | 
    +-----------------------------+----------------------------+----------------------+--------------------+
 
    또한, cubrid createdb로 DB 생성 시 데이터 페이지 크기와 로그 페이지 크기의 최소값이 1K에서 4K로 변경되었다.
 
시스템 파라미터를 잘못 설정하면 DB 서비스, 유틸리티 및 응응 프로그램이 구동되지 않음 (CUBRIDSUS-5375)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    cubrid.conf 또는 cubrid_ha.conf에 정의되지 않은 시스템 파라미터를 설정하거나, 페이지 단위의 시스템 파라미터와 바이트 단위의 시스템 파라미터가 동시에 사용되거나, 시스템 파라미터 값이 허용 범위를 벗어나면 이와 관련된 DB 서비스, 유틸리티 및 응응 프로그램이 구동되지 않는다.

CUBRID 32bit 버전에서 data_buffer_size에 2G를 초과하는 값을 설정하면 DB 구동에 실패함 (CUBRIDSUS-5349)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    CUBRID 32bit 버전에서 data_buffer_size가 2G를 초과하는 값으로 설정되는 경우 DB 구동에 실패한다. 32bit 버전에서는 OS의 한계로 인해 설정값이 2G를 초과할 수 없음에 주의한다.

2008 R3.0 이하 버전에서 사용하던 GLO 클래스 지원 중단 (CUBRIDSUS-3826)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    CUBRID 2008 R3.0 이하 버전은 glo (Generalized Large Object) 클래스를 사용하여 Large Object를 처리했으나, CUBRID 2008 R3.1 이상 버전 glo 클래스를 제거하고 BLOB, CLOB 타입(이하 LOB)을 지원한다. 보다 자세한 사항은 :ref:`blob-clob` 절을 참고한다.

    기존의 glo 클래스 사용자는 다음과 같이 작업할 것을 권장한다.

    * GLO 데이터를 파일로 저장한 후 어플리케이션 및 DB 스키마에서 GLO를 사용하지 않도록 수정한다.

    * unloaddb, loaddb 유틸리티를 이용하여 DB 마이그레이션을 한다.

    * 변경한 어플리케이션에 맞게 파일을 LOB 데이터로 로딩하는 작업을 수행하도록 한다.

    * 수정한 어플리케이션이 정상 동작하는지 확인한다.


    참고로, cubrid loaddb 유틸리티는 GLO 클래스를 상속받거나 GLO 클래스 타입을 가진 테이블을 로딩하려는 경우 " Error occurred during schema loading " 오류 메시지와 함께 데이터 로딩을 중지한다.

    GLO 클래스의 지원 중단에 따라 각 인터페이스 별로 삭제한 함수는 다음과 같다.

    +------------+----------------------------+ 
    | 인터페이스 | 삭제한                     | 
    |            | 함수                       | 
    +============+============================+ 
    | CCI        | cci_glo_append_data        | 
    |            |                            | 
    |            | cci_glo_compress_data      | 
    |            |                            | 
    |            | cci_glo_data_size          | 
    |            |                            | 
    |            | cci_glo_delete_data        | 
    |            |                            | 
    |            | cci_glo_destroy_data       | 
    |            |                            | 
    |            | cci_glo_insert_data        | 
    |            |                            | 
    |            | cci_glo_load               | 
    |            |                            | 
    |            | cci_glo_new                | 
    |            |                            | 
    |            | cci_glo_read_data          | 
    |            |                            | 
    |            | cci_glo_save               | 
    |            |                            | 
    |            | cci_glo_truncate_data      | 
    |            |                            | 
    |            | cci_glo_write_data         | 
    |            |                            | 
    +------------+----------------------------+ 
    | JDBC       | CUBRIDConnection.getNewGLO | 
    |            |                            | 
    |            | CUBRIDOID.loadGLO          | 
    |            |                            | 
    |            | CUBRIDOID.saveGLO          | 
    |            |                            | 
    +------------+----------------------------+ 
    | PHP        | cubrid_new_glo             | 
    |            |                            | 
    |            | cubrid_save_to_glo         | 
    |            |                            | 
    |            | cubrid_load_from_glo       | 
    |            |                            | 
    |            | cubrid_send_glo            | 
    |            |                            | 
    +------------+----------------------------+ 

Windows Vista 이상 버전에서 CUBRID 유틸리티를 사용한 서비스 제어 시 권장 사항 (CUBRIDSUS-4186)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    Windows Vista 이상 버전에서 cubrid 유틸리티를 사용하여 서비스를 제어하려면 명령 프롬프트 창을 관리자 권한으로 구동한 후 사용하는 것을 권장한다.

    명령 프롬프트 창을 관리자 권한으로 구동하지 않고 cubrid 유틸리티를 사용하는 경우 UAC(User Account Control) 대화 상자를 통하여 관리자 권한으로 수행될 수 있으나 수행 결과 메시지를 확인할 수 없다.

    Windows Vista 이상 버전에서 명령 프롬프트 창을 관리자 권한으로 구동하는 방법은 다음과 같다.

    * [시작> 모든 프로그램> 보조 프로그램> 명령 프롬프트]에서 마우스 오른쪽 버튼을 클릭한다.

    * [관리자 권한으로 실행(A)]을 선택하면 권한 상승을 확인하는 대화 상자가 활성화되고, "예"를 클릭하여 관리자 권한으로 구동한다.

JDBC에서 연결 정보를 URL 스트링으로 입력하는 경우 물음표를 반드시 명시 (CUBRIDSUS-3217)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    JDBC에서 URL 스트링으로 연결 정보를 입력하는 경우 이전 버전에서는 물음표(?)를 입력하지 않더라도 속성(PROPERTY) 정보가 적용되었으나, CUBRID 2008 R3.0부터는 문법에 따라 반드시 물음표를 명시해야 하고 이를 생략할 경우 에러를 출력한다. 또한, 연결 정보 중 USERNAME과 PASSWORD가 없더라도 반드시 콜론( : )을 명시해야 한다.

    ::

        URL=jdbc:CUBRID:127.0.0.1:31000:db1:::altHosts=127.0.0.2:31000,127.0.0.3:31000 –에러 처리
        URL=jdbc:CUBRID:127.0.0.1:31000:db1:::?altHosts=127.0.0.2:31000,127.0.0.3:31000 –정상 처리

마스터 프로세스와 서버 프로세스 간 프로토콜 변경 및 두 개 버전을 동시에 운영하는 경우 포트 설정 필요 (CUBRIDSUS-3564)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    마스터 프로세스(cub_master)와 서버 프로세스(cub_server) 간 통신 프로토콜 변경으로 인해 CUBRID 2008 R3.0 이상 버전의 마스터 프로세스는 하위 버전의 서버 프로세스와 통신할 수 없고, 하위 버전의 마스터 프로세스도 2008 R3.0 이상 버전의 서버 프로세스와 통신할 수 없다. 따라서, 이미 하위 버전이 설치되어 있는 환경에서 새 버전을 추가 설치하여, 두 개 버전의 CUBRID를 동시에 운영하는 경우 각각 서로 다른 포트를 사용하도록 cubrid.conf의 cubrid_port_id 시스템 파라미터를 수정해야 한다.

DB 이름에 @를 포함할 수 없음 (CUBRIDSUS-2828)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    DB 이름에 @이 포함되는 경우 호스트 이름이 명시된 것으로 해석될 수 있으므로 이를 방지하기 위하여 cubrid createdb, cubrid renamedb, cubrid copydb 유틸리티 실행 시 DB 이름에 @를 포함할 수 없도록 수정했다.

CUBRID 소스 빌드 후 실행 시, 매니저 서버 프로세스 관련 오류 발생 (CUBRIDSUS-3553)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    사용자가 직접 빌드하여 설치하는 경우, CUBRID와 CUBRID 매니저를 각각 빌드하여 설치해야 한다. 만약, CUBRID 소스만 checkout하여 빌드 후 cubrid service start 또는 cubrid manager start를 실행하면, cubrid manager server is not installed라는 오류가 발생한다.

