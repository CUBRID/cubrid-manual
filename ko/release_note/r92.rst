:tocdepth: 3

.. contents::

***************
9.2 릴리스 노트
***************

릴리스 노트 정보
================

본 문서는 CUBRID 9.2(빌드번호 9.2.0.0133)에 관한 정보를 포함한다.
CUBRID 9.2는 CUBRID 9.1에서 발견된 오류 수정 및 기능 개선과 이전 버전들에 반영된 모든 오류 수정 및 기능 개선을 포함한다.

9.0 Beta, 9.1에 대한 정보는 :doc:`r90`, :doc:`r91`\ 에서 확인할 수 있다.

CUBRID 2008 R4.3 이하 버전에 대한 정보는 http://release.cubrid.org/ko\ 에서 확인할 수 있다.


릴리스 특징
===========

CUBRID 9.2는 CUBRID 9.1을 안정화하고 개선한 버전이다. 

CUBRID 9.2는 CUBRID 9.1과 데이터베이스 볼륨이 호환되지 않으므로, CUBRID 9.1 및 이전 버전 사용자는 반드시 **데이터베이스를 마이그레이션**\ 해야 한다. 이와 관련하여 :doc:`/upgrade` 절을 참고한다.

운영 편의성 개선
----------------
*   SQL 프로파일링 기능을 추가했다.
*   각종 상태 정보 출력 또는 트랜잭션 관리 등을 수행하는 CUBRID 운영 도구(유틸리티)의 기능을 추가 또는 개선했다.
*   각종 상태 정보의 확인이 용이하도록 로그 메시지를 강화했다.

SQL 함수 및 구문 추가
---------------------
*   FIRST_VALUE, LAST_VALUE, NTH_VALUE 함수를 추가했다.
*   CUME_DIST, PERCENT_RANK, MEDEAN 함수를 추가했다.
*   NULL의 순서 지정이 가능하도록 구문을 추가했다.

HA 복제 안정화    
--------------
*   레플리카 노드로 복제가 진행될 때 복제 지연 간격과 복제 정지 시간을 지정할 수 있게 했다. 
*   특정 질의문에 대해 복제가 되지 않는 현상들을 수정했다.
*   접속 오류 또는 복제 지연 현상들을 수정했다.

Sharding 기능 개선 및 안정화 
----------------------------
*   shard.conf로 설정하고 "cubrid shard" 명령으로 구동하던 SHARD 기능을 브로커 기능으로 통합했다. 이와 함께 SHARD 관련 파라미터 이름 대부분이 변경되었다.
*   SHARD key에 해당하는 shard ID를 확인할 수 있도록 하는 명령을 추가했다.
*   SHARD proxy에 대한 CAS의 개수가 동적으로 조정될 수 있도록 수정했다.
*   접속 오류 또는 질의 처리 오류 등을 수정했다.

동작 변경
---------
*   레코드가 있는 테이블에 "ALTER .. ADD COLUMN" 수행 시 PRIMARY KEY 또는 NOT NULL 제약 조건을 위배하는 경우가 없도록 수정했다.
*   브로커 파라미터인 SELECT_AUTO_COMMIT이 제거되었다.
*   브로커 파라미터 APPL_SERVER_MAX_SIZE_HARD_LIMIT의 값의 범위가 1과 2,097,151 사이의 값으로 제한되었다.
*   SQL 로그 파일 크기를 지정하는 브로커 파라미터 SQL_LOG_MAX_SIZE의 기본 설정값이 100MB에서 10MB로 변경되었다.
*   JDBC 응용 프로그램에서 연결 URL의 zeroDateTimeBehavior 속성 값이 "round"일 때 TIMESTAMP의 zero date를 '0001-01-01 00:00:00'에서 '1970-01-01 00:00:00'(GST)으로 변경하도록 수정했다.
*   브로커의 ACCESS_MODE 중 PHRO를 제거했다.

설정
----
*   시간 또는 용량을 입력하는 파라미터에 시간 단위 또는 용량 단위를 지정할 수 있게 했다.
*   GENERIC 볼륨의 여유 공간을 일정량 유지할 수 있게 하는 파라미터를 추가했다.

설치
----
*   ODBC, OLE DB 드라이버는 더 이상 Windows용 CUBRID 설치 패키지에 포함되지 않는다. 이들을 설치하려면 http://ftp.cubrid.org/CUBRID_Drivers/\ 에서 다운받아야 한다.

다국어
------
*   바이너리가 아닌(non-binary) 콜레이션에서는 지원하지 않았던 해시 분할을 지원하도록 수정했다. 
*   일부 질의에서 콜레이션이 적용되지 않는 오류를 수정했다.
    
드라이버 호환성
---------------
*   9.2 버전의 JDBC와 CCI 드라이버는 CUBRID 9.1 및 CUBRID 2008 R4.1, R4.3, R4.4 버전의 DB와 연동된다.

보다 자세한 변경 사항은 아래의 내용을 참고하며, 이전 버전 사용자는 :ref:`changed-behaviors92` 절과 :ref:`new-cautions92` 절을 반드시 확인하도록 한다.

기능 추가
=========

운영 편의성
-----------

.. 4.4new

SQL 프로파일링 기능 추가(CUBRIDSUS-10984)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

질의 성능 분석을 위한 SQL 프로파일링(profiling) 기능을 추가했다. 

다음과 같이 "SET TRACE ON" 문장을 실행하고 질의를 실행한 후, "SHOW TRACE" 문장을 실행하면 SQL 프로파일링 정보가 출력된다. 

::
 
    csql> SET TRACE ON;
    csql> SELECT /*+ RECOMPILE */ o.host_year, o.host_nation, o.host_city, n.name, SUM(p.gold), SUM(p.silver), SUM(p.bronze)  
            FROM OLYMPIC o, PARTICIPANT p, NATION n
            WHERE o.host_year = p.host_year AND p.nation_code = n.code AND p.gold > 10 
            GROUP BY o.host_nation;
    csql> SHOW TRACE;
 
      trace
    ======================
      '
    Query Plan:
      SORT (group by)
        NESTED LOOPS (inner join)
          NESTED LOOPS (inner join)
            TABLE SCAN (o)
            INDEX SCAN (p.fk_participant_host_year) (key range: (o.host_year=p.host_year))
          INDEX SCAN (n.pk_nation_code) (key range: p.nation_code=n.code)

      rewritten query: select o.host_year, o.host_nation, o.host_city, n.[name], sum(p.gold), sum(p.silver), sum(p.bronze) from OLYMPIC o, PARTICIPANT p, NATION n where (o.host_year=p.host_year and p.nation_code=n.code and (p.gold> ?:0 )) group by o.host_nation

    Trace Statistics:
      SELECT (time: 1, fetch: 1059, ioread: 2)
        SCAN (table: olympic), (heap time: 0, fetch: 26, ioread: 0, readrows: 25, rows: 25)
          SCAN (index: participant.fk_participant_host_year), (btree time: 1, fetch: 945, ioread: 2, readkeys: 5, filteredkeys: 5, rows: 916) (lookup time: 0, rows: 38)
            SCAN (index: nation.pk_nation_code), (btree time: 0, fetch: 76, ioread: 0, readkeys: 38, filteredkeys: 38, rows: 38) (lookup time: 0, rows: 38)
        GROUPBY (time: 0, sort: true, page: 0, ioread: 0, rows: 5)
    '

.. 4.4new

tranlist 명령에 지정된 칼럼으로 정렬하여 출력하는 기능 추가(CUBRIDSUS-9655)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

"cubrid tranlist"에 지정된 칼럼으로 정렬하여 출력하는 기능을 추가했다. 
  
다음은 네 번째 칼럼인 "Process id"를 지정하여 정렬한 정보를 출력하는 예이다. 
  
:: 
  
    % cubrid tranlist --sort-key=4 tdb 
  
    Tran index    User name Host name Process id           Program name  Query time Tran time Wait for lock holder  SQL_ID         SQL Text 
    --------------------------------------------------------------------------------------------------------------------------------------------------------------
       1(ACTIVE)     PUBLIC    myhost      20080 query_editor_cub_cas_1        0.00      0.00                   -1  *** empty *** 
       3(ABORTED)    PUBLIC    myhost      20081 query_editor_cub_cas_2        0.00      0.00                   -1  *** empty *** 
       2(ACTIVE)     PUBLIC    myhost      20082 query_editor_cub_cas_3        0.00      0.00                   -1  *** empty *** 
       4(ACTIVE)     PUBLIC    myhost      20083 query_editor_cub_cas_4        1.80      1.80              2, 3, 1  cdcb58552e320  update ta set a=5 where a > ? 
    --------------------------------------------------------------------------------------------------------------------------------------------------------------
  
    Tran index : 4 
    update ta set a=5 where a > ? 

.. 4.4new

질의 성능에 영향을 주는 상태를 기록하는 이벤트 로그 파일 추가(CUBRIDSUS-10986)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

질의 성능에 영향을 주는 SLOW_QUERY, MANY_IOREADS, LOCK_TIMEOUT, DEADLOCK, TEMP_VOLUME_EXPAND 상태를 기록하는 별도의 이벤트 로그 파일을 추가했다.

보다 자세한 사항은 매뉴얼의 :ref:`server-event-log` 절을 참고한다.


.. 4.4new

HA 상태 출력 시 cub_master 로그 파일에 각 노드 정보를 포함하도록 수정(CUBRIDSUS-11113)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

split-brain, fail-over, fail-back이 발생하면 cub_master 프로세스의 로그 파일에 각 노드 정보를 포함하여 기록하도록 수정했다.
해당 로그 파일은 $CUBRID/log/<host_name>.cub_master.err로 존재한다.
 
split-brain 상태를 해소하기 위해 스스로 종료하는 마스터 노드의 cub_master 로그 파일은 다음과 같이 노드 정보를 포함한다.
 
::
 
    Time: 05/31/13 17:38:29.138 - ERROR *** file ../../src/executables/master_heartbeat.c, line 714 ERROR CODE = -988 Tran = -1, EID = 19
    Node event: More than one master detected and local processes and cub_master will be terminated.
 
    Time: 05/31/13 17:38:32.337 - ERROR *** file ../../src/executables/master_heartbeat.c, line 4493 ERROR CODE = -988 Tran = -1, EID = 20
    Node event:HA Node Information
    ================================================================================
     * group_id : hagrp   host_name : testhost02    state : unknown
    --------------------------------------------------------------------------------
    name                priority   state          score      missed heartbeat
    --------------------------------------------------------------------------------
    testhost03          3          slave          3          0
    testhost02          2          master         2          0
    testhost01          1          master         -32767     0
    ================================================================================
 
fail-over 후 마스터로 변경되는 노드 혹은 fail-back 후 슬레이브로 변경되는 노드의 cub_master 로그 파일은 다음과 같이 노드 정보를 포함한다.
 
::    
 
    Time: 06/04/13 15:23:28.056 - ERROR *** file ../../src/executables/master_heartbeat.c, line 957 ERROR CODE = -988 Tran = -1, EID = 25
    Node event: Failover completed.
 
    Time: 06/04/13 15:23:28.056 - ERROR *** file ../../src/executables/master_heartbeat.c, line 4484 ERROR CODE = -988 Tran = -1, EID = 26
    Node event: HA Node Information
    ================================================================================
     * group_id : hagrp   host_name : testhost02    state : master
    --------------------------------------------------------------------------------
    name                 priority   state           score      missed heartbeat
    --------------------------------------------------------------------------------
    testhost03           3          slave           3          0
    testhost02           2          to-be-master    -4094      0
    testhost01           1          unknown         32767      0
    ================================================================================

SQL
---

NULL에 대한 순서 지정이 가능하도록 수정(CUBRIDSUS-7395)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ORDER BY 절 뒤에 NULLS FIRST 또는 NULLS LAST 구문을 지원하여 NULL 값에 대한 순서를 지정할 수 있도록 수정했다. 

.. code-block:: sql

    SELECT col1 FROM TABLE1 ORDER BY col1 NULLS FIRST; 
    SELECT col1 FROM TABLE1 ORDER BY col1 NULLS LAST; 


FIRST_VALUE, LAST_VALUE, NTH_VALUE 함수 추가(CUBRIDSUS-10531)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

정렬된 값 집합에서 첫번째 값, 마지막 값, N번째 값을 각각 반환하는 FIRST_VALUE, LAST_VALUE, NTH_VALUE 함수를 추가했다. 

.. code-block:: sql 

    SELECT groupid, itemno, FIRST_VALUE(itemno) OVER(PARTITION BY groupid ORDER BY itemno) AS ret_val 
    FROM test_tbl; 
    SELECT groupid, itemno, LAST_VALUE(itemno) OVER(PARTITION BY groupid ORDER BY itemno) AS ret_val 
    FROM test_tbl; 
    SELECT groupid, itemno, NTH_VALUE(itemno) OVER(PARTITION BY groupid ORDER BY itemno) AS ret_val 
    FROM test_tbl; 

CUME_DIST 함수 추가(CUBRIDSUS-10532)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

값의 그룹에서 누적 분포값을 반환하는 CUME_DIST 함수를 추가했다. 

.. code-block:: sql 

    SELECT CUME_DIST(60, 60, 'D') 
    WITHIN GROUP(ORDER BY math, english, pe) AS CUME 
    FROM SCORES; 

    SELECT id, math, english, pe, grade, CUME_DIST() OVER(ORDER BY math, english, pe) AS cume_dist 
    FROM scores 
    ORDER BY cume_dist; 

PERCENT_RANK 함수 추가(CUBRIDSUS-10533)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

값의 그룹에서 행의 상대적인 위치를 순위 퍼센트로 반환하는 PERCENT_RANK 함수를 추가했다. 

.. code-block:: sql 

    CREATE TABLE test_tbl(VAL INT); 
    INSERT INTO test_tbl VALUES (100), (200), (200), (300), (400); 
     

    SELECT PERCENT_RANK(100) WITHIN GROUP (ORDER BY val) AS pct_rnk FROM test_tbl; 
    SELECT PERCENT_RANK() OVER (ORDER BY val) AS pct_rnk FROM test_tbl; 

MEDIAN 함수 추가(CUBRIDSUS-11087)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

중앙값(median value)을 반환하는 MEDIAN 함수를 추가했다. 

.. code-block:: sql 

    SELECT col1, MEDIAN(col2) 
    FROM tbl GROUP BY col1; 

    SELECT col1, MEDIAN(col2) OVER (PARTITION BY col1) 
    FROM tbl;

DROP VIEW IF EXISTS 구문 지원(CUBRIDSUS-10715)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

DROP VIEW IF EXISTS 구문을 지원하도록 수정했다. 

.. code-block:: sql 

    CREATE TABLE t (a INT); 
    CREATE VIEW v as SELECT * FROM t; 
    DROP VIEW IF EXISTS v; 

HA
--

레플리카 노드로 복제 지연 간격을 설정하고 복제 정지 시간을 지정하는 기능 추가(CUBRIDSUS-11347)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

마스터 노드에서 레플리카 노드로 데이터 복제가 진행될 때, 복제 지연 간격을 설정하는 ha_replica_delay 파라미터와 복제 정지 시간을 지정하는 ha_replica_time_bound 파라미터를 추가했다.

.. 4.4new

"cubrid heartbeat stop" 명령 실행 시 -i 옵션 추가 및 절체 방식 변경(CUBRIDSUS-9572) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

"cubrid heartbeat stop" 명령을 수행하면 기존에는 HA 서버와 유틸리티들이 모두 종료될 때까지 기다린 후 절체가 진행되었으며, 일정 시간 동안 서버 프로세스와 유틸리티들이 스스로 종료되지 않으면 강제 종료시켰다.
하지만 수정 후에는 서버 프로세스가 미처 종료되지 않았어도 종료 과정 중 복제 불일치를 발생시키지 않는 상황이 되면, 남아있는 유틸리티들을 종료하고 즉시 절체를 진행한다. 

수정 이후 서버 프로세스가 강제 종료되지 않기 때문에 HA 재구동 시 DB 복구 시간이 들지 않게 되었다.

수정 버전에서 "cubrid heartbeat stop" 명령에 -i 옵션이 주어지는 경우 서버와 유틸리티들을 즉시 종료시키고 절체를 진행한다. 

Sharding
--------

.. 4.4new

cci_set_db_parameter 함수를 사용할 수 있도록 수정(CUBRIDSUS-10125)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

SHARD 환경에서 cci_set_db_parameter 함수를 사용할 수 있도록 수정했다. 이로 인해, SHARD 환경에서 isolation level, lock timeout을 설정할 수 있게 되었다.

.. 4.4new

shard DB의 암호를 환경 변수로 지정할 수 있도록 수정(CUBRIDSUS-11570)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cubrid_broker.conf의 SHARD_DB_PASSWORD를 환경 변수로 지정할 수 있도록 수정했다. cubrid_broker.conf에 SHARD_DB_PASSWORD를 노출시키고 싶지 않은 경우 환경 변수를 사용할 수 있다.
환경 변수 이름의 형식은 "<broker_name>_SHARD_DB_PASSWORD"이며, <broker_name>이 shard1이면 환경 변수의 이름은 SHARD1_SHARD_DB_PASSWORD가 된다.

::

    export SHARD1_SHARD_DB_PASSWORD=shard123

설정
----

.. 4.4new

복제 로그의 최대 보존 개수를 조절하는 파라미터 추가(CUBRIDSUS-11377)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

복제 로그의 최대 보존 개수를 조절하는 ha_copy_log_max_archives 파라미터를 추가했다. 
수정 이전 버전에서는 log_max_archives 파라미터를 통해서 트랜잭션 보관 로그 파일의 최대 보존 개수와 복제 로그 파일의 최대 보존 개수를 모두 지정했다. 

.. 4.4new

잠금 에스컬레이션 발생 시 트랜잭션의 롤백 여부를 지정하는 시스템 파라미터 추가(CUBRIDSUS-11384)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
잠금 에스컬레이션 발생 시 트랜잭션의 롤백 여부를 지정하는 rollback_on_lock_escalation 파라미터를 추가했다. 
  
이 파라미터가 yes로 설정되면, 잠금 에스컬레이션 발생 시점에 에스컬레이션 없이 에러 로그를 기록하고, 해당 잠금 요청은 실패하면서 트랜잭션을 롤백한다. 
no로 설정되면 기존처럼 잠금 에스컬레이션이 수행되고 트랜잭션을 계속 진행한다. 

다수의 HA/REPLICA DB로 구성된 환경에서, 브로커에서 DB로 접속하는 순서를 지정하는 파라미터 추가(CUBRIDSUS-11446)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

CONNECT_ORDER 브로커 파라미터를 추가했다. 기본값은 SEQ로 기존과 동일하게 databases.txt의 db-hosts에 설정된 순서대로 접속을 시도한다. 이 값이 RANDOM이면 db-hosts에 설정된 호스트들에 랜덤한 순서로 접속을 시도한다. 

GENERIC 볼륨의 여유공간 크기를 일정량으로 유지할 수 있도록 generic_vol_prealloc_size 시스템 파라미터 추가(CUBRIDSUS-10987)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

GENERIC 볼륨의 여유공간이 시스템 파라미터 generic_vol_prealloc_size(기본값 50M)보다 작아진 상태에서 새 페이지가 할당되면, 자동으로 generic볼륨을 확장(또는 추가)하여 여유 공간이 generic_vol_prealloc_size 이상으로 유지되도록 하였다. 

다국어
------

루마니아어 로캘 ro_RO 추가(CUBRIDSUS-9405)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

CUBRID 9.2에 루마니아어 로캘을 추가로 지원한다. 
루마니아어 로캘은 DB 생성 시에 "ro_RO.utf8"로 설정할 수 있다. 

모든 콜레이션에서 해시 분할이 가능하도록 수정(CUBRIDSUS-10161) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

바이너리가 아닌(non-binary) 콜레이션에서는 지원하지 않았던 해시 분할을 지원하도록 수정했다. 
 
.. code-block:: sql 

    .. 
    SET NAMES utf8 COLLATE utf8_de_exp_ai_ci; 

    CREATE TABLE t2 ( code VARCHAR(10)) collate utf8_de_exp_ai_ci PARTITION BY HASH (code) PARTITIONS 4; 
    INSERT INTO t2(code) VALUES ('AE'); 
    INSERT INTO t2(code) VALUES ('ae'); 
    INSERT INTO t2(code) VALUES ('Ä'); 
    INSERT INTO t2(code) VALUES ('ä'); 

SHOW CREATE TABLE 결과에 칼럼의 콜레이션을 포함하여 출력하도록 수정(CUBRIDSUS-11134)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. _changed-behaviors92:

동작 변경
=========

SQL
---

.. 4.4new

레코드가 있는 테이블에 ALTER 문으로 기본 값 없는 칼럼 추가 시 PRIMARY KEY 또는 NOT NULL 제약 조건을 위배하는 경우가 발생하지 않도록 수정(CUBRIDSUS-9725)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ALTER ... ADD COLUMN 문을 통해 기본 값이 없는 칼럼을 추가할 때 추가된 칼럼의 값이 모두 NULL이 되면서 PRIMARY KEY 또는 NOT NULL 제약 조건을 위배하는 경우가 발생하지 않도록 수정했다.

수정된 버전에서는 

*   레코드가 있는 테이블에 추가하려는 칼럼의 제약 조건이 PRIMARY KEY이면 에러를 반환하고, 
*   추가하려는 칼럼의 제약 조건이 NOT NULL이고 cubrid.conf의 add_column_update_hard_default 설정값이 no이면 에러를 반환한다. 

다국어
------

날짜/시간 타입 관련 함수에서 날짜/시간 형식 인자 생략 시 로캘 설정과 무관하게 CUBRID 기본 날짜/시간 형식으로 출력 또는 입력할 수 있도록 수정(CUBRIDSUS-12075)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

TO_CHAR(date_time, format) 함수에서 날짜/시간 형식을 생략하면 DB의 로캘 또는 intl_date_lang 파라미터의 언어 설정과 무관하게 en_US 날짜/시간 형식으로 문자열을 출력하도록 수정했다. 이로 인해 날짜/시간 형식을 생략하면 언어 설정과 무관하게 일관된 문자열을 출력할 수 있게 되었다.

en_US 날짜/시간 형식은 :ref:`언어별 기본 출력 형식 <tochar-default-datetime-format>` 표를 참고한다.

.. code-block:: sql

    SET SYSTEM PARAMETERS 'intl_date_lang = de_DE';
    SELECT TO_CHAR(datetime'12/24/2101 10:12:19');

::
    
    -- 수정 이전
      '10:12:19.000 24.12.2101'
    
    -- 수정 이후
      '10:12:19.000 AM 12/24/2101'
    
TO_DATE, TO_DATETIME, TO_TIME, TO_TIMESTAMP 함수에서 날짜/시간 형식을 생략하면 먼저 CUBRID 기본 날짜/시간 형식으로 문자열을 해석하고, 실패하는 경우 DB의 로캘 또는 intl_date_lang의 언어 설정에 따라 날짜/시간 문자열을 해석하도록 수정했다.

CUBRID 기본 날짜/시간 형식은 :ref:`cast-to-datetime-recommend`\ 을 참고한다.

.. code-block:: sql

    SET SYSTEM PARAMETERS 'intl_date_lang = ko_KR';
    SELECT TO_TIMESTAMP ( CAST ('10:12:13 12/23/2013' AS CHAR(20)));

::
    
    -- 수정 이전: ko_KR의 TIMESTAMP 문자열 형식은 'HH24:MI:SS YYYY.MM.DD'이며 이 형식으로만 문자열 인식을 시도한다.
      ERROR: Invalid format.


    -- 수정 이후: ko_KR의 TIMESTAMP 문자열 형식으로 문자열 인식을 시도하기 전에 CUBRID 기본 날짜/시간 형식으로 문자열 인식을 시도하므로 정상 수행된다.
      10:12:13 AM 12/23/2013

ENUM 타입의 콜레이션과 문자셋이 더 이상 원소에서 전파되지 않도록 수정(CUBRIDSUS-12269)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ISO88591 문자셋으로 생성한 DB에서 다음 문장을 실행한다.

.. code-block:: sql

    CREATE TABLE tbl (e ENUM (_utf8'a', _utf8'b')); 

수정 이전 버전에서, 칼럼 'e'는 UTF8 문자셋, utf8_bin 콜레이션을 가진다(ENUM 타입의 원소에서 전파됨).

수정 이후 버전에서, 칼럼 'e'는 ISO88591 문자셋, iso88591_bin 콜레이션을 가진다. 문자열 원소는 칼럼이 생성될 때 UTF8 문자셋에서 ISO88591 문자셋으로 변환된다. 사용자가 다른 문자셋이나 콜레이션을 적용하고 싶으면 테이블의 칼럼에 대해 이를 명시해야 한다.

.. code-block:: sql

    CREATE TABLE t (e ENUM (_utf8'a', _utf8'b') COLLATE utf8_bin); 
    or 
    CREATE TABLE t (e ENUM (_utf8'a', _utf8'b')) COLLATE utf8_bin;

HA
--

split-brain으로 인한 장애 시 우선 순위가 낮은 마스터를 슬레이브로 변경(CUBRIDSUS-10885)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
HA 환경에서 split-brain으로 인한 장애 시 우선 순위가 낮은 마스터를 슬레이브로 역할을 변경하도록 수정했다. 
수정 이전에는 우선 순위가 낮은 마스터 노드를 강제로 종료시켰다.

Sharding
--------

SHARD 관련 파라미터 이름 변경 및 설정/구동을 브로커로 통합(CUBRIDSUS-10884)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

SHARD 설정 및 구동과 관련하여 다음이 변경되었다. 

*   SHARD 기능을 제어하던 "cubrid shard" 명령을 제거하고, "cubrid broker" 명령에서 제어하도록 수정했다. 
*   shard.conf에서 설정하던 SHARD 관련 파라미터들은 모두 cubrid_broker.conf에서 설정하도록 수정했다. 
*   다음의 SHARD 관련 파라미터의 이름을 변경했다. 

============================================ ============================================ 
기존 파라미터                                새 파라미터 
============================================ ============================================ 
IGNORE_SHARD_HINT                            SHARD_IGNORE_HINT 
MIN_NUM_PROXY                                제거됨 
MAX_NUM_PROXY                                SHARD_NUM_PROXY 
PROXY_LOG_DIR                                SHARD_PROXY_LOG_DIR 
PROXY_LOG                                    SHARD_PROXY_LOG 
PROXY_LOG_MAX_SIZE                           SHARD_PROXY_LOG_MAX_SIZE 
PROXY_MAX_PREPARED_STMT_COUNT                SHARD_MAX_PREPARED_STMT_COUNT 
PROXY_TIMEOUT                                SHARD_PROXY_TIMEOUT 
MAX_CLIENT                                   SHARD_MAX_CLIENTS 
METADATA_SHM_ID                              SHARD_PROXY_SHM_ID 
============================================ ============================================ 

*   새로운 파라미터 SHARD가 추가되었다. ON/OFF로 값을 설정하며, ON이면 SHARD 기능을 사용할 수 있다. 

드라이버
--------

.. 4.4new

[JDBC][CCI] 배치 처리 함수에 질의 타임아웃 적용(CUBRIDSUS-10088)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
CCI의 cci_execute_batch 함수나 cci_execute_array 함수를 사용하거나, cci_execute 함수에 CCI_EXEC_QUERY_ALL 플래그를 지정하거나, JDBC의 executeBatch 메서드를 사용하는 경우에 질의 타임아웃(queryTimeout)이 적용되도록 수정했다. 
배치 처리 함수에 대한 질의 타임아웃은 개별적인 SQL 단위가 아니라, 함수(또는 메서드) 단위로 적용된다. 

.. 4.4new

[JDBC] 연결 URL의 zeroDateTimeBehavior 속성 값이 "round"일 때 TIMESTAMP의 zero date를 '0001-01-01 00:00:00'에서 '1970-01-01 00:00:00'(GST)로 변경(CUBRIDSUS-11612)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
연결 URL의 zeroDateTimeBehavior 속성 값이 "round"일 때 TIMESTAMP의 zero date를 '0001-01-01 00:00:00'에서 '1970-01-01 00:00:00'(GST)로 변경하도록 수정했다.

유틸리티
--------

cubrid createdb 수행 시 로캘을 명시하도록 수정(CUBRIDSUS-11040)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cubrid createdb 수행 시 로캘을 명시하도록 수정했다. DB 생성 시 로캘을 명시하게 되면서 기존의 CUBRID_CHARSET 환경변수는 더 이상 사용되지 않게 되었다. 

:: 
     
    $ cubrid createdb testdb en_US.utf8 
 
일부 유틸리티에서 크기를 출력할 때 소수점 이하의 값이 Linux와 Windows에서 서로 다른 경우가 발생(CUBRIDSUS-11923)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

createdb, spacedb, paramdump 등의 유틸리티에서 메모리 크기 혹은 파일 크기를 출력할 때 소수점 이하의 값이 Linux와 Windows에서 서로 다른 경우가 발생하는 문제를 수정했다.

.. _changed-config92:

설정
----

.. 4.4new, 4.4-10412
.. page_flush_interval, index_scan_key_buffer_pages은 내부 파라미터로 매뉴얼 노출 안 됨
.. 9.2에서 PROXY_LOG_MAX_SIZE, PROXY_TIMEOUT은 이름이 바뀌며, 브로커 파라미터로 통합됨.

시간 또는 용량을 입력하는 파라미터의 값 뒤에 시간 단위 또는 용량 단위를 지정할 수 있도록 수정(CUBRIDSUS-11456) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

시간 또는 용량을 입력하는 시스템(cubrid.conf), 브로커(cubrid_broker.conf) 파라미터의 값 뒤에 시간 단위 또는 용량 단위를 지정할 수 있도록 수정했다.

아래 표에서 왼쪽의 파라미터는 사용을 권장하지 않으며, 대신 오른쪽의 파라미터를 사용할 것을 권장한다.

============================== ==============================
deprecated                     new
============================== ==============================
lock_timeout_in_secs           lock_timeout
checkpoint_every_npages        checkpoint_every_size
checkpoint_interval_in_mins    checkpoint_interval
max_flush_pages_per_second     max_flush_size_per_second
sync_on_nflush                 sync_on_flush_size
sql_trace_slow_msecs           sql_trace_slow
============================== ==============================

파라미터의 입력 단위 및 의미는 다음과 같다.

+------+-----------+--------------+
| 구분 | 입력 단위 | 의미         |
+======+===========+==============+
| 용량 | B         | Bytes        |
|      +-----------+--------------+
|      | K         | Kilobytes    |
|      +-----------+--------------+
|      | M         | Megabytes    |
|      +-----------+--------------+
|      | G         | Gigabytes    |
|      +-----------+--------------+
|      | T         | Terabytes    |
+------+-----------+--------------+
| 시간 | ms        | milliseconds |
|      +-----------+--------------+
|      | s         | seconds      |
|      +-----------+--------------+
|      | min       | minutes      |
|      +-----------+--------------+
|      | h         | hours        |
+------+-----------+--------------+


단위를 사용하는 파라미터 및 해당 파라미터가 허용하는 단위는 다음과 같다.

+-----------+---------------------------------+---------------+
| 구분      | 파라미터 이름                   | 허용 단위     |
+===========+=================================+===============+
| 시스템    | thread_stacksize                | B,K,M,G,T     |
|           +---------------------------------+---------------+
|           | checkpoint_every_size           | B,K,M,G,T     |
|           +---------------------------------+---------------+
|           | max_flush_size_per_second       | B,K,M,G,T     |
|           +---------------------------------+---------------+
|           | sync_on_flush_size              | B,K,M,G,T     |
|           +---------------------------------+---------------+
|           | group_concat_max_len            | B,K,M,G,T     |
|           +---------------------------------+---------------+
|           | string_max_size_bytes           | B,K,M,G,T     |
|           +---------------------------------+---------------+
|           | backup_volume_max_size_bytes    | B,K,M,G,T     |
|           +---------------------------------+---------------+
|           | lock_timeout                    | ms, s, min, h |
|           +---------------------------------+---------------+
|           | checkpoint_interval             | ms, s, min, h |
|           +---------------------------------+---------------+
|           | sql_trace_slow                  | ms, s, min, h |
+-----------+---------------------------------+---------------+
| 브로커    | APPL_SERVER_MAX_SIZE_HARD_LIMIT | B, K, M, G    |
|           +---------------------------------+---------------+
|           | LONG_QUERY_TIME                 | ms, s, min, h |
|           +---------------------------------+---------------+
|           | LONG_TRANSACTION_TIME           | ms, s, min, h |
|           +---------------------------------+---------------+
|           | MAX_QUERY_TIMEOUT               | ms, s, min, h |
|           +---------------------------------+---------------+
|           | SESSION_TIMEOUT                 | ms, s, min, h |
|           +---------------------------------+---------------+
|           | SHARD_PROXY_LOG_MAX_SIZE        | B, K, M, G    |
|           +---------------------------------+---------------+
|           | SHARD_PROXY_TIMEOUT             | ms, s, min, h |
|           +---------------------------------+---------------+
|           | SQL_LOG_MAX_SIZE                | B, K, M, G    |
|           +---------------------------------+---------------+
|           | TIME_TO_KILL                    | ms, s, min, h |
+-----------+---------------------------------+---------------+

브로커의 ACCESS_MODE 중 PHRO 제거(CUBRIDSUS-11835)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

브로커의 ACCESS_MODE 중 PHRO를 제거했다. 
이와 함께, RW, RO, SO 모드에서 PREFERRED_HOSTS 파라미터의 설정이 가능하도록 수정했다. 

DBA 권한이 없는 사용자가 동적으로 변경 가능한 시스템 파라미터 중 "클라이언트" 또는 "클라이언트/서버" 파라미터를 변경 가능하도록 수정(CUBRIDSUS-10952)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

DBA 권한이 없는 사용자가 동적으로 변경 가능한 파라미터 중 "서버" 파라미터를 제외한 "클라이언트" 또는 "클라이언트/서버" 파라미터를 변경 가능하도록 수정했다. 
"클라이언트", "클라이언트/서버", "서버"의 적용 구분은 :ref:`cubrid-conf-default-parameters`\ 를 참고한다. 

.. code-block:: sql

    create user user1; 
    call login('user1','') on class db_user; 
    set system parameters 'intl_date_lang=en_US'; 

.. note:: 

    2008 R4.4 이하 버전에서 DBA 권한이 없는 사용자는 동적 변경 가능한 파라미터 중 "클라이언트" 파라미터만 변경이 가능하다. 
    9.1에서 DBA 권한이 없는 사용자는 모든 파라미터의 값을 변경할 수 없는 버그가 존재한다. 

기타
----

.. 4.4new

비동기 질의 기능 지원 중단(CUBRIDSUS-11265)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

CSQL 인터프리터에서 질의를 수행하거나 cci_execute 함수에 CCI_EXEC_ASYNC 플래그를 지정하여 질의를 수행할 때 중간 질의 결과를 전달받을 수 있는 비동기 질의 기능을 더 이상 지원하지 않는다. 

개선 및 오류 수정 
=================

성능 및 최적화
--------------

.. 4.4new

데이터가 매우 작은 상태에서 만든 플랜은 데이터가 증가한 경우 플랜을 다시 만들도록 수정(CUBRIDSUS-3382)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
같은 질의문에 대해 prepare를 재수행할 때 이전에 prepare 한 이후로 변경된 데이터 양이 임계치를 초과하면 질의 계획을 재작성하도록 수정했다. 
  
아래 질의에서 첫 번째 SELECT 문 수행 시 idx1 인덱스를 사용하지만, 두 번째 SELECT 문 수행 시 질의 계획을 재작성하여 idx2 인덱스를 활용하게 된다.
  
.. code-block:: sql 
  
    CREATE TABLE foo (a INT, b INT, c STRING); 
    INSERT INTO foo VALUES(1, 1, REPEAT('c', 3000)); 
    CREATE UNIQUE INDEX idx1 ON foo (a, c); 
    CREATE INDEX idx2 ON foo (a); 
      
    SELECT a, b FROM foo WHERE a = 1; -- 1st 
      
    INSERT INTO foo SELECT a+1, b, c FROM foo; 
    INSERT INTO foo SELECT a+2, b, c FROM foo; 
    INSERT INTO foo SELECT a+4, b, c FROM foo; 
    INSERT INTO foo SELECT a+8, b, c FROM foo; 
    INSERT INTO foo SELECT a+16, b, c FROM foo; 
    INSERT INTO foo SELECT a+32, b, c FROM foo; 
    INSERT INTO foo SELECT a+64, b, c FROM foo; 
    INSERT INTO foo SELECT a+128, b, c FROM foo; 
      
    SELECT a, b FROM foo WHERE a = 1; -- 2nd

.. 4.4new

인덱스 추가 시 해당 인덱스의 통계 정보만 갱신되도록 수정(CUBRIDSUS-10709)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

이전 버전에서는 인덱스 추가 시 기존의 모든 인덱스의 통계 정보가 갱신되면서 시스템의 부하로 작용했으나, 추가되는 인덱스의 통계 정보만 생성하도록 수정했다. 

ORDER BY ... LIMIT 구문 수행 시 인-메모리 정렬 최적화(CUBRIDSUS-10934)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ORDER BY ... LIMIT 조건을 만족하는 투플만 정렬 버퍼(sort buffer)에 저장하여 질의를 처리하는 인-메모리 정렬 최적화 기능을 추가했다. 

조인 질의에서 ORDER BY ... LIMIT 수행 시 SORT-LIMIT 최적화를 적용하여 질의 성능 개선(CUBRIDSUS-11050)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

조인 질의에서 ORDER BY ... LIMIT 절을 수행하는 경우, SORT-LIMIT 최적화를 적용하여 질의 성능을 개선했다. 
LIMIT 연산에 의해 외부 테이블(outer table)의 투플 개수를 줄이며, 전체를 정렬한 후 LIMIT 연산을 수행하는 것이 아니기 때문에 성능이 개선된다. 

.. code-block:: sql 

    CREATE TABLE t(i int PRIMARY KEY, j int, k int); 
    CREATE TABLE u(i int, j int, k int); 
    ALTER TABLE u ADD constraint fk_t_u_i FOREIGN KEY(i) REFERENCES t(i); 
    CREATE INDEX i_u_j ON u(j); 
    INSERT INTO t SELECT ROWNUM, ROWNUM, ROWNUM FROM _DB_CLASS a, _DB_CLASS b LIMIT 1000; 
    INSERT INTO u SELECT 1+(ROWNUM % 1000), RANDOM(1000), RANDOM(1000) FROM _DB_CLASS a, _DB_CLASS b, _DB_CLASS c LIMIT 5000; 
     
    SELECT /*+ RECOMPILE */ * FROM u, t WHERE u.i = t.i AND u.j > 10 ORDER BY u.j LIMIT 5; 

위의 SELECT 질의에 대한 질의 계획은 아래와 같이 출력되는데, "(sort limit)"가 출력되는 것을 확인할 수 있다. 

:: 

    Query plan: 

    temp(order by) 
        subplan: idx-join (inner join) 
                     outer: temp(sort limit) 
                                subplan: sscan 
                                             class: u node[0] 
                                             cost: 1 card 0 
                                cost: 1 card 0 
                     inner: iscan 
                                class: t node[1] 
                                index: pk_t_i term[0] 
                                cost: 6 card 1000 
                     cost: 7 card 0 
        sort: 2 asc 
        cost: 13 card 0 

이와 관련하여, sort-limit 질의 계획이 수행되지 않도록 지정하는 NO_SORT_LIMIT 힌트를 추가했다. 

.. code-block:: sql 

    SELECT /*+ NO_SORT_LIMIT */ * FROM t, u WHERE t.i = u.i ORDER BY u.j LIMIT 10; 
     
또한, "sort_limit_max_count" 시스템 파라미터를 추가했다. LIMIT 절의 행 개수가 "sort_limit_max_count" 파라미터에서 지정한 개수보다 크면 SORT-LIMIT 최적화를 수행하지 않는다. 

계층 질의문에서 START WITH 절에 부질의를 조건으로 부여하는 경우 인덱스를 사용하도록 수정(CUBRIDSUS-9613)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: sql 

    SELECT /*+ RECOMPILE use_idx*/ a, b 
    FROM foo
    START WITH a IN ( SELECT a FROM foo1 ) 
    CONNECT BY PRIOR a = b;

리소스
------

.. 4.4new

브로커의 SQL_LOG 모드를 동적으로 OFF로 변경했는데도 디스크 쓰기 작업이 계속되는 문제(CUBRIDSUS-10765) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

DB 운영 중에 브로커의 SQL_LOG 모드를 ON에서 OFF로 변경해도, SQL 로그로 인한 디스크 쓰기(IO write)가 없어지지 않는 문제를 해결했다. 
기존에는 SQL LOG 모드를 동적으로 OFF로 변경하면 디스크에 로그를 쓴 뒤, 파일 포인터를 되돌리는 방식으로 SQL 로그가 써지지 않는 것처럼 동작했으나 수정 후에는 실제로 디스크에 로그가 써지지 않도록 변경했다.

.. 4.4new

DB 볼륨이 매우 큰 DB의 백업 볼륨을 복구하는 경우 많은 메모리를 사용하는 문제(CUBRIDSUS-11843)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

DB 볼륨이 매우 큰 DB의 백업 볼륨을 복구하는 경우 많은 메모리를 사용하는 문제를 수정했다. 예를 들어, 수정 이전 버전에서 DB 페이지 크기가 16KB인 2.2TB 크기의 DB에 대해 수준(level) 0 백업 파일을 복구할 때 최소 8G의 메모리를 필요로 했으나, 수정 이후에는 해당 메모리를 필요로 하지 않는다. 

그러나, 수정 이후 버전에서도 수준 1 또는 수준 2 백업 파일을 복구할 때는 많은 메모리가 필요할 수 있다. 

"cubrid shard start" 명령 수행 시 공유 메모리가 요구량보다 훨씬 크게 할당되는 문제(CUBRIDSUS-10954)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
"cubrid shard start" 명령 수행 시 사용되는 공유 메모리가 요구량보다 훨씬 크게 할당되어 메모리가 낭비되는 문제를 수정했다.

참고로, 9.2부터 "cubrid shard" 명령은 "cubrid broker" 명령으로 통합되었다.

IN 절 조건이 OR로 연속되는 질의를 수행하면 많은 메모리를 소진하는 현상(CUBRIDSUS-11052)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: sql 
  
    SELECT table1 . "col_datetime_key" AS field1 
    FROM h AS table1 
           LEFT OUTER JOIN b AS table2 
                        ON table1 . col_int_key = table2 . pk 
    WHERE table2 . pk IN ( 6, 4, 6 ) 
            OR table2 . pk >= 3 
               AND table2 . pk < ( 3 + 5 ) 
            OR table2 . pk > 7 
               AND table2 . pk <= ( 0 + 5 ) 
               AND table2 . pk > 3 
               AND table2 . pk <= ( 3 + 1 ) 
            OR table2 . pk >= 3 
               AND table2 . pk < ( 3 + 5 ) 
               AND table2 . pk > 0 
    ORDER BY field1; 

안정성
------

.. 4.4new

인덱스를 스캔하는 질의가 종료되지 않는 현상(CUBRIDSUS-11945)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

인덱스를 스캔하는 질의가 종료되지 않으면서 일시적 임시(temporary temp) 볼륨이 무한히 증가하는 현상을 수정했다.

.. 4.4new

롤백 과정에서 인덱스 노드 삭제 도중 오류로 인해 서버 프로세스가 종료된 이후, 데이터베이스 볼륨 복구 과정에서 서버 프로세스가 비정상 종료하는 현상(CUBRIDSUS-10695)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. 4.4new

자동 커밋 OFF인 상태에서 테이블 생성, INSERT와 DELETE를 대량 반복, ROLLBACK을 수행한 상태에서 다시 테이블을 생성한 이후 특정 시점에 DB 볼륨이 비정상이 되는 문제(CUBRIDSUS-11479)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. 4.4new

드라이버 연결 후 DB가 재시작되면 이후 첫 번째 질의 수행에 실패하는 현상(CUBRIDSUS-10773) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 

드라이버 연결 후 DB가 재시작되면 이후 첫 번째 질의 수행에서 아래의 오류 메시지와 함께 실패하는 현상을 수정했다. 

:: 

    Server no longer responding.... Invalid argument 
    Your transaction has been aborted by the system due to server failure or mode change. 
    A database has not been restarted.
    
.. 4.4new

CAS의 종료와 시작이 자주 발생하는 상황에서 새로운 접속 요청이 30초 이상 걸리는 문제(CUBRIDSUS-10891) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cubrid_broker.conf의 MIN_NUM_APPL_SERVER 값이 MAX_NUM_APPL_SERVER 보다 작게 설정된 경우, 
접속하려는 드라이버 요청의 개수에 따라 CAS가 시작되거나 또는 종료될 수 있다. 
이렇게 CAS의 시작과 종료가 자주 발생하는 환경에서, 가끔 새로운 접속 요청이 30초 이상 걸리는 문제를 해결하였다.

.. 4.4new

Windows에서 DB 서버를 재시작할 때 멈춰있는(hang) 문제(CUBRIDSUS-12028)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Windows에서 DB 서버를 재시작할 때 멈춰있는 문제를 수정했다. 이 문제는 Windows XP 이하, Windows 2003 이하 버전에서만 발생하며, Windows 7, Windows 2008에서는 발생하지 않는다.

데이터베이스 볼륨이 조금씩 확장되도록 수정(CUBRIDSUS-10987)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

기존에는 질의 수행중 공간이 부족하면 시스템 파라미터인 db_volume_size 크기 만큼의 GENERIC 볼륨이 새로 추가되었고, 이 시간동안 질의 수행은 정지되었다. 

수정 이후에는 질의에서 요구되는 크기만 볼륨을 추가한 뒤 더 이상 볼륨을 확보하지 않고, 질의가 진행될 수 있도록 수정하였다. 
이후 다른 질의를 수행하면서 공간이 부족하면 추가된 볼륨에서 조금씩 공간을 확장한다. 
조금씩 확장되는 방식이므로 특정 순간에 볼륨의 크기는 db_volume_size 설정 값 보다 작을 수 있다. 
자동 추가된 GENERIC볼륨은 추가될 때의 db_volume_size 크기만큼 최대로 확장된다. 

TIME_TO_KILL 브로커 파라미터에 의해 종료되어야 할 CAS가 종료되지 않아 같은 ID를 가지는 CAS가 여러 개가 되는 현상(CUBRIDSUS-11857)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

여러 개의 응용 프로그램이 동시에 DML을 수행할 때 서버 프로세스가 비정상 종료될 수 있는 현상(CUBRIDSUS-11428)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

브로커에 의해 자동으로 시작된 CAS 가 일정 시간 내에 DB 접속에 성공 하지 못하면 브로커가 종료될 때 CAS가 같이 종료되지 못하는 현상(CUBRIDSUS-11772)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
브로커에 의해 자동으로 시작된 CAS 가 일정 시간 내에 DB 접속에 성공 하지 못하면 브로커가 공유 메모리 상의 CAS PID를 -1로, 상태를 IDLE로 설정하게 되고 이로 인해 브로커가 종료될 때 CAS가 같이 종료되지 못하는 현상을 수정했다. 

SQL
---

.. 4.4new

새로 생성한 테이블에 대해 커밋하지 않고 PREPARE한 이후, 배열/배치 실행 함수에서 INSERT를 반복 수행하면 실패하는 현상(CUBRIDSUS-10723) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. 4.4new

PREPARE 문에서 ELSE 절 없는 CASE .. WHEN 절 또는 DEFAULT 인자 없는 DECODE 함수의 마지막 인자가 호스트 변수일 때 오류가 발생하는 현상(CUBRIDSUS-10405)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

수정 이전 버전의 CASE .. WHEN 절에서 ELSE 절을 지정하지 않고 마지막 THEN 절의 인자가 호스트 변수이면 오류가 발생하는 현상을 수정했다. 
  
.. code-block:: sql 
  
    PREPARE st FROM 'select CASE ? WHEN 1 THEN 1 WHEN -1 THEN ? END'; 
    EXECUTE st USING -1, 3; 
  
    ERROR: Cannot coerce value of domain "integer" to domain "*NULL*". 
  
수정 이전 버전의 DECODE 함수에서 DEFAULT 인자가 없고 result 인자가 호스트 변수이면 오류가 발생하는 문제를 수정했다. 
  
.. code-block:: sql 
     
   PREPARE st FROM 'select DECODE (?, 1, 10,-1,?)'; 
   EXECUTE st USING -1,-10; 
   
   ERROR: Cannot coerce value of domain "integer" to domain "*NULL*". 
   
.. 4.4new

뷰를 포함하여 테이블 셋을 SELECT할 때 응용 프로그램이 비정상 종료되는 현상(CUBRIDSUS-11016) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: sql 

    CREATE TABLE t (a int, b int); 
    CREATE TABLE u (a int, b int); 
    CREATE VIEW vt AS SELECT * FROM t; 

    SELECT * FROM (vt, u);    

.. 4.4new

시스템 파라미터 max_plan_cache_entries의 값이 -1인 상태에서 INSERT 질의 수행 시 오류가 발생하면 같은 prepare문에 해당하는 질의는 계속해서 오류가 발생하는 문제(CUBRIDSUS-11038)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

시스템 파라미터 max_plan_cache_entries의 값이 -1(플랜 캐시 OFF)인 상태에서 첫 번째 INSERT 질의 수행 시 오류가 발생하면 같은 prepare문에 해당하는 질의는 바인딩되는 호스트 변수 값을 바꿔서 재수행해도 계속 같은 오류가 발생하는 문제를 수정했다. 

.. 4.4new

질의 계획 캐시를 사용하지 않는 질의문에서 사용되는 테이블 이름을 RENAME하고 기존 테이블을 DROP하는 경우 오류가 발생하는 문제(CUBRIDSUS-11039)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

시스템 파라미터 max_plan_cache_entries의 값을 -1로 설정하여 질의 계획 캐시를 사용하지 않거나 IN 절에 호스트 변수를 사용하는 경우와 같이 질의 계획 캐시를 사용하지 않는 질의문에서 사용되는 테이블 이름을 RENAME하고 기존 테이블을 DROP하는 경우, 해당 질의를 실행하면  "INTERNAL ERROR: Assertion 'false' failed" 오류가 발생하는 문제를 수정했다.

+----------------------------------------+-------------------------------------------+
| T1                                     |  T2                                       |
+========================================+===========================================+
| SELECT * FROM foo WHERE id IN (?, ?);  |                                           |
+----------------------------------------+-------------------------------------------+
|                                        | CREATE TABLE foo_n AS SELECT * FROM foo;  |
|                                        +-------------------------------------------+
|                                        | RENAME foo AS foo_drop;                   |
|                                        +-------------------------------------------+
|                                        | RENAME foo_n AS foo;                      |
|                                        +-------------------------------------------+
|                                        | DROP TABLE foo_drop;                      |
+----------------------------------------+-------------------------------------------+
| SELECT * FROM foo WHERE id IN (?, ?);  |                                           |
+----------------------------------------+-------------------------------------------+

.. 4.4new

플랜 캐시를 OFF하고 특정의 다중 질의문을 수행하면 응용 프로그램이 비정상 종료하는 현상(CUBRIDSUS-11055)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cubrid.conf의 max_plan_cache_entries 값을 -1로 설정하여 플랜 캐시를 OFF하고 다중 질의문을 수행하면 응용 프로그램이 비정상 종료하는 현상을 수정했다.

.. 4.4new

타입 형 변환이 필요한 비교 구문이 있는 질의 수행을 시도하면 응용 프로그램이 비정상 종료하는 현상(CUBRIDSUS-11064)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
타입 형 변환이 필요한 비교 구문이 있는 질의 수행을 시도하면 응용 프로그램이 비정상 종료하는 현상을 수정했다. 
수정 이전 버전에서 아래의 예처럼 SELECT LIST에 함수가 사용되고 LIMIT 절이 사용되는 경우 발생했으며, 둘 중 어느 하나가 없는 경우 정상적으로 오류 메시지를 출력했다. 
  
.. code-block:: sql 
  
    SELECT MIN(col_int) 
    FROM cc 
    WHERE cc. col_int_key >= 'vf' 
    LIMIT 1;

.. 4.4new

다중 칼럼 인덱스의 어떤 칼럼에 DESC가 있고, 다음 칼럼의 값이 NULL인 경우 해당 인덱스를 스캔하는 SELECT 문 수행 시 잘못된 결과를 출력하는 현상(CUBRIDSUS-11354)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: sql 
  
    CREATE TABLE foo ( a integer primary key, b integer, c integer, d datetime ); 
    CREATE INDEX foo_a_b_d_c on foo ( a , b desc , c ); 
    INSERT INTO foo VALUES ( 1, 3, NULL, SYSDATETIME ); 
    INSERT INTO foo VALUES ( 2, 3, NULL, SYSDATETIME ); 
    INSERT INTO foo VALUES ( 3, 3, 1, SYSDATETIME ); 
  
    SELECT * FROM foo WHERE a = 1 AND b > 3 ; 
 
::
 
    -- In the previous version, above query shows a wrong result. 
  
                a            b            c  d
    ======================================================================
                1            3         NULL  12:23:56.832 PM 05/30/2013

.. 4.4new

조인 계층 질의가 SELECT 리스트에 상관 부질의(correlated subquery)를 포함하고 있으면 잘못된 결과를 출력하는 현상(CUBRIDSUS-11658)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: sql 

    CREATE TABLE t1(i INT); 
    CREATE TABLE t2(i INT); 
    INSERT t1 VALUES (1); 
    INSERT t2 VALUES (1),(2); 

    SELECT (SELECT COUNT(*) FROM t1 WHERE t1.i=t2.i) FROM t1,t2 START WITH t2.i=1 CONNECT BY NOCYCLE 1=1; 

수정 이전 버전에서는 잘못된 결과를 출력한다. 

:: 

    1 
    1 

수정 이후 버전부터는 올바른 결과를 출력한다. 

:: 

    1 
    0 

.. 4.4new

CHAR 타입 칼럼이 연이어 정의된 테이블의 첫번째 칼럼을 CONV 함수에 입력하면 잘못된 결과를 반환하는 현상(CUBRIDSUS-11824)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

CHAR 타입 칼럼이 연이어 정의된 테이블의 첫번째 칼럼을 CONV 함수에 입력하면 두번째 칼럼에 대한 CONV 값을 반환하는 현상을 수정했다. 

.. code-block:: sql 

    CREATE TABLE tbl (h1 CHAR(1), p1 CHAR(4)); 
    INSERT INTO tbl (h1, p1) VALUES ('0', '0001'); 
    SELECT CONV (h1, 16, 10) from tbl; 
     
    1 


.. 4.4new

INSERT ... SELECT 문에서 SELECT 리스트와 INSERT 리스트의 타입이 달라 타입 변환이 발생하고, SELECT 문에 ORDER BY 절이 존재할 때 INSERT되는 순서가 달라지는 현상(CUBRIDSUS-12031)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
INSERT ... SELECT 문에서 SELECT 리스트와 INSERT 리스트의 타입이 달라 타입 변환이 발생하고, SELECT 문에 ORDER BY 절이 존재할 때 INSERT되는 순서가 달라지는 현상을 수정했다.
 
INSERT 리스트 칼럼 중 AUTO_INCREMENT 칼럼이 존재하는 경우 INSERT되는 순서가 중요하게 된다.
 
.. code-block:: sql
 
    CREATE TABLE t1 (id INT AUTO_INCREMENT, a CHAR(5), b CHAR(5), c INT);
    CREATE TABLE t2 (a CHAR(30), b CHAR(30), c INT);
    INSERT INTO t2 VALUES ('000000001', '5', 1),('000000002','4',2),('000000003','3',3),('000000004','2',4),('000000005','1',5);
    INSERT INTO t1(a,b,c) SELECT * FROM t2 ORDER BY a, b DESC;
    SELECT * FROM t1;

플랜 캐시를 OFF하고 INSERT ... ON DUPLICATE KEY UPDATE 문을 수행하면 응용 프로그램이 비정상 종료하는 현상(CUBRIDSUS-11057)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cubrid.conf의 max_plan_cache_entries 값을 -1로 설정하여 플랜 캐시를 OFF하고 INSERT ... ON DUPLICATE KEY UPDATE 질의문을 수행하면 응용 프로그램이 비정상 종료하는 현상을 수정했다. 
  
.. code-block:: sql 
  
    INSERT INTO tbl2 (b, c) SELECT a, s FROM tbl1 ON DUPLICATE KEY UPDATE a = a-1, c = c-1; 

DELETE 문의 조건에 255바이트 이상의 문자열이 존재하는 경우 응용 프로그램이 비정상 종료되는 현상(CUBRIDSUS-11067)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

이 문제는 9.1에서만 발생했다. 
  
.. code-block:: sql 
  
    DELETE FROM "i" WHERE col_varchar_255 != 'bqhwvuzchakfjbhzlkqkxahligypiuccqmdrurhppmkehewmsadxgktulpodxbartfqudmhqzzrfwqaspshzhrvzknmcitozkirzbdaaepvaoveblzqoptijhnygyhkhqzkggvhpznfdxlffvstcjgkhsgpsqjuukgejpzkbkxcbzysrwirkzhsuwclmsdxcjmnrxhzntknbfqcuatiehqdiahlppjhzjcjmvevthpczvapskueruuwndyyhcxw'


ALTER 문으로 ENUM 원소 변경 이후 기존 테이블에 있던 값들이 새로 변경한 ENUM 타입에 없는 원소이면 공백 문자열로 매핑되도록 수정(CUBRIDSUS-10138) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ALTER 문으로 ENUM 원소 변경 이후 기존 테이블에 있던 값들이 새로 변경한 ENUM 타입에 없는 원소이면 새로 지정한 원소의 첫번째 값으로 매핑되었으나, 공백 문자열('')로 매핑되도록 수정했다. 

.. code-block:: sql 

    CREATE TABLE t2 (a ENUM('TRUE','FALSE','NONE')); 
    INSERT INTO t2 VALUES ('NONE'); 
    ALTER TABLE t2 MODIFY a ENUM('YES', 'NO'); 
    SELECT * FROM t2; 
     
    '' 

자동커밋이 OFF인 상태에서 PREPARE한 statement를 실행하고 해당 테이블을 DROP/CREATE 후 다시 해당 statement를 실행하면 CAS 프로세스가 비정상 종료하는 현상(CUBRIDSUS-11876)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
.. code-block:: java
  
    conn.setAutoCommit(false); 

    stmt = conn.createStatement(); 
    stmt.executeUpdate(sql); 
    conn.commit(); 

    p1 = conn.prepareStatement("SELECT * FROM t;"); 
    p1.executeQuery(); 
    stmt.executeUpdate("DROP TABLE t;"); 
    stmt.executeUpdate("CREATE TABLE t;"); 
    p1.executeQuery();
   
INSERT 문에서 SYS_DATETIME, SYS_TIME, SYS_TIMESTAMP 사용 시 서머 타임이 고려되지 않는 문제(CUBRIDSUS-11322)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

INSERT 문에서 SYS_DATETIME, SYS_TIME, SYS_TIMESTAMP을 사용하면 서머 타임(summer time, day light saving time)이 고려되지 않은 값이 입력되는 문제를 수정했다. 
서머 타임을 적용하지 않는 나라에서는 해당 문제가 발생하지 않는다.

상관 부질의 밖의 칼럼과 안의 칼럼을 포함하는 연산식에 집계 함수 수행 시 오류가 발생하는 현상(CUBRIDSUS-10400)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

상관 부질의 밖의 칼럼과 안의 칼럼을 포함하는 연산식에 집계 함수 수행 시 오류가 발생하는 현상을 수정했다. 

.. code-block:: sql 

    CREATE TABLE t1 (a INT , b INT , c INT); 
    INSERT INTO t1 (a, b) VALUES (3, 3), (2, 2), (3, 3), (2, 2), (3, 3), (4, 4); 
    SELECT (SELECT SUM(outr.a + innr.a) FROM t1 AS innr LIMIT 1) AS tt FROM t1 AS outr; 

    // 수정 이전 버전에서는 아래의 오류가 발생한다. 
    ERROR: System error (generate xasl) in ../../src/parser/xasl_generation.c (line: 16294)
    
뷰에서 상수를 ENUM 타입으로 변경하게 되는 경우 발생하는 오류(CUBRIDSUS-10852)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

뷰에서 상수를 ENUM 타입으로 변경하게 되는 경우, 예를 들어 ENUM 타입 칼럼에 DEFAULT 함수를 사용한 뷰에 대해 질의 수행 시 발생하는 오류를 수정했다. 

.. code-block:: sql 

    CREATE TABLE t1(a ENUM('a', 'b', 'c') DEFAULT 'a' ); 
    INSERT INTO t1 VALUES (1), (2), (3); 
    CREATE VIEW v1 AS SELECT DEFAULT(a) col FROM t1; 
    SELECT * FROM v1; 

::
    
    // 수정 이전 버전에서는 아래의 오류가 발생한다. 
    ERROR: System error (type check) in ../../src/parser/type_checking.c 

ENUM 타입이 CAST 함수를 통해 정의될 때 원소가 중복되는 것을 허용하는 문제(CUBRIDSUS-10854)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ENUM 타입이 CAST 함수를 통해 정의될 때 원소가 중복되는 것을 허용하는 문제를 수정했다. 
     
.. code-block:: sql 

    CREATE TABLE t1(a INT); 
    INSERT INTO t1 VALUES (1), (2), (3); 

    CREATE TABLE t2 AS SELECT CAST(a AS ENUM('a', 'b', 'c', 'a', 'a', 'a')) col, a FROM t1; 

    // 수정 이후 ENUM 타입에서 원소의 중복을 허용하지 않는다. 
    ERROR: before ' , 'a', 'a')) col, a from t1; ' 
    Duplicate values in enum type. 

절대 경로를 포함한 LOB 파일 이름이 128보다 클 때 SELECT 문에서 LOB 파일 경로를 출력하면 128자 이하로 출력하는 문제(CUBRIDSUS-10856)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

절대 경로를 포함한 LOB 파일(LOB 타입의 실제 데이터를 저장한 파일) 이름이 128보다 클 때 SELECT 문에서 LOB 파일 경로를 출력하면 128자까지만 출력되는 문제를 수정했다. 
  
.. code-block:: sql 
  
    CREATE TABLE clob_tbl(c1 clob); 
    SELECT * FROM clob_tbl;

여러 개의 왼쪽 외부 조인 중 재작성된 내부 조인의 일부가 잘못되어 잘못된 질의 결과가 출력되는 현상(CUBRIDSUS-11129)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: sql 

    SELECT * FROM k AS table1 
    LEFT JOIN i AS table2 ON table1.col1_key = table2.col1 
    LEFT JOIN h AS table3 ON table2.col3 = table3.col3_key 
    LEFT JOIN i AS table4 ON table2.col2_key = table4.col2_key 
    WHERE table1.pk <= table4.col_int; 

위 질의 중 WHERE 조건에 해당하는 값은 NULL인 경우가 없으므로 table4는 INNER JOIN으로 변환될 수 있는데, 질의 변환 과정에서 조건을 잘못 처리하여 질의 결과가 잘못 출력되는 문제를 수정했다.

INSERT ... SELECT ORDERBY_NUM() ... 구문 수행 시 잘못된 결과가 입력되는 현상(CUBRIDSUS-11510)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
ORDERBY_NUM()을 SELECT 리스트에 명시하여 INSERT 문에서 사용될 때 대상 칼럼의 타입이 BIGINT가 아닌 경우 해당 칼럼 값이 모두 0이 되는 현상을 수정했다. 

수정 이전에는 아래와 같이 INSERT 문을 수행하면 rank 칼럼의 값이 모두 0이 되었다. 
  
.. code-block:: sql 
  
    CREATE TABLE tbl(RANK int, id VARCHAR(10), SCORE int); 
    INSERT INTO tbl(rank, id, score) SELECT ORDERBY_NUM() AS rank, id, score FROM (SELECT 'A' AS id, 1 AS score UNION ALL SELECT 'B' AS id, 10 AS score) A ORDER BY score DESC; 
    SELECT * FROM tbl; 

자동 커밋 OFF인 상태에서 AUTO_INCREMENT 칼럼이 있는 테이블을 생성하고 테이블을 RENAME한 후 INSERT 시 오류가 발생하는 현상(CUBRIDSUS-11689)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

자동 커밋 OFF인 상태에서 AUTO_INCREMENT 칼럼이 있는 테이블을 생성하고 테이블을 RENAME한 후 INSERT하면 AUTO_INCREMENT 칼럼의 값이 증가하지 않으면서 고유 키 위반(unique constraint violations) 오류가 발생하는 현상을 수정했다. 

.. code-block:: sql 

    CREATE TABLE tbl ( a VARCHAR(2), b INT AUTO_INCREMENT PRIMARY KEY); 
    INSERT INTO tbl (a) VALUES('1'); 
    INSERT INTO tbl (a) VALUES('2'); 
    INSERT INTO tbl (a) VALUES('3'); 

    ALTER TABLE tbl RENAME tbl_old; 

    INSERT INTO t1_old (a) VALUES('4');

MERGE 문에서 인라인 뷰로 지정한 SELECT 리스트에 호스트 변수를 바인딩하는 경우 일부 값이 NULL이 되는 문제(CUBRIDSUS-11921)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: sql 

    CREATE TABLE w(col1 VARCHAR(20), col2 VARCHAR(20), col3 VARCHAR(20)); 
    CREATE TABLE t(col1 VARCHAR(20), col2 VARCHAR(20), col3 VARCHAR(20)); 
    INSERT w VALUES('a','b','c'); 

    PREPARE st FROM 'MERGE INTO T USING ( 
        SELECT ? c1, ? c2, ? c3 FROM w) d ON t.col1 = d.c1 
        WHEN MATCHED THEN UPDATE SET col1 = 0 
        WHEN NOT MATCHED THEN INSERT VALUES (d.c1, d.c2, d.c3)'; 
    EXECUTE st USING 'x', 'y', 'z'; 
    SELECT * FROM t; 

:: 
     
      col1 col2 col3 
    ==================================================================
      'x' NULL NULL 

MIN/MAX SQL 함수를 포함하여 GROUP BY ... WITH ROLLUP 문 수행 시 잘못된 결과를 출력하는 현상(CUBRIDSUS-11478)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: sql 
  
    CREATE TABLE test(math INT, grade INT, class_no INT); 
    INSERT INTO test VALUES(60, 1, 1), (70, 2, 2); 
    SELECT MIN(math), grade, class_no FROM test GROUP BY grade, class_no WITH ROLLUP; 

UPDATE 트리거가 존재하는 테이블에 호스트 변수가 포함된 UPDATE 문을 실행하면 데이터가 변경되지 않거나 잘못된 데이터를 변경하는 현상(CUBRIDSUS-11918)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

뷰가 포함된 SQL문에 대해 prepare 수행 도중 인터럽트를 받으면 가끔씩 CAS가 비정상 종료하는 현상(CUBRIDSUS-10846) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

다국어
------

서로 다른 로캘 사이에 공유되는 콜레이션 정보는 common_colaltions.xml에서 공유되도록 수정(CUBRIDSUS-10160)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


테이블의 콜레이션이 분할 조건에 적용되지 않는 현상(CUBRIDSUS-11794)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

테이블의 콜레이션이 분할 조건에 적용되지 않는 현상을 수정했다. 

다음 예에서 데이터베이스의 문자셋이 en_US.utf8일 때, 수정 이전 버전에서는 테이블의 콜레이션인 utf8_de_exp_ai_ci인 경우 분할 조건인 _utf8'AEäÄ', _utf8'ääÄ', _utf8'ÄÄAE'이 모두 같음에도 불구하고 분할 테이블이 정상 생성되는 오류가 존재했다. 

.. code-block:: sql 
  
    CREATE TABLE t3 (a CHAR(10), b int) collate utf8_de_exp_ai_ci 
    PARTITION BY LIST (a) ( 
        PARTITION a1 VALUES IN (_utf8'AEäÄ'), 
        PARTITION a2 VALUES IN (_utf8'ääÄ'), 
        PARTITION a3 VALUES IN (_utf8'ÄÄAE') 
    ); 

시스템 문자셋과 다른 멀티바이트 문자셋 데이터를 숫자와 비교 연산할 수 있도록 수정(CUBRIDSUS-10589)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

시스템 문자셋과 다른 멀티바이트 문자셋 데이터이더라도 숫자와 비교 연산을 수행하면 해당 문자 데이터를 숫자로 변환하여 비교할 수 있도록 수정했다. 

.. code-block:: sql 

    -- CUBRID charset=ko_KR.euckr 
    CREATE TABLE t1(a STRING COLLATE utf8_en_cs); 
    SELECT a > 100 FROM t1; 

수정 이후 위의 질의는 정상 수행된다. 
하지만 아래 질의는 '100'을 시스템 문자셋인 _euckr'100'으로 인식하여 문자열 간 비교 연산이 수행되므로, 에러가 발생한다. 

.. code-block:: sql 
    
    -- CUBRID charset=ko_KR.euckr 
    CREATE TABLE t1(a STRING COLLATE utf8_en_cs); 
    SELECT a> '100' FROM t1; 
     
    ERROR: before ' from t1; ' 
    '>' requires arguments with compatible collations. 

멀티바이트 문자셋으로 매우 긴 길이의 식별자 이름 지정 시 입력한 이름이 달라질 수 있는 문제(CUBRIDSUS-10641) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 

멀티바이트 문자셋으로 매우 긴 길이의 식별자(테이블, 칼럼, 인덱스 등) 이름 지정 시 UMR(Uninitialized Memory Read) 오류로 인해 입력한 이름과 달라질 수 있는 문제를 수정했다. 또한, 기본 키의 이름 등 자동으로 생성되는 제약조건(constraint)이 식별자의 최대 길이를 넘지 않도록 수정했다. 

CUBRID 로캘이 en_US.iso88591인 데이터베이스에서 UTF-8 또는 EUC-KR 문자에 MD5 함수 수행 시 실패하는 현상(CUBRIDSUS-10775) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: sql 
 
    -- CUBRID charset=en_US.iso88591

    SET NAMES utf8; 
    CREATE TABLE t (c CHAR(128) CHARSET utf8); 
    INSERT INTO t VALUES ('a'); 

    SELECT MD5(c) FROM t; 

    ERROR: No error message available.

"SET NAMES" 문이 응용 프로그램의 문자셋과 콜레이션을 변경할 수 있도록 수정하고, 응용 프로그램의 콜레이션 이름을 저장하는 시스템 파라미터 추가(CUBRIDSUS-10952)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

"SET NAMES" 문이 응용 프로그램의 문자셋과 콜레이션을 변경할 수 있도록 수정하고, 응용 프로그램의 콜레이션 이름을 저장하는 시스템 파라미터인 intl_collation을 추가했다. 수정 이후 "SET NAMES" 문으로 콜레이션을 변경하는 경우와 intl_collation 시스템 파라미터를 변경하는 경우는 같은 동작을 수행한다. 

아래의 두 문장은 같은 동작을 수행한다. 

.. code-block:: sql 

    SET NAMES utf8 COLLATE utf8_bin; 
    SET SYSTEM PARAMETER intl_collation=utf8_bin; 
        
칼럼 정의 시 문자셋 지정자는 있는데 콜레이션 지정자가 없으면 콜레이션은 칼럼에 대한 문자셋의 기본 콜레이션이 되도록 수정(CUBRIDSUS-11361)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

칼럼 정의 시 문자셋 지정자는 있는데 콜레이션 지정자가 없으면, 수정 이전 버전에서는 테이블의 콜레이션이 칼럼 콜레이션이 되었으나, 
9.2 버전부터는 해당 칼럼에 대한 문자셋의 기본 콜레이션이 되도록 수정했다. 

.. code-block:: sql 

    CREATE TABLE tbl (col STRING CHARSET utf8) COLLATE utf8_en_ci; 

위의 질의문에서 칼럼 col의 콜레이션은 수정 이전 버전에서는 테이블의 콜레이션과 같은 utf8_en_ci가 되며, 9.2 버전부터는 해당 칼럼에 대한 문자셋의 기본 콜레이션인 utf8_bin이 된다. 

UNION 문 수행 시 SELECT 리스트끼리 콜레이션 호환 여부를 검사하도록 수정(CUBRIDSUS-11324)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

UNION 문 수행 시 SELECT 리스트끼리 콜레이션 호환 여부를 검사한 후 질의를 수행하도록 수정했다. 

아래 UNION 문의 SELECT 리스트는 CONCAT(s1, ''), CONCAT(s2, ''), s3이므로 s3가 기준 콜레이션이 되고, 
표현식 CONCAT(s1, '')과 CONCAT(s2, '')는 s3 칼럼의 콜레이션으로 변환된다. 

.. code-block:: sql 

    CREATE TABLE t1 (s1 STRING COLLATE utf8_en_ci); 
    CREATE TABLE t2 (s2 STRING COLLATE utf8_en_cs); 
    CREATE TABLE t3 (s3 STRING COLLATE utf8_tr_cs); 

    SELECT CONCAT(s1,'') FROM t1 
    UNION 
    SELECT CONCAT(s2,'') FROM t2 
    UNION 
    SELECT s3 FROM t3; 

아래와 같이 기준 콜레이션을 정할 수 없는 질의는 오류를 반환한다. 

.. code-block:: sql 

    SELECT s1 FROM t1 
    UNION 
    SELECT s2 FROM t2 
    UNION 
    SELECT s3 FROM t3; 

컬렉션 타입의 원소에 대한 콜레이션 추론 오류(CUBRIDSUS-12078)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

호스트 변수인 컬렉션 타입의 원소에 대한 콜레이션 변경으로 인해 타입(domain)이 변경되지 않도록 수정했다.

.. code-block:: sql

    //  utf8로 DB 생성: cubrid createdb en_US.utf8
    
    //  문자셋 변경으로 인해 콜레이션이 변경됨(utf8_bin -> iso88591_bin)
    SET NAMES iso88591;
    CREATE TABLE t1(i int, e1 enum ('Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', '01/01/2012'));
    INSERT INTO T1 VALUES (1, 1), (3, 3), (2, 'Monday'), (6, 'Friday'), (7, 7), (4, 4), (5, 5), (8, 8);
    
    PREPARE X FROM 'select /*+ recompile */ * from t1 where e1 < all {''T'', ?, ''Sunday'', ?}  order by i';

    EXECUTE x USING 50, 3;

::

    // 수정 이전
    8 '01/01/2012'

    // 수정 이후
    ERROR: Domain "character varying" is not compatible with domain "integer".

호스트 변수 인자와 클라이언트 문자셋이 시스템 문자셋과 다를 때 발생하는 콜레이션 추론 오류(CUBRIDSUS-12111)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

아래 예에서 시스템 문자셋은 UTF-8인데 비해 클라이언트의 문자셋은 ISO-88591이며, 수정 이전 버전에서 오류가 발생한다.

.. code-block:: sql

    //create db with en_US.utf8
    SET NAMES iso88591;
    PREPARE s FROM 'SELECT FIELD (?, ?, ?, ?) INTO :result';

::
    
    ERROR: Semantic: before '  into :result'
    'field ' requires arguments with compatible collations. select  field( ?:0 ,  ?:1 ,  ?:2 ,  ?:3 ) into :result        
    
콜레이션 추론 규칙에서 숫자나 날짜 타입 상수는 콜레이션 변환도가 가장 크도록 수정(CUBRIDSUS-12082)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

숫자나 날짜 타입 상수는 항상 상대방 문자열의 콜레이션으로 변환되도록 수정했다.

::

    $ cubrid createdb en_US.iso88591
    
.. code-block:: sql

    SET NAMES utf8;

    CREATE TABLE test_ro (id INT NOT NULL, name VARCHAR(20) collate utf8_ro_cs);
    INSERT INTO test_ro VALUES (4,CONCAT('ț',123));
    SELECT * FROM test_ro;

수정 이전 버전에서 숫자나 날짜는 DB 생성 시 결정된 콜레이션을 따른다. 따라서 위의 예에서 CONCAT('ț',123)를 수행하는 경우 'ț'의 콜레이션은 utf8_bin, '123'의 콜레이션은 iso88591_bin이 되고, 그 결과 비정상적인 문자열을 반환한다.

멀티바이트 문자셋을 단일바이트 문자셋(ISO88591)으로 변환할 때 문자열 변환 함수의 오동작 수정(CUBRIDSUS-12127)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

문자열 변환 함수가 멀티바이트 문자셋을 단일바이트 문자셋으로 변환할 때 결과 값에 결과 자리수까지 공백을 붙이도록 수정했다. 따라서 아래 Q1과 Q2는 같은 결과를 출력한다.

.. code-block:: sql

    // create DB with en_US.iso88591

    SET NAMES utf8;
    CREATE TABLE tbl (a CHAR(10));
    CREATE INDEX i_t2_a ON tbl(a);
    INSERT INTO tbl VALUES ('1234567890');
    
    PREPARE STMT FROM 'SELECT  a FROM tbl WHERE a LIKE CAST((?+''%'') AS CHAR(11))'
    EXECUTE STMT USING '123456789';  -- Q1

    SELECT a FROM tbl WHERE a LIKE '123456789% ';   -- Q2

멀티바이트 문자셋끼리 문자셋 변환이 가능하도록 수정(CUBRIDSUS-10753) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 

UTF-8에서 EUC-KR로, EUC-KR에서 UTF-8로, 또는 ISO8859-1에서 EUC-KR로 문자셋 변환이 가능하도록 수정했다. 
 
.. code-block:: sql 
 
    SELECT CAST(iso_str AS STRING CHARSET utf8) FROM t_iso; 

뷰, 분할 표현식, 함수 인덱스 표현식, 필터 인덱스 표현식에 대해 출력되는 질의의 문자열에 CHARSET과 COLLATE 수정자를 포함하도록 수정(CUBRIDSUS-12195)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

DB의 문자셋/콜레이션과 다른 문자셋/콜레이션을 가진 뷰, 분할 표현식, 함수 인덱스 표현식, 필터 인덱스 표현식에 대해 질의를 수행하면 오류가 발생하는 문제를 수정했다.

::

    ERROR: Required character set and collation are not compatible.

수정 이후 위의 오류는 발생하지 않는다. 예를 들어 "CREATE INDEX i_a on t(a) WHERE LOWER(a)<'John';"에 대해 출력되는 필터 인덱스 표현식은 

.. code-block:: sql
 

    LOWER(a)<'John' 

에서

.. code-block:: sql

    LOWER(a)<_iso88591'John' collate iso88591_bin

로 바뀌었다.

EUC-KR 문자셋의 고정 길이 CHAR 타입 문자열로 해시 분할하여 분할 테이블을 생성할 때 잘못 분할되는 문제(CUBRIDSUS-12220)  
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: sql

    -- EUC-KR로 DB 생성
    
    CREATE TABLE hash_test
    (
        id INT NOT NULL PRIMARY KEY ,
        test_char char(50)
    )
    PARTITION BY HASH(test_char)
    PARTITIONS 4;
    INSERT INTO hash_test values(2,'bbb');
    
    UPDATE hash_test set test_char = 'ddd' where test_char = 'bbb';    
    -- 수정 이전 버전에서는 위의 질의를 수행해도 UPDATE되는 레코드가 없다.
    
    0 row affected.
    
분할 테이블에 대한 ALTER 문을 수행하면서 분할 키 타입의 콜레이션이 변환되는 경우 응용 프로그램이 비정상 종료되는 현상(CUBRIDSUS-12179)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 

.. code-block:: sql 

    // en_US.utf8로 DB 생성 
    // 콜레이션 변경 

    SET NAMES utf8 COLLATE utf8_gen; 
    CREATE TABLE list_test(id INT NOT NULL PRIMARY KEY , 
                            test_int INT, 
                            test_char CHAR(50), 
                            test_varchar VARCHAR(2000), 
                            test_datetime TIMESTAMP) 
    PARTITION BY LIST (test_char) ( 
    PARTITION P0 VALUES IN ('10'), 
    PARTITION P1 VALUES IN ('20')); 

    ALTER TABLE list_test ADD PARTITION ( 
    PARTITION P1024 VALUES IN ('20000')); 

분할 테이블에서 콜레이션 변경 후 필터링 인덱스 생성에 실패하는 현상(CUBRIDSUS-12173)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: sql 

    // en_US.utf8로 DB 생성 
    // 콜레이션 변경 
    SET NAMES utf8 collate utf8_gen; 
    CREATE TABLE part 
    ( 
        id INTEGER UNIQUE, 
        textlabel VARCHAR(255), 
        description VARCHAR(4096) 
    ) 
    PARTITION BY RANGE (ID) 
    ( 
        PARTITION p1 VALUES LESS THAN (10), 
        PARTITION p2 VALUES LESS THAN (20), 
        PARTITION p3 VALUES LESS THAN (30), 
        PARTITION p4 VALUES LESS THAN MAXVALUE 
    ); 

    CREATE INDEX idx_part ON part(id, textlabel) WHERE textlabel LIKE '%$_%' ESCAPE '$'; 

    -- 수정 이전 버전에서는 아래의 오류를 출력한다. 
    ERROR: No error message available. 

DB 생성 시 명시한 문자셋과 다른 문자셋으로 변경한 후 ENUM 타입을 포함하는 질의문 수행에 실패하는 현상(CUBRIDSUS-12159)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: sql 

    // create DB with en_US.iso88591 
    // change charset 
    SET NAMES utf8; 
    CREATE TABLE tbl ( 
        A ENUM('你', '我', '他') 
    ); 
    CREATE INDEX IDX ON tbl(LOG10(A)); 
    INSERT INTO tbl VALUES(2); 
    SELECT * FROM tbl; 
    INSERT INTO tbl VALUES ('我'), ('你'), (2), ('他'); 

DB 생성 시 명시한 문자셋과 다른 문자셋으로 변경한 후 CREATE TABLE ... LIKE 문 수행에 실패하는 현상(CUBRIDSUS-12142)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: sql 

    // en_US.iso88591로 DB 생성 
    SET NAMES utf8 COLLATE utf8_gen; 
    CREATE TABLE t1(a CHAR(1200), b VARCHAR(1200)); 
    CREATE INDEX i_t1_b on t1(b) WHERE b='1234567890'; 
     
    CREATE TABLE t2 LIKE t1; 

    // 수정 이전 버전에서 다음의 에러가 발생한다. 
    ERROR: In line 1, column 45 before ' utf8_bin' 
    Syntax error: unexpected 'collate', expecting SELECT or VALUE or VALUES or '(' 

CSQL -S 옵션으로 실행해서 intl_date_lang 시스템 파라미터 값을 변경할 때 TO_CHAR 함수가 잘못된 결과를 출력하는 현상(CUBRIDSUS-12135)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: sql 

    // de_DE.utf8로 DB 생성 
    // -S 옵션으로 CSQL 실행 
     
    // intl_date_lang 시스템 파라미터 값 변경 
    SET SYSTEM PARAMETERS 'intl_date_lang=ko_KR';
     
    // 수정 이전 버전에서는 de_DE 포맷으로 출력된다. 
    SELECT TO_CHAR(datetime'03:36:16 pm 2013-04-12', 'HH12:MI:SS.FF pm, YYYY-MM-DD-DAY'); 
    '03:36:16.000 nachm., 2013-04-12-FREITAG ' 
    
TO_CHAR 함수에서 호스트 변수로 SELECT를 수행할 때 잘못된 결과를 출력하는 현상(CUBRIDSUS-12130)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: sql 

    PREPARE st FROM 'SELECT TO_CHAR(?)'; 
    EXECUTE st USING 'a'; 
    // 수정 이전 버전에서는 공백 문자를 출력한다. 
    '' 

COERCIBILITY 함수의 인자로 상수를 포함하는 표현식이 입력될 때 표현식의 변환도가 아닌 상수의 변환도를 출력하는 문제(CUBRIDSUS-12278) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 

.. code-block:: sql 

    SELECT COERCIBILITY( IFNULL(date '2010-01-01', _euckr'a'));

다중 바이트 문자셋에서 "alter_table_change_type_strict=yes"일 때 칼럼 타입의 자리수를 변경하려고 하면 실패하는 문제(CUBRIDSUS-12268) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 

ISO-88591을 제외한 EUC-KR, UTF-8 문자셋에서 "alter_table_change_type_strict=yes"일 때 칼럼 타입의 자리수를 변경하려고 하면 실패하는 문제를 수정했다. 

.. code-block:: sql 

    CREATE TABLE t2 ( s1 CHAR(2) CHARSET utf8); 
    INSERT INTO t2 VALUES (REPEAT(CHR(15052985 USING utf8),2)); 
    SET SYSTEM PARAMETERS 'alter_table_change_type_strict=yes'; 
     
    ALTER TABLE t2 CHANGE s1 s CHAR(3) CHARSET utf8; 

수정 이전 버전에서 위의 ALTER 문을 수행하여 자리수만 바꾸려고 시도해도 아래의 오류가 발생한다. 

:: 

    ERROR: ALTER TABLE .. CHANGE : changing to new domain : cast failed, current configuration doesn't allow truncation or overflow. 
    
분할(Partitioning)
------------------

분할 테이블에서 XOR 연산 수행 시 잘못된 결과를 출력하는 현상(CUBRIDSUS-11091)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: sql 

    SELECT table1 . "col_datetime" AS field1, SUM( table1 . col_int ) AS field2, table1 . "col_varchar_512" AS field3, MAX( distinct table1 . col_varchar_256_key ) AS field4 FROM "pp_a" AS table1 WHERE ( ( table1 . col_int < 2 ) XOR table1 . col_date != '2008-05-16' ) GROUP BY field1, field3 ; 
    
분할 테이블에 대해 ALTER 문 수행 시 예약어를 []로 감싼 테이블 이름 또는 칼럼 이름을 인식하지 못하는 문제(CUBRIDSUS-11110)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: sql 

    ALTER TABLE [partition] PARTITION BY RANGE (ch) (PARTITION p1 VALUES LESS THAN ('100'), PARTITION p2 VALUES LESS THAN ('200'), PARTITION p3 VALUES LESS THAN ('300')); 

수정 이전 버전에서 위의 질의를 수행하면, 아래와 같은 오류를 반환한다. 
     
:: 

    Syntax error: unexpected 'partition'

범위 또는 리스트 분할 테이블 복제에 실패하는 현상(CUBRIDSUS-11821)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

HA 환경에서 콜레이션을 지정한 칼럼으로 범위 분할 또는 리스트 분할을 하는 분할 테이블 복제 시 실패하는 현상을 수정했다. 


.. code-block:: sql 

    CREATE TABLE t1 (a VARCHAR(10) COLLATE utf8_en_cs, b int PRIMARY KEY) 
    PARTITION BY LIST (a) ( 
        PARTITION a2 VALUES IN ('a'), 
        PARTITION a3 VALUES IN ('b') 
    ); 

분할 테이블에 ALTER 연산 수행 시 잠금 획득 순서가 잘못된 현상(CUBRIDSUS-11797)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

분할 테이블에 인덱스 추가 등과 같은 ALTER 연산 수행 시 잠금 획득 순서가 잘못되었으나 분할에 잠금이 획득된 이후 분할 연산이 수행되도록 수정했다.

분할 테이블에 INSERT하는 질의문이 교착 상태에 의해 취소되면 교착 상태 관련 에러가 중간에 무시되면서 교착 상태가 해소되지 못하는 현상(CUBRIDSUS-11795)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

분할 테이블의 INNER JOIN 수행 시 인덱스를 사용할 수 있도록 개선(CUBRIDSUS-9986)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: sql 

    CREATE TABLE t1(I INT); 
    INSERT INTO t1 VALUES (1), (2), (3), (4), (5); 
    CREATE TABLE t2(I INT) PARTITION BY HASH( I ) PARTITIONS 5; 
    INSERT INTO t2 VALUES (1), (2), (3), (4), (5); 
    CREATE index idx_t2_i ON t2( I ); 
    UPDATE STATISTICS ON t2; 

    SELECT /*+ RECOMPILE */ * FROM t1, t2 WHERE t1.i=t2.i; 

HA
--

.. 4.4new

copylogdb가 무응답하여 DB 서버가 동작을 멈추는 현상(CUBRIDSUS-11145)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

copylogdb 프로세스가 무응답할 경우 해당 copylogdb와 연결된 DB 서버의 동작이 멈추는 (hang) 현상을 수정했다. 
해당 오류가 발생했을 경우 DB 서버는 copylogdb와 연결을 끊고 다음의 메시지를 출력한다. 

::
  
    Time: 06/11/13 10:56:40.002 - ERROR *** file ../../src/transaction/log_writer.c, line 1982 ERROR CODE = -1026 Tran = 2, CLIENT = hostname:copylogdb(6694), EID = 110 
    Timed out waiting for next request from client. 

.. 4.4new

max_clients만큼의 연결이 맺어지면 applylogdb 또는 copylogdb 프로세스가 DB 서버에 접속하지 못하는 현상(CUBRIDSUS-10328)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

HA 환경에서 max_clients만큼의 연결이 맺어지면 applylogdb 또는 copylogdb 프로세스가 DB 서버에 접속하지 못하면서 HA 구동 명령 수행에 실패하는 현상을 수정했다.    

.. 4.4new

"cubrid heartbeat stop" 명령으로 서버 프로세스가 종료되지 않는 현상(CUBRIDSUS-10725)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. 4.4new

dba 계정이 아닌 계정으로 DDL 실행 후 복제 재구축 시 applylogdb 프로세스가 비정상 종료하는 문제(CUBRIDSUS-10759)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. 4.4new

정상 판정을 받은 브로커에도 health check 메시지를 지속적으로 보내는 현상(CUBRIDSUS-10817)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

HA 환경에서 연결 URL의 rctime 설정에 의해 브로커에 health check 메시지를 1분에 한 번씩 보내는데, 정상으로 판정되어도 한 번 장애 목록에 포함되면 health check 메시지를 지속적으로 보내는 현상을 수정했다. 

.. 4.4new

복제 반영을 재시도해야 할 오류임에도 불구하고 재시도하지 않는 현상(CUBRIDSUS-10833)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cubrid_ha.conf의 ha_applylogdb_retry_error_list에 설정되어 복제 반영을 재시도해야 할 오류임에도 불구하고 재시도하지 않는 현상을 수정했다.

.. 4.4new

브로커의 JOB QUEUE가 가득 찬 경우 altHosts로 재접속을 시도하지 못하고 에러를 반환하는 현상(CUBRIDSUS-10851) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
응용 프로그램들의 요청이 많아져 브로커의 JOB QUEUE가 가득 찬 경우, 연결 URL에 altHosts를 지정했음에도 불구하고 altHosts로 재접속을 시도하지 못하고 CAS_ER_FREE_SERVER 에러를 반환하는 문제를 수정했다.

.. 4.4new

마스터 노드에서 ASYNC로 설정했음에도 불구하고 로그 복사가 멈추면(block) 다음 트랜잭션을 진행하지 못하는 현상(CUBRIDSUS-10991)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cubrid_ha.conf의 ha_copy_sync_mode를 ASYNC로 설정했음에도 불구하고 로그 복사가 멈추면(block) 다음 트랜잭션을 진행하지 못하는 현상을 수정했다.

.. 4.4new

applylogdb 에러 메시지 중 상대편 노드의 서버 상태를 출력하는 메시지에 상대편 노드 이름 추가(CUBRIDSUS-10992)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
applylogdb 에러 메시지 중 상대편 노드의 서버 상태를 출력하는 메시지에 상대편 노드 이름이 없었으나 이를 추가했다. 
  
:: 
  
    // 수정 이전 
    HA generic: change HA server state from from 'idle' to 'active'.. 
  
    // 수정 이후 
    HA generic: change the state of HA server (testdb@cdbs037.cub) from 'idle' to 'active'.

.. 4.4new

INSERT ... SELECT 복제 도중 ALTER TABLE로 칼럼 추가하면 복제가 실패하는 현상(CUBRIDSUS-11166)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. 4.4new

BIGINT 타입 칼럼을 가진 뷰가 복제되지 않는 문제(CUBRIDSUS-11200)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: sql 
  
    CREATE VIEW vw AS SELECT CAST(2 AS BIGINT) FROM db_root;


테이블 생성 시 ENUM 데이터 집합에 콜레이션을 지정하면 슬레이브 노드 복제에 실패하는 현상(CUBRIDSUS-11465)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: sql 

    CREATE TABLE tbl(i INT, e ENUM('e','D','a') COLLATE utf8_en_ci);

ALTER TABLE 문의 칼럼을 정의할 때 PRIMARY KEY, FOREIGN KEY, UNIQUE, CHECK 등의 앞에 NOT NULL이 명시되면 복제에 실패하는 현상(CUBRIDSUS-11964)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Sharding
--------

.. 4.4new

질의문에 SHARD_VAL 힌트 입력 시 SHARD CAS SQL 로그에서 이를 SHARD_ID 힌트로 치환되도록 수정(CUBRIDSUS-7156)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

질의문에 SHARD_VAL 힌트를 입력하면 SHARD CAS SQL 로그에 기록되는 SQL 문에서는 이를 SHARD_ID 힌트로 치환되도록 수정했다. 

.. 4.4new

shard.conf 의 MAX_CLIENT 제약으로 응용 클라이언트가 SHARD proxy로 접속 불가능한 경우, 이를 판단할 수 있도록 에러 코드 추가(CUBRIDSUS-8326) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

shard.conf의 MAX_CLIENT의 제약으로 인해 SHARD proxy에 응용 클라이언트의 연결이 불가능한 경우, 수정 이전 버전에서는 단순히 네트워크 연결을 종료하기 때문에 에러 상황을 판단할 수 없었으나 이를 판단할 수 있는 에러 코드를 반환하도록 수정했다. 
  
:: 

    Proxy refused client connection. max clients exceeded

.. 4.4new

PROXY_LOG_DIR로 지정한 경로에 PROXY 로그 파일을 생성하지 않는 오류 수정(CUBRIDSUS-10390)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. 4.4new

SHARD 환경에서 cci_prepare_and_execute 함수를 사용할 수 있도록 수정(CUBRIDSUS-10441)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. 4.4new

Statement 개수의 제한 또는 메모리 용량의 제한 등으로 인해 SHARD CAS가 재시작하면 트랜잭션 커밋에 대한 응답을 처리하기 전에 CAS의 연결 오류를 먼저 처리하는 문제(CUBRIDSUS-10792) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
Statement 개수의 제한 또는 메모리 용량의 제한으로 인해 SHARD CAS가 재시작하면 트랜잭션 커밋에 대한 응답을 응용 프로그램이 전달받기 전에 SHARD CAS의 연결 오류(Cannot communicate with server)를 먼저 받게 되는 문제를 수정했다. 

.. 4.4new

Linux 시스템에서 샤드 구동 시 필요한 fd 수보다 시스템의 "ulimit -n"의 값이 작게 설정되어 있으면 에러를 발생하도록 수정(CUBRIDSUS-10837)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
Linux 시스템에서 "cubrid shard start"를 수행할 경우 필요한 fd(file descriptor) 수보다 "ulimit -n"으로 지정한 값이 작으면 응용 프로그램에서 시스템 멈춤(hang) 현상 등의 오동작이 발생했으나, 에러를 발생하도록 수정했다. Linux 시스템에서 필요한 fd의 개수는 shard.conf에서 설정하는 MAX_CLIENT에 적당한 개수를 더한 값이다. 

.. 4.4new

"shard reset" 명령 이후 응용 프로그램의 첫 번째 질의 처리에서 오류가 발생하는 문제(CUBRIDSUS-10895)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
DB 서버 프로세스의 재시작 등으로 인해 SHARD CAS와 DB 서버 프로세스 사이의 기존 연결이 종료되면 "cubrid shard reset" 명령을 수행하여 재연결한 이후 모든 질의가 정상 처리되어야 하나, 응용 프로그램의 첫 번째 질의 처리에서 오류가 발생하는 문제를 수정했다.

.. 4.4new

재시작된 SHARD CAS가 사용되지 못하는 현상(CUBRIDSUS-11271)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

SHARD CAS 의 메모리 증가로 인하여 빈번하게 재시작 되는 경우, 해당 SHARD CAS가 사용자의 요청을 
받지 못하는 현상을 수정했다. 

.. 4.4new

"shard status -c" 명령 수행 시 출력하는 응용 프로그램의 최근 요청 시각이 갱신되지 않는 문제(CUBRIDSUS-11272) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

"cubrid shard status -c" 명령 수행 시 출력하는 응용 프로그램의 최근 요청 시각(L-REQ-TIME)이 갱신되지 않는 상황이 존재했으나, 항상 갱신되도록 수정했다. 
  
또한, 해당 명령 수행 시 출력되는 칼럼의 제목인 L-REQ-TIME, L-RES-TIME을 LAST-REQ-TIME, LAST-RES-TIME로 변경했다.

.. 4.4new

shard.conf의 MAX_CLIENT 설정 값 이상의 응용 프로그램들이 SHARD PROXY에 동시 접속을 시도하는 경우 SHARD PROXY 프로세스가 비정상 종료하는 현상(CUBRIDSUS-11290)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. 4.4new

SHARD proxy에 대한 CAS의 개수가 동적으로 관리되도록 수정(CUBRIDSUS-10130)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

shard.conf에서 SHARD proxy 시스템에 대한 CAS의 최소 개수인 MIN_NUM_APPL_SERVER와 최대 개수인 MAX_NUM_APPL_SERVER가 항상 동일하게 설정되어야 했으나, 이를 다르게 설정하여 설정과 부하에 따라서 실행되는 CAS 프로세스의 개수가 동적으로 늘어나거나 줄어들 수 있도록 수정했다. 
  
또한, "cubrid shard status -b" 명령 수행 시 STMT-Q와 SHARD-Q 정보를 추가로 출력하도록 수정했다. 
 
::

    $ cubrid shard status -b -s 1 -t
    @ cubrid shard status
    
      NAME           PID  PORT   Active-P   Active-C  STMT-Q SHARD-Q  TPS  QPS   SELECT   INSERT   UPDATE   DELETE   OTHERS   K-QPS  NK-QPS     LONG-T     LONG-Q   ERR-Q  UNIQUE-ERR-Q  #CONNECT
    ==============================================================================================================================================================================================
    * shard1       18046 45511          4         16       0      12   56   65        0        0        0        0        0      65       0     0/60.0     0/60.0       0             0         0
   
*   STMT-Q: shard status 명령을 실행하는 시점에 prepare를 수행하려고 대기중인 클라이언트의 요청 수 
*   SHARD-Q: shard status 명령을 실행하는 시점에 가용한 CAS를 대기중인 클라이언트의 요청 수

.. 4.4new

Linux에서 SHARD proxy 프로세스 당 연결 가능한 클라이언트의 개수를 최대 10,000개까지 허용하도록 수정(CUBRIDSUS-10218)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Linux에서 SHARD proxy 프로세스 당 연결 가능한 클라이언트의 개수를 기존에는 500개 정도로 제한했으나, 수정 이후 10,000개 까지 허용하도록 수정했다. 
  
*   SHARD proxy 프로세스 한 개에서 사용하는 파일 디스크립터의(fd)는 다음과 같다. "((MAX_CLIENT + MAX_NUM_APPL_SERVER) / MAX_NUM_PROXY) + 256" 

DB 서버보다 이전 버전의 드라이버를 사용하는 응용 프로그램이 잘못된 에러 코드를 반환하는 현상(CUBRIDSUS-12054)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
SHARD 환경에서 DB 서버보다 이전 버전의 드라이버를 사용하는 응용 프로그램이 잘못된 에러 코드를 반환하는 현상을 수정했다. 이 현상은 proxy에서 에러가 발생하는 경우에만 존재한다.

드라이버
--------

.. 4.4new

[JDBC][CCI] 배치 처리 함수에서 실행한 질의문의 길이가 8K 이상이면 CAS SQL 로그 파일에 질의문이 잘려서 기록되는 문제 수정(CUBRIDSUS-11547)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. 4.4new

[JDBC][CCI] 2008 R4.0 미만의 드라이버와 2008 R4.0 이상의 드라이버를 동시에 사용할 때 DB 서버 프로세스가 비정상 종료하는 문제(CUBRIDSUS-10916) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

2008 R4.0 미만의 드라이버와 2008 R4.0 이상의 드라이버를 동시에 사용할 때 CHANGE CLIENT가 발생하면서 SESSION ID가 중복 사용되어 DB 서버 프로세스가 비정상 종료하는 문제를 수정했다. 

.. 4.4new

[JDBC] 이미 close한 객체에 접근할 때 잘못된 예외 오류를 반환하는 문제(CUBRIDSUS-7251)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

JDBC 응용 프로그램에서 이미 close한 java.sql.ResultSet, java.sql.Statement, java.sql.PreparedStatement, java.sql.CallableStatement, java.sql.Connection, java.sql.DatabaseMetaData object 등에 접근할 때 SQLException 예외 오류를 반환해야 하나, NullPointerException 예외 오류를 반환하는 문제를 수정했다.

.. 4.4new

[JDBC] 연결 URL의 zeroDateTimeBehavior 프로퍼티 설정이 exception일 때 zero date를 조회하면 잘못된 에러 메시지를 출력하는 문제(CUBRIDSUS-9963)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

JDBC 응용 프로그램에서 연결 URL의 zeroDateTimeBehavior 프로퍼티 설정이 exception일 때 zero date에 해당하는 값을 조회하면 정상적인 에러 메시지를 출력하도록 수정했다. 
  
::

    // 수정 이전 에러 메시지 
    invalid argument 
  
    // 수정 이후 에러 메시지 
    Zero date can not be represented as java.sql.Timestamp. 
     
참고로, 2008 R4.0 이하 버전에서 TIMESTAMP '1970-01-01 00:00:00'(GMT)는 TIMESTAMP의 최소값이지만, 2008 4.1 이상 버전에서는 zerodate로 인식되며 TIMESTAMP '1970-01-01 00:00:01'(GMT)이 TIMESTAMP의 최소값이다. 

.. 4.4new

[JDBC] queryTimeout을 매우 큰 값으로 설정하면 정상 수행되어야 할 질의문에서 질의 타임아웃 에러가 발생하는 현상(CUBRIDSUS-10967)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

JDBC 응용 프로그램에서 queryTimeout을 매우 큰 값으로 설정하면 비정상적인 질의 타임아웃 에러가 발생하는 현상을 수정했다. 이와 함께, queryTimeout을 2,000,000으로 제한했다.

[JDBC] UNION 질의에서 SELECT 리스트의 타입이 서로 다를 때 잘못된 결과를 출력하는 문제(CUBRIDSUS-12112)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

수정 이전 버전에서 위의 질의 수행 시 JDBC 프로그램이 비정상 결과를 출력하는 현상을 수정했다. 하지만, CSQL은 수정 이전 버전에서도 SELECT 리스트의 타입을 DOUBLE로 변환하면서 결과를 정상 출력한다.

.. code-block:: sql

    SELECT 1 UNION ALL SELECT '4';

.. 4.4new

[CCI] cci_datasource_borrow 호출에 성공한 이후 해당 연결을 사용 시 에러가 발생하는 현상(CUBRIDSUS-11159)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

다중 응용 프로그램들이 CCI datasource를 사용하는 환경에서 cci_datasource_borrow 호출에 성공한 이후 해당 연결을 사용하려고 하면 에러가 발생하는 현상을 수정했다. 

.. 4.4new

[CCI] cci_disconnect 호출 이후 무한정 대기하는 현상(CUBRIDSUS-11000) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. 4.4new

[CCI] cci_datasource_release 함수 호출 시 수행 중이던 트랜잭션의 롤백이 실패하면 다음 번 질의 수행 시 오류가 발생하는 문제(CUBRIDSUS-11841)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
cci_datasource_release 함수가 트랜잭션이 종료되지 않은 상태로 호출되면 트랜잭션을 롤백시키는데, 롤백이 실패할 경우 드라이버의 트랜잭션 상태가 완료로 변경되지 않고 트랜잭션 중으로 유지되면서 다음 번 질의 수행 시 오류가 발생하는 문제를 수정했다.

[CCI] 실행->연결 종료->질의 결과셋 종료 순으로 CCI 함수를 실행하면 잘못된 오류를 반환하는 현상(CUBRIDSUS-11732)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

실행(cci_execute) -> 연결 종료(cci_disconnect) -> 질의 결과셋 종료(cci_close_query_result) 순으로 CCI 함수를 실행하면 CCI_ER_REQ_HANDLE 오류가 아닌 CCI_ER_CON_HANDLE 오류가 반환되는 현상을 수정했다.

[CCI] DATASOURCE를 사용할 때 여러 스레드가 borrow->execute->release를 동시에 수행하면 프로그램이 비정상 종료하는 현상(CUBRIDSUS-12264)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. 4.4new

[CCI] 에러 코드에 대해 누락된 에러 메시지 추가(CUBRIDSUS-11217)(CUBRIDSUS-11310)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
CCI_ER_NO_PROPERTY, CCI_ER_PROPERTY_TYPE, CCI_ER_INVALID_DATASOURCE, CCI_ER_DATASOURCE_TIMEOUT, CCI_ER_DATASOURCE_TIMEDWAIT, CCI_ER_LOGIN_TIMEOUT, CCI_ER_QUERY_TIMEOUT 에러 코드에 대해 누락된 에러 메시지를 추가했다.    

운영 편의성
-----------

.. 4.4new

DB 서버 시작이나 백업 볼륨 복구 시 에러 로그 파일에 로그 회복(log recovery) 시작과 끝을 알리는 NOTIFICATION 메시지를 출력하도록 수정(CUBRIDSUS-9620)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

DB 서버 시작이나 백업 볼륨 복구 시 서버 에러 로그 또는 restoredb 에러 로그 파일에 로그 회복(log recovery) 시작 시간과 종료 시간에 대한 NOTIFICATION 메시지를 출력하도록 수정했다. 
시작 로그에는 적용(redo)해야할 로그의 개수와 로그 페이지 개수가 함께 기록되며, 사용자는 로그를 통해 해당 작업의 소요 시간을 확인할 수 있다. 
  
:: 
  
    Time: 06/14/13 21:29:04.059 - NOTIFICATION *** file ../../src/transaction/log_recovery.c, line 748 CODE = -1128 Tran = -1, EID = 1 
    Log recovery is started. The number of log records to be applied: 96916. Log page: 343 ~ 5104. 
    ..... 
    Time: 06/14/13 21:29:05.170 - NOTIFICATION *** file ../../src/transaction/log_recovery.c, line 843 CODE = -1129 Tran = -1, EID = 4 
    Log recovery is finished. 

.. 4.4new

서버에서 질의 수행이 실패하면 해당 질의문을 NOTIFICATION 에러 메시지로 기록하도록 수정(CUBRIDSUS-10665)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

서버에서 질의 수행이 실패하면 해당 질의문을 아래와 같이 NOTIFICATION 에러 메시지로 기록하도록 수정했다. 

::
  
    Time: 06/13/13 18:34:27.395 - NOTIFICATION *** file ../../src/communication/network_interface_sr.c, line 5803 CODE = -1122 Tran = 1, CLIENT = cdbs035.cub:query_editor_cub_cas_1(20781), EID = 7 
    Query execution error. ERROR_CODE = -670, /* SQL_ID: 9759b7e11189b */ update t1 set a=1 where a>?

.. 4.4new

CAS가 DB에 접속하지 못하는 경우 CAS의 SQL 로그에 연결 실패 정보를 기록하도록 수정(CUBRIDSUS-10676)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

잘못된 암호 입력 등으로 CAS가 DB에 접속하지 못하는 경우 $CUBRID/log/broker/sql_log 이하에 위치하는 CAS의 SQL 로그에 연결 실패 정보를 기록하도록 수정했다. 
수정 이전에는 없었던 아래의 정보가 수정 이후 추가로 기록된다. 
  
:: 
  
    13-05-29 11:02:54.172 (0) connect db bug_7455 user dba url cci:cubrid:10.24.18.66:38000:bug_7455:dba:********: - error:-171(Incorrect or missing password.) 

.. 4.4new

통계 정보 갱신 시작 시와 종료 시에 서버 에러 로그에 NOTIFICATION 메시지를 출력하도록 수정(CUBRIDSUS-10702) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
통계 정보 갱신 시작 시와 종료 시에 서버 에러 로그에 NOTIFICATION 메시지를 출력하도록 수정했다. 이를 통해 통계 정보 갱신에 걸리는 시간을 확인할 수 있다. 

::

    Time: 05/07/13 15:06:25.052 - NOTIFICATION *** file ../../src/storage/statistics_sr.c, line 123 CODE = -1114 Tran = 1, CLIENT = testhost:csql(21060), EID = 4 
    Started to update statistics (class "code", oid : 0|522|3). 

    Time: 05/07/13 15:06:25.053 - NOTIFICATION *** file ../../src/storage/statistics_sr.c, line 330 CODE = -1115 Tran = 1, CLIENT = testhost:csql(21060), EID = 5
    Finished to update statistics (class "code", oid : 0|522|3, error code : 0). 

.. 4.4new, 4.4-10703

오버플로우 키나 오버플로우 페이지가 발생하면 서버 에러 로그 파일에 NOTIFICATION 메시지를 출력하도록 수정(CUBRIDSUS-11455)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

오버플로우 키나 오버플로우 페이지가 발생하면 서버 에러 로그 파일에 NOTIFICATION 메시지를 출력하도록 수정했다. 사용자는 이 메시지를 통해 DB 성능이 느려질 수 있음을 감지할 수 있다. 

::

    Time: 06/14/13 19:23:40.485 - NOTIFICATION *** file ../../src/storage/btree.c, line 10617 CODE = -1125 Tran = 1, CLIENT = testhost:csql(24670), EID = 6 
    Created the overflow key file. INDEX idx(B+tree: 0|131|540) ON CLASS hoo(CLASS_OID: 0|522|2). key: 'z ..... '(OID: 0|530|1). 
    ........... 

    Time: 06/14/13 19:23:41.614 - NOTIFICATION *** file ../../src/storage/btree.c, line 8785 CODE = -1126 Tran = 1, CLIENT = testhost:csql(24670), EID = 9 
    Created a new overflow page. INDEX i_foo(B+tree: 0|149|580) ON CLASS foo(CLASS_OID: 0|522|3). key: 1(OID: 0|572|578). 
    ........... 

    Time: 06/14/13 19:23:48.636 - NOTIFICATION *** file ../../src/storage/btree.c, line 5562 CODE = -1127 Tran = 1, CLIENT = testhost:csql(24670), EID = 42 
    Deleted an empty overflow page. INDEX i_foo(B+tree: 0|149|580) ON CLASS foo(CLASS_OID: 0|522|3). key: 1(OID: 0|572|192).

.. 4.4new

부하가 집중되어 특정 서버 스레드가 UPDATE를 위한 페이지 접근에 여러 번 실패하게 될 때 구체적인 오류 메시지를 출력하도록 수정(CUBRIDSUS-10704) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     
    부하가 집중되어 특정 서버 스레드가 UPDATE를 위한 페이지 접근에 여러 번 실패하게 되면 "Internal system failure: no more specific information is available." 오류가 발생했으나, 보다 구체적인 정보를 제공하기 위해 "LATCH ON PAGE(xx|xx) ABORTED" 메시지를 출력하도록 수정했다. 

.. 4.4new

드라이버 단에서 CAS 정보를 확인할 수 있도록 함수 제공 및 로그 메시지 추가(CUBRIDSUS-10818)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

드라이버 단에서 CAS 정보를 확인할 수 있도록 CCI의 cci_get_cas_info 함수 또는 JDBC의 Connection.toString() 메서드를 제공했다. 
또한, 드라이버의 슬로우 쿼리 로그와 에러 메시지에 CAS정보가 포함되도록 수정했다. 

다음은 JDBC 응용 프로그램에서 cubrid.jdbc.driver.CUBRIDConnection 클래스의 toString() 메서드를 사용하여 CAS 정보를 출력한 예이다. 
  
::
  
    cubrid.jdbc.driver.CUBRIDConnection(CAS ID : 1, PROCESS ID : 22922) 
  
다음은 CCI 응용 프로그램에서 cci_get_cas_info() 함수를 사용하여 CAS 정보를 출력한 예이다. 
  
:: 
  
    127.0.0.1:33000,1,12916 

JDBC 드라이버의 슬로우 쿼리 로그에 다음처럼 CAS정보가 포함된다. 
  
::
 
    2013-05-09 16:25:08.831|INFO|SLOW QUERY 
    [CAS INFO] 
    localhost:33000, 1, 12916 
    [TIME] 
    START: 2013-05-09 16:25:08.775, ELAPSED: 52 
    [SQL] 
    SELECT * from db_class a, db_class b 
  
CCI 의 슬로우 쿼리 로그에 다음처럼 CAS정보가 포함된다. 
  
  
:: 
  
    2013-05-10 18:11:23.023 [TID:14346] [DEBUG][CONHANDLE - 0002][CAS INFO - 127.0.0.1:33000, 1, 12916] [SLOW QUERY - ELAPSED : 45] [SQL - select * from db_class a, db_class b] 

JDBC의 에러 메시지에 다음처럼 CAS정보가 포함된다. 
  
:: 
  
    Syntax: syntax error, unexpected IdName [CAS INFO - localhost:33000,1,30560],[SESSION-16],[URL-jdbc:cubrid:localhost:33000:demodb::********:?logFile=driver_1.log&logSlowQueries=true&slowQueryThresholdMillis=5]. 

CCI의 에러 메시지에 다음처럼 CAS정보가 포함된다. 
  
:: 
  
    Syntax: syntax error, unexpected IdName [CAS INFO - 127.0.0.1:33000, 1, 30560]. 


.. 4.4new

브로커의 SQL 로그 또는 브로커의 상태 출력 시 접속한 드라이버의 버전 정보를 포함하도록 수정(CUBRIDSUS-10936) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
브로커의 SQL 로그를 출력할 때와 "cubrid broker status -f" 명령을 수행하여 브로커 상태를 출력할 때 접속 드라이버의 버전을 출력하도록 수정했다. 
  
수정 이후 SQL 로그는 다음과 같이 출력된다. 
  
:: 
  
    13-05-27 18:50:08.584 (0) CLIENT VERSION 9.2.0.0165 
  
수정 이후 브로커 상태 정보는 다음과 같이 출력된다. 

:: 
  
    $ cubrid broker status -f 
    @ cubrid broker status 
    % test 
    -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
       ID PID QPS LQS PSIZE STATUS LAST ACCESS TIME DB HOST LAST CONNECT TIME CLIENT IP CLIENT VERSION SQL_LOG_MODE TRANSACTION STIME #CONNECT #RESTART 
    -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
        1 12236 10 0 63820 CLOSE_WAIT 2013/05/12 16:22:51 demodb localhost 2013/05/12 16:22:06 10.64.48.166 9.2.0.0165 - 2013/05/12 16:22:51 8 0 
    SQL: 

    
.. 4.4new

killtran 명령에서 출력하는 질의문을 사용자가 입력한 문자열 그대로 출력하도록 수정(CUBRIDSUS-10251)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
"cubrid killtran" 명령에서 질의문 출력 시 시스템이 재작성한 문자열을 출력했으나, 사용자가 입력한 문자열 그대로 출력하도록 수정했다.

유틸리티
--------

.. 4.4new

CSQL에서 질의가 영향을 끼친 행 수, 수행 시간 등 부가 정보를 한 줄에 출력하도록 수정(CUBRIDSUS-10055)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

수정 이전에는 CSQL에서 질의 수행 시 아래와 같이 여러 줄에 걸쳐 부가 정보를 출력했다. 
  
:: 
  
    1 rows selected. 
    SQL statement execution time: 0.008940 sec 
  
    Current transaction has been committed. 
    
수정 이후 한 줄에 출력하게 되었다. 
  
:: 
  
    1 rows selected. (0.008940 sec) Committed.

.. 4.4new

CSQL에서 DB 서버 접속에 실패할 때 csql.err에만 원인이 남고 콘솔에는 접속 실패 메시지만 출력하는 문제(CUBRIDSUS-10073)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

CSQL에서 DB 서버 접속에 실패할 때 csql.err에만 원인이 남고 콘솔에는 접속 실패 메시지만 출력했으나, 콘솔에도 접속 실패 원인을 출력하도록 수정했다. 
  
다음은 cubrid.conf의 max_clients 설정을 초과하는 CAS 프로세스가 구동될 때 발생하는 에러 메시지이다. 
  
:: 
  
    $ csql testdb@localhost 
    Server refused client connection: max clients, (10), exceeded. 
    Failed to connect to database server, 'testdb', on the following host(s): localhost 

    ERROR: Failed to connect to database server, 'testdb', on the following host(s): localhost 
  
다음은 DB 서버와 브로커의 버전이 서로 다를 때 발생하는 에러 메시지이다. 
  
:: 
  
    $ csql testdb@testhost.cub 
    Server release 8.4.4 is different from client release 9.2.0. 
    Failed to connect to database server, 'testdb', on the following host(s): testhost.cub 
  
    ERROR: Failed to connect to database server, 'testdb', on the following host(s): testhost.cub 

.. 4.4new

CSQL에서 세션 명령어인 ;restart를 사용할 때 발생하는 메모리 누수 현상(CUBRIDSUS-10296)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. 4.4new

backupdb 명령의 -D 옵션에 존재하지 않는 경로를 입력하면 에러 처리하도록 수정(CUBRIDSUS-10642)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

"cubrid backupdb" 명령의 -D 옵션에 존재하지 않는 경로를 입력하면 오동작을 수행했으나 에러 처리하도록 수정했다.

.. 4.4new

broker_log_top의 입력 파일에 년도가 바뀐 데이터가 공존하면 정상 수행되지 않는 현상(CUBRIDSUS-10435)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
broker_log_top의 입력 파일인 CAS 로그 파일에 년도 정보가 없어 년도가 바뀐 데이터가 한 파일에 공존하면 정상 수행되지 않았으나, 로그의 날짜 부분에 년도를 포함(YY-MM-DD)하여 broker_log_top를 수행하면 정상 수행되도록 수정했다. 

.. 4.4new

broker_log_converter와 broker_log_runner 관련 오류 수정(CUBRIDSUS-10822) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

bind value에 varchar 칼럼이 존재하는 경우 broker_log_converter의 결과 파일에서 바인딩 값이 잘못되는 문제와, 바인딩 값에 datetime 칼럼이 존재하는 경우 broker_log_runner를 실행했을 때 CCI 응용 프로그램에서 "type conversion" 오류가 발생하는 문제를 수정했다. 
  
또한, 바인딩 값에 datetime 칼럼이 존재하는 경우와 관련하여 cci_bind_param에서 날짜 문자열의 형식은 기존 버전에서는 "YYYY/MM/DD"만 허용했으나, 수정 버전부터 "YYYY/MM/DD" 또는 "YYYY-MM-DD" 형식을 허용하도록 수정했다. 

.. 4.4new

cubrid lockdb 명령 수행 시 잘못된 "Run Deadlock interval" 값을 출력하는 현상(CUBRIDSUS-11798)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cubrid lockdb 명령 수행 시 아래와 같이 잘못된 "Run Deadlock interval" 값을 출력하는 현상을 수정했다. 

:: 

    Lock Escalation at = 100000, Run Deadlock interval = -689679844 

.. 4.4new

"cubrid broker reset" 명령 수행 시 CAS와 브로커 간의 연결을 즉시 리셋하도록 수정(CUBRIDSUS-11972)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

"cubrid broker reset" 명령을 수행했음에도 불구하고 CAS와 DB 서버 간에 기존의 연결을 유지하는 경우가 존재했으나 즉시 연결을 리셋하도록 수정했다.

.. 4.4new

SA(standalone) 모드로 checkdb 수행 시 데이터베이스 볼륨의 페이지 할당 테이블 정보가 유효한지 검사하도록 수정(CUBRIDSUS-10755)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

데이터베이스 볼륨의 헤더 부분에는 현재 볼륨에서 사용중인 페이지에 대한 할당 테이블이 유지되는데, SA 모드로 checkdb를 수행하면 각 볼륨의 페이지 할당 테이블 정보와 데이터베이스에서 유지되는 페이지 정보가 일치하는지 검사하도록 하였다. 
  
두 정보가 불일치하는 경우 아래와 같은 오류 메시지를 남긴다. 

::

    Internal error: Page id 256 is allocated according to the allocation map of volume "/home1/cubrid/tdb_x001", but it does not belong to any file. 
    Internal error: Page id 256 of volume "/home1/cubrid/tdb_x001" is currently being used. But it is not allocated according to the allocation map of volume. 

테이블 이름의 최대 길이를 넘겨서 CSQL의 ;sc 명령을 수행하면 CSQL이 비정상 종료하는 현상(CUBRIDSUS-11842)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

테이블 이름의 최대 길이를 넘겨서 CSQL의 ;sc 명령을 수행하면 CSQL이 비정상 종료하는 현상을 수정했다. 

참고로, 테이블 이름의 최대 길이인 254bytes를 넘어서 DDL을 수행하는 경우 254bytes 길이만큼 이름이 잘린 채로 수행된다. 

CSQL의 클라이언트/서버 모드에서 질의 수행 결과가 가끔씩 안 나올 수 있는 현상(CUBRIDSUS-10768) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    CSQL의 클라이언트/서버 모드(csql -C)에서 질의 수행 결과가 가끔씩 안 나올 수 있는 현상을 수정했다.

SA(standalone) 모드로 CSQL을 실행할 때 통계 정보가 업데이트 되도록 수정(CUBRIDSUS-11417)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

SA 모드로 CSQL을 실행할 때(csql -S) 통계 정보가 업데이트되지 않는 문제를 수정했다.


spacedb 명령으로 GENERIC 볼륨에 대해 용도별 사용량 확인이 가능하도록 수정(CUBRIDSUS-11161)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

"cubrid spacedb" 명령으로 볼륨 사용량을 확인할 때 -p 옵션을 사용하면 GENERIC 볼륨에 대해 용도 별 사용량을 확인할 수 있도록 수정했다. 
GENERIC 볼륨에서 data, index 용도에 따른 사용량을 확인할 수 있다. 

:: 

    $ cubrid spacedb -p --size-unit=M tdb 
    Space description for database 'tdb' with pagesize 16.0K. (log pagesize: 16.0K) 

    Volid Purpose  total_size  free_size  data_size  index_size  temp_size  Vol Name 
                                                                            
        0 GENERIC      20.0 M     17.0 M      2.1 M       0.9 M      0.0 M  /home1/cubrid/tdb 
        1    DATA      20.0 M     19.5 M      0.4 M       0.0 M      0.0 M  /home1/cubrid/tdb_x001 
        2   INDEX      20.0 M     19.6 M      0.0 M       0.4 M      0.0 M  /home1/cubrid/tdb_x002 
        3    TEMP      20.0 M     19.6 M      0.0 M       0.0 M      0.3 M  /home1/cubrid/tdb_x003 
        4    TEMP      20.0 M     19.9 M      0.0 M       0.0 M      0.1 M  /home1/cubrid/tdb_x004 
    ---------------------------------------------------------------------------------------------------- 
        5             100.0 M     95.6 M      2.5 M       1.2 M      0.4 M 
    Space description for temporary volumes for database 'tdb' with pagesize 16.0K. 

    $ cubrid spacedb -s --size-unit=M tdb 
    Summarized space description for database 'tdb' with pagesize 16.0K. (log pagesize: 16.0K) 

       Purpose  total_size  used_size  free_size  volume_count 
    ------------------------------------------------------------- 
          DATA      20.0 M      0.5 M     19.5 M             1 
         INDEX      20.0 M      0.4 M     19.6 M             1 
       GENERIC      20.0 M      3.0 M     17.0 M             1 
          TEMP      40.0 M      0.5 M     39.5 M             2 
     TEMP TEMP       0.0 M      0.0 M      0.0 M             0 
    ------------------------------------------------------------- 
         TOTAL     100.0 M      4.4 M     95.6 M             5 

Windows에서 "cubrid loaddb" 명령 수행 시 발생하는 에러 메시지 중 일부 인자값이 출력되지 않는 현상(CUBRIDSUS-11859)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

해당 현상을 수정했다. 수정 이전 버전에서 이 현상은 영어를 제외한 다른 언어에 대해서만 발생한다.
    
설정, 빌드 및 설치
------------------

.. 4.4new

브로커의 ACCESS_CONTROL_FILE 파라미터에 접속을 허용하는 한 브로커 내의 DB 사용자 별 IP 목록의 최대 라인 개수를 256개로 늘림(CUBRIDSUS-11985)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

브로커의 ACCESS_CONTROL_FILE 파라미터에 접속을 허용하는 IP 목록의 최대 라인 개수가, 하나의 브로커 내에서 같은 DB와 같은 사용자 별로 최대 100라인이었으나 최대 256라인으로 늘어났다.

.. 4.4new

RPM 패키지 설치 시 /etc/init.d 설치 및 chkconfig 에 cubrid 스크립트가 추가되도록 수정(CUBRIDSUS-10657)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
RPM 패키지 설치 시 /etc/init.d 설치 및 chkconfig에 cubrid 스크립트가 추가되도록 수정하여, 이후 재부팅 시 "service cubrid start" 명령을 자동으로 수행하게 되었다. 하지만 수정 이후 버전에서도 cubrid 스크립트 파일 안의 $CUBRID_USER 환경 변수를 CUBRID를 설치한 Linux 계정으로 변경하는 작업이 필요하다. 
수정 이전 버전에서는 $CUBRID/share/init.d cubrid라는 스크립트가 포함되어 이 파일 안의 $CUBRID_USER라는 환경 변수를 CUBRID를 설치한 Linux 계정으로 변경한 후 /etc/init.d에 등록하는 과정이 필요했다. 

.. 4.4new

RPM 패키지 설치 후 cshell을 사용하여 로그인할 때 오류가 발생하는 현상(CUBRIDSUS-9769) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

RPM 패키지 설치 시 /etc/profile.d/cubrid.csh 파일이 생성되는데, cshell로 로그인하는 사용자는 해당 파일을 실행하면서 오류가 발생하는 현상을 수정했다. 


.. 4.4new

2008 R4.1 Patch 2 이전 버전에서 버그로 인해 칼럼 길이보다 큰 데이터가 잘못 들어갔는데, 업그레이드 이후 해당 데이터를 읽을 수 없는 문제(CUBRIDSUS-10347) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

2008 R4.1 Patch 2 이전 버전에서 버그로 인해 칼럼 길이보다 큰 데이터가 잘못 들어갔는데, 업그레이드 이후 해당 이터를 읽을 수 없는 문제가 존재했으나 해당 데이터의 경우 칼럼의 길이만큼 잘라서 읽을 수 있도록 수정했다.

.. 4.4new

Windows에서 tar.gz 소스 압축 파일이 정상적으로 풀리지 않는 문제 수정(CUBRIDSUS-10959)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Windows에서 tar.gz 소스 압축 파일이 정상적으로 풀리지 않는 문제를 수정했다. 또한, 새 버전부터는 Windows 사용자를 위해 zip 파일을 별도로 제공한다.

.. 4.4new

64bit Linux 용 바이너리로 빌드 시 cub_cmhttpd 바이너리가 빌드되지 않는 현상(CUBRIDSUS-10960)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

64bit Linux 용 바이너리로 빌드하는 과정에서 아래의 오류가 발생하면서 cub_cmhttpd 바이너리가 빌드되지 않는 현상을 수정했다. 

::

    build_64 command not found 

Windows 용 CUBRID 설치 패키지에서 같이 제공되던 ODBC, OLE DB 드라이버 제거(CUBRIDSUS-11539)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Windows 용 CUBRID 설치 패키지에서 같이 제공되던 ODBC, OLE DB 드라이버가 제거되었다. 참고로, 모든 CUBRID 관련 드라이버들은 http://ftp.cubrid.org/CUBRID_Drivers/ 에서 다운받을 수 있다. 

기타
----

.. 4.4new

DB 서버 프로세스가 비정상 종료된 이후 복구 도중 발생하는 ER_FILE_TABLE_CORRUPTED 에러를 WARNING으로 변경(CUBRIDSUS-10921)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

DB 서버 프로세스가 비정상 종료된 이후 복구 도중 ER_FILE_TABLE_CORRUPTED 에러가 발생하는 경우가 있었으나, 이는 발생 가능한 상황이므로 WARNING으로 변경했다. 

주의 사항
=========

.. _new-cautions92:

신규 주의 사항
--------------

9.2 버전과 9.1 버전 사이에 DB 볼륨 호환 안 됨(CUBRIDSUS-11316)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

9.2 버전과 9.1 버전 사이에 DB 볼륨이 호환되지 않게 됨에 따라 CUBRID 9.1을 9.2로 업그레이드하는 사용자는 CUBRID 9.2 설치 이후 기존의 DB 볼륨을 9.2용으로 반드시 변환해야 한다. 볼륨 마이그레이션을 위해서 9.2 버전에 제공되는 migrate_91_to_92 유틸리티를 제공한다. ::

    % migrate_91_to_92 <db_name>

보다 자세한 사항은  :doc:`/upgrade`\ 를 참고한다.

.. note:: 

    9.1 버전 및 그 이전 버전 사용자는 데이터를 마이그레이션하는 것과 함께 드라이버, 브로커, DB 서버 모두를 반드시 업그레이드해야 한다.

9.2 버전과 9.1 이전 버전 간에 DB 볼륨이 호환되지 않음
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

9.1 이전 버전과 DB 볼륨이 호환되지 않으므로 cubrid unloaddb/loaddb를 이용하여 데이터를 마이그레이션해야 한다. 보다 자세한 사항은  :doc:`/upgrade`\ 를 참고한다.

CUBRID_LANG 환경 변수 대신에 CUBRID_MSG_LANG 환경 변수로 변경
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

9.1 버전부터 CUBRID_LANG 환경 변수는 더 이상 사용되지 않으며, 유틸리티 메시지 및 오류 메시지를 출력할 때는 CUBRID_MSG_LANG 환경 변수를 사용한다. 
DB의 로캘 및 문자셋 지정 시 CUBRID_CHARSET이 9.1 버전에서 사용되었으나, 9.2부터는 CUBRID_CHARSET이 더 이상 사용되지 않으며 DB 생성 시 로캘 및 문자셋을 지정하도록 바뀌었다.

.. 4.4new

[JDBC] 연결 URL의 zeroDateTimeBehavior 속성 값이 "round"일 때 TIMESTAMP의 zero date가 '0001-01-01 00:00:00'에서 '1970-01-01 00:00:00'(GST)로 변경됨(CUBRIDSUS-11612)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
2008 R4.4부터, 연결 URL의 zeroDateTimeBehavior 속성 값이 "round"일 때 TIMESTAMP의 zero date 값이 '0001-01-01 00:00:00'에서 '1970-01-01 00:00:00'(GST)로 변경되었으므로, 응용 프로그램에서 zero date를 사용하는 경우 주의해야 한다.

기존 주의 사항
--------------

CCI 응용 프로그램에서 여러 개의 질의를 한 번에 수행한 결과의 배열에 대한 에러 처리 방식 수정(CUBRIDSUS-9364)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

CCI 응용에서 여러 개의 질의를 한 번에 수행할 때 2008 R3.0부터 2008 R4.1 버전까지는 cci_execute_array 함수, cci_execute_batch 함수 또는 cci_execute_result 함수에 의한 질의 수행 결과들 중 하나만 에러가 발생해도 해당 질의의 에러 코드를 반환했으나, 2008 R4.3 버전 및 9.1 버전부터는 전체 질의 개수를 반환하고 CCI_QUERY_RESULT_* 매크로들을 통해 개별 질의에 대한 에러를 확인할 수 있도록 수정했다.

수정 이전 버전에서는 에러가 발생한 경우에도 배열 내 각각의 질의들의 성공 실패 여부를 알 수 없으므로, 이를 판단해야 한다.

.. code-block:: c

    ...
    char *query = "INSERT INTO test_data (id, ndata, cdata, sdata, ldata) VALUES (?, ?, 'A', 'ABCD', 1234)";
    ...
    req = cci_prepare (con, query, 0, &cci_error);
    ...
    error = cci_bind_param_array_size (req, 3);
    ...
    error = cci_bind_param_array (req, 1, CCI_A_TYPE_INT, co_ex, null_ind, CCI_U_TYPE_INT);
    ...
    n_executed = cci_execute_array (req, &result, &cci_error);

    if (n_executed < 0)
      {
        printf ("execute error: %d, %s\n", cci_error.err_code, cci_error.err_msg);

        for (i = 1; i <= 3; i++)
          {
            printf ("query %d\n", i);
            printf ("result count = %d\n", CCI_QUERY_RESULT_RESULT (result, i));
            printf ("error message = %s\n", CCI_QUERY_RESULT_ERR_MSG (result, i));
            printf ("statement type = %d\n", CCI_QUERY_RESULT_STMT_TYPE (result, i));
          }
      }
    ...
    
수정 이후 버전에서는 에러가 발생하면 전체 질의가 실패한 것이며, 에러가 발생하지 않은 경우에 대해 배열 내 각 질의들의 성공 실패 여부를 판단한다.

.. code-block:: c

    ...
    char *query = "INSERT INTO test_data (id, ndata, cdata, sdata, ldata) VALUES (?, ?, 'A', 'ABCD', 1234)";
    ...
    req = cci_prepare (con, query, 0, &cci_error);
    ...
    error = cci_bind_param_array_size (req, 3);
    ...
    error = cci_bind_param_array (req, 1, CCI_A_TYPE_INT, co_ex, null_ind, CCI_U_TYPE_INT);
    ...
    n_executed = cci_execute_array (req, &result, &cci_error);
    if (n_executed < 0)
      {
        printf ("execute error: %d, %s\n", cci_error.err_code, cci_error.err_msg);
      }
    else
      {
        for (i = 1; i <= 3; i++)
          {
            printf ("query %d\n", i);
            printf ("result count = %d\n", CCI_QUERY_RESULT_RESULT (result, i));
            printf ("error message = %s\n", CCI_QUERY_RESULT_ERR_MSG (result, i));
            printf ("statement type = %d\n", CCI_QUERY_RESULT_STMT_TYPE (result, i));
          }
      }
    ...

javax.sql.XAConnection 인터페이스에서 HOLD_CURSORS_OVER_COMMIT 미지원(CUBRIDSUS-10800)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

CUBRID는 현재 javax.sql.XAConnection 인터페이스에서 ResultSet.HOLD_CURSORS_OVER_COMMIT을 지원하지 않는다.

9.0 버전부터 STRCMP는 대소문자를 구분하여 문자열을 비교
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

9.0 이전 버전까지는 STRCMP가 대소문자를 구분하지 않고 문자열을 비교했으나, 
9.0 버전부터는 대소문자를 구분하여 문자열을 비교한다. STRCMP가 대소문자를 구분하지 않고 동작하게 하려면 문자열에 대소문자를 구분하지 않는 콜레이션(예: utf8_en_ci)을 지정해야 한다.
    
.. code-block:: sql

    -- In previous version of 9.0 STRCMP works case-insensitively
    SELECT STRCMP ('ABC','abc');
    0
    
    -- From 9.0 version, STRCMP distinguish the uppercase and the lowercase when the collation is case-sensitive.
    -- charset is en_US.iso88591
    
    SELECT STRCMP ('ABC','abc');
    -1
    
    -- If the collation is case-insensitive, it distinguish the uppercase and the lowercase.
    -- charset is en_US.iso88591

    SELECT STRCMP ('ABC' COLLATE utf8_en_ci ,'abc' COLLATE utf8_en_ci);
    0

2008 R4.1 버전부터 CCI_DEFAULT_AUTOCOMMIT 의 기본값이 ON으로 바뀜(CUBRIDSUS-5879)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

2008 R4.1 버전부터 CCI 인터페이스로 개발된 응용 프로그램의 자동 커밋 모드에 영향을 주는 브로커 파라미터인 CCI_DEFAULT_AUTOCOMMIT의 기본값이 ON으로 변경되었다. 따라서 CCI 및 CCI로 개발된 인터페이스(PHP, ODBC, OLE DB 등) 사용자는 응용 프로그램의 자동 커밋 모드가 이에 적합한지 살펴보아야 한다.

2008 R4.0 버전부터 페이지 단위의 옵션 및 파라미터가 볼륨 크기 단위로 바뀜(CUBRIDSUS-5136)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cubrid createdb 유틸리티의 DB 볼륨 크기 및 로그 볼륨 크기를 지정할 때 페이지 단위를 사용하는 옵션들(-p, -l, -s)은 제거될 예정이므로, 2008 R4.0 Beta 이후 새로 추가된 옵션들(--db-volume-size, --log-volume-size, --db-page-size, --log-page-size)을 사용한다.

cubrid addvoldb 유틸리티의 DB 볼륨 크기를 지정하는 경우에도 페이지 단위를 사용하지 않고 2008 R4.0 Beta 이후 새로 추가된 옵션(--db-volume-size)을 사용한다.
페이지 단위의 시스템 파라미터들은 추후 제거될 예정이므로 바이트 단위의 새로운 시스템 파라미터를 사용할 것을 권장한다. 관련 시스템 파라미터들에 대한 내용은 아래를 참고한다.

2008 R4.0 Beta 이전 사용자는 DB 볼륨 크기 설정 시 주의(CUBRIDSUS-4222)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

2008 R4.0 Beta 버전부터 DB 생성 시 데이터 페이지 및 로그 페이지의 크기 기본값이 4KB에서 16KB로 변경되었으므로, DB 볼륨을 페이지 개수로 지정하여 생성하는 경우 볼륨의 바이트 크기가 기대와 다를 수 있음에 주의한다. 아무런 옵션도 주지 않을 경우 이전 버전에서는 4KB의 페이지 크기로 100MB의 DB 볼륨을 생성했으나, 2008 R4.0 버전부터는 16KB의 페이지 크기로 512MB의 DB 볼륨을 생성하게 된다.

그리고, DB 볼륨의 생성 가능한 최소 크기를 20MB로 제한했으므로 이보다 작은 크기의 DB 볼륨은 생성할 수 없다.

2008 R4.0 이전 버전의 일부 시스템 파라미터들의 기본값 변경(CUBRIDSUS-4095)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

2008 R4.0부터 다음 시스템 파라미터들의 기본값이 변경되었다.

DB 서버가 허용하는 동시 연결 개수를 설정하는 max_clients의 기본값, 인덱스 페이지 생성 시 향후 업데이트를 대비하여 확보하는 여유 공간 비율을 설정하는 index_unfill_factor의 기본값이 변경되었으며, 바이트 단위 시스템 파라미터의 기본값이 기존 페이지 단위 시스템 파라미터의 기본값보다 커져서 별도의 설정을 하지 않는 경우 더 많은 메모리를 사용하게 되었다.

+-----------------------------+----------------------------+----------------------+--------------------+ 
| 기존                        | 추가된                     | 기존                 | 변경된             | 
| 시스템 파라미터             | 시스템  파라미터           | 기본값               | 기본값             |
|                             |                            |                      | (단위: 바이트)     | 
+=============================+============================+======================+====================+ 
| max_clients                 | 없음                       | 50                   | 100                | 
+-----------------------------+----------------------------+----------------------+--------------------+ 
| index_unfill_factor         | 없음                       | 0.2                  | 0.05               | 
+-----------------------------+----------------------------+----------------------+--------------------+
| data_buffer_pages           | data_buffer_size           | 100M(페이지 크기=4K) | 512M               | 
+-----------------------------+----------------------------+----------------------+--------------------+
| log_buffer_pages            | log_buffer_size            | 200K(페이지 크기=4K) | 4M                 | 
|                             |                            |                      |                    |
+-----------------------------+----------------------------+----------------------+--------------------+
| sort_buffer_pages           | sort_buffer_size           | 64K(페이지 크기=4K)  | 2M                 | 
|                             |                            |                      |                    | 
+-----------------------------+----------------------------+----------------------+--------------------+
| index_scan_oid_buffer_pages | index_scan_oid_buffer_size | 16K(페이지 크기=4K)  | 64K                | 
|                             |                            |                      |                    | 
+-----------------------------+----------------------------+----------------------+--------------------+

또한, cubrid createdb로 DB 생성 시 데이터 페이지 크기와 로그 페이지 크기의 최소값이 1K에서 4K로 변경되었다.

시스템 파라미터를 잘못 설정하면 DB 서비스, 유틸리티 및 응응 프로그램이 구동되지 않음(CUBRIDSUS-5375)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

cubrid.conf 또는 cubrid_ha.conf에 정의되지 않은 시스템 파라미터를 설정하거나, 페이지 단위의 시스템 파라미터와 바이트 단위의 시스템 파라미터가 동시에 사용되거나, 시스템 파라미터 값이 허용 범위를 벗어나면 이와 관련된 DB 서비스, 유틸리티 및 응응 프로그램이 구동되지 않는다.

CUBRID 32bit 버전에서 data_buffer_size에 2G를 초과하는 값을 설정하면 DB 구동에 실패함(CUBRIDSUS-5349)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

CUBRID 32bit 버전에서 data_buffer_size가 2G를 초과하는 값으로 설정되는 경우 DB 구동에 실패한다. 32bit 버전에서는 OS의 한계로 인해 설정값이 2G를 초과할 수 없음에 주의한다.


Windows Vista 이상 버전에서 CUBRID 유틸리티를 사용한 서비스 제어 시 권장 사항(CUBRIDSUS-4186)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Windows Vista 이상 버전에서 cubrid 유틸리티를 사용하여 서비스를 제어하려면 명령 프롬프트 창을 관리자 권한으로 구동한 후 사용하는 것을 권장한다.

명령 프롬프트 창을 관리자 권한으로 구동하지 않고 cubrid 유틸리티를 사용하는 경우 UAC(User Account Control) 대화 상자를 통하여 관리자 권한으로 수행될 수 있으나 수행 결과 메시지를 확인할 수 없다.

Windows Vista 이상 버전에서 명령 프롬프트 창을 관리자 권한으로 구동하는 방법은 다음과 같다.

*   [시작> 모든 프로그램> 보조 프로그램> 명령 프롬프트]에서 마우스 오른쪽 버튼을 클릭한다.
    
*   [관리자 권한으로 실행(A)]을 선택하면 권한 상승을 확인하는 대화 상자가 활성화되고, "예"를 클릭하여 관리자 권한으로 구동한다.

CUBRID 소스 빌드 후 실행 시, 매니저 서버 프로세스 관련 오류 발생(CUBRIDSUS-3553)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

사용자가 직접 빌드하여 설치하는 경우, CUBRID와 CUBRID 매니저를 각각 빌드하여 설치해야 한다. 만약, CUBRID 소스만 checkout하여 빌드 후 cubrid service start 또는 cubrid manager start를 실행하면, cubrid manager server is not installed라는 오류가 발생한다.

2008 R3.0 이하 버전에서 사용하던 GLO 클래스 지원 중단(CUBRIDSUS-3826)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

CUBRID 2008 R3.0 이하 버전은 glo (Generalized Large Object) 클래스를 사용하여 Large Object를 처리했으나, CUBRID 2008 R3.1 이상 버전 glo 클래스를 제거하고 BLOB, CLOB 타입(이하 LOB)을 지원한다. LOB 데이터 타입에 대한 자세한 내용은 :ref:`blob-clob` 절을 참고하면 된다.

기존의 glo 클래스 사용자는 다음과 같이 작업할 것을 권장한다.

*   GLO 데이터를 파일로 저장한 후 어플리케이션 및 DB 스키마에서 GLO를 사용하지 않도록 수정한다.
    
*   unloaddb, loaddb 유틸리티를 이용하여 DB 마이그레이션을 한다.
    
*   변경한 어플리케이션에 맞게 파일을 LOB 데이터로 로딩하는 작업을 수행하도록 한다.
    
*   수정한 어플리케이션이 정상 동작하는지 확인한다.


참고로, cubrid loaddb 유틸리티는 GLO 클래스를 상속받거나 GLO 클래스 타입을 가진 테이블을 로딩하려는 경우 " Error occurred during schema loading " 오류 메시지와 함께 데이터 로딩을 중지한다.

GLO 클래스의 지원 중단에 따라 각 인터페이스 별로 삭제한 함수는 다음과 같다.

+------------+----------------------------+
| 인터페이스 | 삭제한                     |
|            | 함수                       |
+============+============================+
| CCI        | cci_glo_append_data        |
|            |                            |
|            | cci_glo_compress_data      |
|            |                            |
|            | cci_glo_data_size          |
|            |                            |
|            | cci_glo_delete_data        |
|            |                            |
|            | cci_glo_destroy_data       |
|            |                            |
|            | cci_glo_insert_data        |
|            |                            |
|            | cci_glo_load               |
|            |                            |
|            | cci_glo_new                |
|            |                            |
|            | cci_glo_read_data          |
|            |                            |
|            | cci_glo_save               |
|            |                            |
|            | cci_glo_truncate_data      |
|            |                            |
|            | cci_glo_write_data         |
|            |                            |
+------------+----------------------------+
| JDBC       | CUBRIDConnection.getNewGLO |
|            |                            |
|            | CUBRIDOID.loadGLO          |
|            |                            |
|            | CUBRIDOID.saveGLO          |
|            |                            |
+------------+----------------------------+
| PHP        | cubrid_new_glo             |
|            |                            |
|            | cubrid_save_to_glo         |
|            |                            |
|            | cubrid_load_from_glo       |
|            |                            |
|            | cubrid_send_glo            |
|            |                            |
+------------+----------------------------+

마스터 프로세스와 서버 프로세스 간 프로토콜 변경 및 두 개 버전을 동시에 운영하는 경우 포트 설정 필요(CUBRIDSUS-3564)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

마스터 프로세스(cub_master)와 서버 프로세스(cub_server) 간 통신 프로토콜 변경으로 인해 CUBRID 2008 R3.0 이상 버전의 마스터 프로세스는 하위 버전의 서버 프로세스와 통신할 수 없고, 하위 버전의 마스터 프로세스도 2008 R3.0 이상 버전의 서버 프로세스와 통신할 수 없다. 따라서, 이미 하위 버전이 설치되어 있는 환경에서 새 버전을 추가 설치하여, 두 개 버전의 CUBRID를 동시에 운영하는 경우 각각 서로 다른 포트를 사용하도록 cubrid.conf의 cubrid_port_id 시스템 파라미터를 수정해야 한다.


JDBC에서 연결 정보를 URL 스트링으로 입력하는 경우 물음표를 반드시 명시(CUBRIDSUS-3217)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

JDBC에서 URL 스트링으로 연결 정보를 입력하는 경우 이전 버전에서는 물음표(?)를 입력하지 않더라도 속성(PROPERTY) 정보가 적용되었으나, CUBRID 2008 R3.0부터는 문법에 따라 반드시 물음표를 명시해야 하고 이를 생략할 경우 에러를 출력한다. 또한, 연결 정보 중 USERNAME과 PASSWORD가 없더라도 반드시 콜론( : )을 명시해야 한다.

::

    URL=jdbc:CUBRID:127.0.0.1:31000:db1:::altHosts=127.0.0.2:31000,127.0.0.3:31000 –에러 처리
    URL=jdbc:CUBRID:127.0.0.1:31000:db1:::?altHosts=127.0.0.2:31000,127.0.0.3:31000 –정상 처리

DB 이름에 @를 포함할 수 없음(CUBRIDSUS-2828)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

DB 이름에 @이 포함되는 경우 호스트 이름이 명시된 것으로 해석될 수 있으므로 이를 방지하기 위하여 cubrid createdb, cubrid renamedb, cubrid copydb 유틸리티 실행 시 DB 이름에 @를 포함할 수 없도록 수정했다.
