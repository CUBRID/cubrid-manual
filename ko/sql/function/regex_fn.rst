:meta-keywords: cubrid regex, cubrid regexp, cubrid rlike, regular expression functions, regex
:meta-description: CUBRID functions related to regular expressions.

:tocdepth: 3

*********************************************
정규 표현식 함수와 연산자
*********************************************

정규 표현식은 복잡한 검색 패턴을 표현하는 강력한 방법이다.
이 섹션에서는 정규 표현식을 이용한 패턴을 매칭하는 함수 및 연산자를 설명한다.

.. contents::

.. _regex-syntax:

정규 표현식 문법
================

정규 표현식을 구현하기 위해 CUBRID는 Google RE2 라이브러리와 C++ <regex> 표준 라이브러리를 사용한다.
**regexp_engine** 시스템 파라미터를 설정하여 정규 표현식 라이브러리를 선택할 수 있고 Google RE2 라이브러리를 기본으로 사용한다.

다음 하위 섹션에서 지원되는 정규식 문법을 예시와 함께 설명한다.

.. note::

  **호환성 고려사항**
  
  - CUBRID 11 이전 버전에서 CUBRID는 Henry Spencer의 정규식 구현을 사용하였다.
  - CUBRID 11.0 부터 CUBRID는 Henry Spencer 라이브러리를 제거하고 C++ <regex> 표준 라이브러리를 사용하여 정규식 함수와 연산자를 지원한다.
  - CUBRID 11.2 부터 CUBRID는 Google RE2 라이브러리를 추가로 지원한다. 시스템 파라미터를 설정하여 C++ <regex> 또는 Google RE2를 선택하여 사용할 수 있다.

  \1. Henry Spencer의 정규식 구현은 바이트 방식으로 작동한다. 따라서 REGEXP 및 RLIKE는 멀티바이트를 지원하지 않았다.
  따라서 인자의 콜레이션을 고려하지 않고 ASCII 인코딩으로만 작동했다.
  
  \2. Henry Spencer 라이브러리는 POSIX의 *collating sequence* (*[.character.]*) 표현식을 지원했지만 더 이상 지원하지 않는다.
  또한 *character equivalents* (*[=word=]*) 문법도 지원하지 않는다. 이러한 문법을 가진 표현식이 주어지면 CUBRID는 에러를 반환한다.
  
  \3. Henry Spencer 라이브러리는 점 연산자 (.)로 행 종결자를 매치한다. 그러나 C++ <regex>는 매치되지 않는다.

  \4. 단어-시작 경계 와 단어-끝 경계 (각각 [[:<:]] 와 [[:>:]]) 문법을 지원하지 않는다. 대신, 단어 경계 표기 (\\b) 를 사용할 수 있다.

.. warning::

  **C++ <regex> 라이브러리 주의사항**

  입력 문자열이 길거나 정규 표현식 패턴이 복잡한 경우 C++ <regex> 라이브러리에서 과도한 재귀 호출이 발생할 수 있는 문제가 있다.
  따라서 C++ <regex> 대신 Google RE2를 사용하는 것을 권장한다.
  C++ <regex>는 하위 호환성을 지원하기 위해 남겨두었으며 이후 버전에서 제거될 예정이다. (deprecated)

.. note::

  **멀티바이트 문자열 비교 고려사항**

  C++ <regex>는 시스템 로케일에 따라 C++ <locale>에 의해 멀티바이트 비교를 수행한다. 따라서 로케일에 민감한 기능을 사용하려면 해당 시스템 로케일이 설치되어 있어야 합니다.

특수 패턴 문자
---------------------------

특수 패턴 문자는 문자열로 표현하기 어려운 문자를 나타내거나 문자 범위 (예: [a-z] 범위) 를 나타내기 위해 정규식 패턴에 나타날 때 특별한 의미를 갖는 문자(또는 문자 시퀀스) 이다.
이러한 각 특수 패턴 문자는 단일 문자에 대해 매칭을 수행한다 (수량자 기호 제외).

+----------------+----------------------------------------------------------------------------------------------------------+
| 문자           | 설명                                                                                                     |
+================+==========================================================================================================+
| .              | 행 종결자를 제외한 모든 문자 (LF, CR, LS, PS).                                                           |
+----------------+----------------------------------------------------------------------------------------------------------+
| \\t            | 수평 탭 문자 (\\u0009 와 동일).                                                                          |
+----------------+----------------------------------------------------------------------------------------------------------+
| \\n            | 개행(줄 바꿈) 문자 (\\u000A 와 동일).                                                                    |
+----------------+----------------------------------------------------------------------------------------------------------+
| \\v            | 세로 탭 문자 (\\u000B 와 동일).                                                                          |
+----------------+----------------------------------------------------------------------------------------------------------+
| \\f            | 폼 피드 문자 (\\u000C 와 동일).                                                                          |
+----------------+----------------------------------------------------------------------------------------------------------+
| \\r            | 캐리지 리턴 문자 (\\u000D 와 동일)                                                                       |
+----------------+----------------------------------------------------------------------------------------------------------+
| \\c\ *letter*  | 코드 단위 값이 *letter*\의 코드 단위 값을                                                                |
|                | 32로 나눈 나머지와 같은 제어 코드 문자.                                                                  |
+----------------+----------------------------------------------------------------------------------------------------------+
| \\x\ *hh*      | 코드 단위 값이 2개의 16진수 *hh*\에 해당하는 16진수 값을 갖는 문자                                       |
+----------------+----------------------------------------------------------------------------------------------------------+
| \\u\ *hhhh*    | 코드 단위 값이 4자리 16진수 *hhhh*\에 해당하는 16진수 값을 갖는 문자 *C++ <regex>만 지원*                |
+----------------+----------------------------------------------------------------------------------------------------------+
| \\x\ {*digits*}| *digits* 값에 해당하는 16진수 값을 갖는 문자 *Google RE2만 지원*                                         |
+----------------+----------------------------------------------------------------------------------------------------------+
| \\0            | 널 문자 (\\u0000와 동일). *C++ <regex>만 지원*                                                           |
+----------------+----------------------------------------------------------------------------------------------------------+
| \\\ *num*      | 여는 괄호가 *num*\번째인 부분 일치의 결과. 자세한 내용은 아래 그룹을 참조.                               |
+----------------+----------------------------------------------------------------------------------------------------------+
| \\d            | 10진수 문자 ([[:digit:]] 와 동일).                                                                       |
+----------------+----------------------------------------------------------------------------------------------------------+
| \\D            | 10진수 문자가 아닌 모든 문자 ([^[:digit:]] 와 동일).                                                     |
+----------------+----------------------------------------------------------------------------------------------------------+
| \\s            | 공백 문자 ([[:space:]] 와 동일).                                                                         |
+----------------+----------------------------------------------------------------------------------------------------------+
| \\S            | 공백 문자가 아닌 모든 문자 ([^[:space:]] 와 동일).                                                       |
+----------------+----------------------------------------------------------------------------------------------------------+
| \\w            | 영숫자 또는 밑줄 문자 ([_[:alnum:]] 와 동일).                                                            |
+----------------+----------------------------------------------------------------------------------------------------------+
| \\W            | 영숫자 또는 밑줄 문자가 아닌 모든 문자 ([^_[:alnum:]] 와 동일).                                          |
+----------------+----------------------------------------------------------------------------------------------------------+
|                | | 정규 표현식 내에서 특별한 의미를 해석하지 않고 있는 그대로 *character* 문자                            |
| \\\ *character*| | 위의 특수 문자 시퀀스를 형성하는 문자를 제외한 모든 문자를 이스케이프 한다.                            |
|                | | 필요한 대상: ^ $ \\ . * + ? ( ) [ ] { } \|                                                             |
+----------------+----------------------------------------------------------------------------------------------------------+
| \[\ *class*\]  | *class*\의 일부인 문자열. 아래의 :ref:`regex-posix-character-class`\를 참조.                             |
+----------------+----------------------------------------------------------------------------------------------------------+
| \[^\ *class*\] | *class*\의 일부가 아닌 문자열. 아래의 :ref:`regex-posix-character-class`\를 참조.                        |
+----------------+----------------------------------------------------------------------------------------------------------+
| \\p{*class*}   | *class*\의 유니코드 범위를 가지는 문자열. 아래의 :ref:`regex-unicode-character-class`\를 참조.           |
+----------------+----------------------------------------------------------------------------------------------------------+

.. code-block:: sql

    -- .: 모든 문자와 일치
    SELECT ('cubrid dbms' REGEXP '^c.*$');
    
::

    ('cubrid dbms' regexp '^c.*$')
    ================================
      1

"\\n", "\\t", "\\r" 및 "\\\\"와 같은 특수 문자를 매칭하려면 일부는 **no_backslash_escapes**\(기본값: yes) 값을 **no**\로 지정하여 백슬래시(\\)로 이스케이프해야 한다.
**no_backslash_escapes**\에 대한 자세한 내용은 :ref:`escape-characters`\를 참조한다.

.. code-block:: sql

    -- \n : no_backslash_escapes=yes(기본값)인 경우 \n 특수 문자와 일치
    SELECT ('new\nline' REGEXP 'new\\nline'); 

::
    
    ('new\nline' REGEXP 'new\\nline'); 
    =====================================
      1

.. code-block:: sql

    -- \n : no_backslash_escapes=no일 때 \n 특수 문자와 일치
    SELECT ('new\nline' REGEXP 'new
    line');

::
    
    ('new
    line' regexp 'new
    line')
    =====================================
      0

수량자
------------

수량자 문자 또는 특수 패턴 문자 뒤에 지정합니다. 정규표현식 매칭에서 캐릭터가 반복되는 횟수를 지정할 수 있다:

+----------------+-------------------------------------------------------------------------+
| Characters     | Description                                                             |
+================+=========================================================================+
| \*             | 선행하는 문자 또는 패턴이 0회 이상 일치                                 |
+----------------+-------------------------------------------------------------------------+
| \+             | 선행하는 문자 또는 패턴이 1회 이상 일치                                 |
+----------------+-------------------------------------------------------------------------+
| ?              | 선행하는 문자 또는 패턴이 선택사항 (0회 또는 1회 일치)                  |
+----------------+-------------------------------------------------------------------------+
| {*num*}        | 선행하는 문자 또는 패턴이 정확히 *num*\회 일치                          |
+----------------+-------------------------------------------------------------------------+
| {*num,*}       | 선행하는 문자 또는 패턴이 정확히 *num*\회 또는 그 이상 일치             |
+----------------+-------------------------------------------------------------------------+
| {*min,max*}    | 선행하는 문자 또는 패턴이 최소 *min*\회 일치하지만 *max*\를 넘지 않음   |
+----------------+-------------------------------------------------------------------------+

.. code-block:: sql

    -- a+ : 하나 이상의 a 문자 시퀀스와 일치. 대소문자 구분하지 않음.
    SELECT ('Aaaapricot' REGEXP '^A+pricot');
    
::

    ('Aaaapricot' regexp '^A+pricot')
    ================================
      1

.. code-block:: sql

    -- a? : 0 또는 1개의 문자와 일치
    SELECT ('Apricot' REGEXP '^Aa?pricot');
    
::

    ('Apricot' regexp '^Aa?pricot')
    ==========================
      1
    
.. code-block:: sql

    SELECT ('Aapricot' REGEXP '^Aa?pricot');
    
::

    ('Aapricot' regexp '^Aa?pricot')
    ===========================
      1
     
.. code-block:: sql

    SELECT ('Aaapricot' REGEXP '^Aa?pricot');
    
::

    ('Aaapricot' regexp '^Aa?pricot')
    ============================
      0

.. code-block:: sql

    -- (cub)* : 시퀀스 abc의 0개 이상의 인스턴스와 일치
    SELECT ('cubcub' REGEXP '^(cub)*$');
    
::

    ('cubcub' regexp '^(cub)*$')
    ==========================
      1

기본적으로 이러한 모든 수량자는 가능한 한 조건을 충족하는 많은 문자를 사용하는 *greedy* 방식으로 수행된다.
그리고 이 동작은 한정자 뒤에 물음표(?)를 추가하여 *non-greedy*\로 재정의할 수 있다.

.. code-block:: sql

    -- (a+), (a+?) : greedy 또는 non-greedy로 수량자를 사용해 각각 매칭 수행.
    SELECT REGEXP_SUBSTR ('aardvark', '(a+)'), REGEXP_SUBSTR ('aardvark', '(a+?)');
    
::

    regexp_substr('aardvark', '(a+)')  regexp_substr('aardvark', '(a+?)')
    ============================================
      'aa'                  'a'

그룹
------

그룹을 사용하면 단일 문자 대신 일련의 문자에 레이블 (예 $1)을 적용할 수 있다. 두 종류의 그룹이 있다.

.. warning::

    $int를 사용한 역참조 문법은 C++ <regex> 에서만 지원한다.

+--------------------+-------------------------------------------------------+
| 문자               | 설명                                                  |
+====================+=======================================================+
| (\ *subpattern*)   | 역참조를 생성하는 그룹                                |
+--------------------+-------------------------------------------------------+
| (?:\ *subpattern*) | 역참조를 생성하지 않는 패시브 그룹                    |
+--------------------+-------------------------------------------------------+

.. code-block:: sql

    -- 캡쳐된 그룹은 $int로 참조할 수 있다
    SELECT REGEXP_REPLACE ('hello cubrid','([[:alnum:]]+)','$1!');

::

    regexp_replace('hello cubrid','([[:alnum:]]+)','$1!')
    ==========================
      'hello! cubrid!'

그룹이 역참조를 생성하면, 문자열에서 하위 패턴을 나타내는 문자가 하위 일치로 저장된다. 각 하위 일치 항목은 여는 괄호가 나타나는 순서에 따라 번호가 매겨진다 (첫 번째 하위 일치 항목은 1번, 두 번째 하위 일치 항목은 2번 등...).
이러한 하위 일치는 전체 하위 패턴이 다른 곳에 다시 나타나도록 지정하기 위해 정규식 자체에서 사용할 수 있는데 (특수 문자 목록의 \int 참조), REGEXP_REPLACE 함수의 대체 문자열에서 사용할 수 있다.

.. code-block:: sql

    -- 그룹 없이 regexp_substr을 수행한다. 다음은 완전히 일치하는 경우이다.
    SELECT REGEXP_SUBSTR ('abckabcjabc', '[a-c]{3}k[a-c]{3}j[a-c]{3}');

    -- ([a-c]{3}) 는 \1 역참조를 생성한다
    SELECT REGEXP_SUBSTR ('abckabcjabc', '([a-c]{3})k\1j\1');

::

    regexp_substr('abckabcjabc', '[a-c]{3}k[a-c]{3}j[a-c]{3}')
    ======================
      'abckabcjabc'

    regexp_substr('abckabcjabc', '([a-c]{3})k\1j\1')
    ======================
      'abckabcjabc'

어서션
----------

어서션은 문자열의 문자를 사용하지 않는 조건이다. 즉, 문자를 나타내지는 않지만 문자의 앞이나 뒤에 충족되어야 하는 조건이다.

+-----------------+-----------------------------------------------------------------------------------------------------------------------+
| 문자            | 설명                                                                                                                  |
+=================+=======================================================================================================================+
| ^               | 문자열의 시작이나 행 종결자 다음                                                                                      |
+-----------------+-----------------------------------------------------------------------------------------------------------------------+
| $               | 문자열의 끝이나 행 종결자 이전                                                                                        |
+-----------------+-----------------------------------------------------------------------------------------------------------------------+

.. note::
    
    다음의 문법은 C++ <regex> 에서만 제공한다.

+-----------------+-----------------------------------------------------------------------------------------------------------------------+
| 문자            | 설명                                                                                                                  |
+=================+=======================================================================================================================+
| \\b             | 이전 문자는 단어 문자이고 다음 문자는 단어가 아닌 문자(또는 그 반대)                                                  |
+-----------------+-----------------------------------------------------------------------------------------------------------------------+
| \\B             | 이전 및 다음 문자는 모두 단어 문자이거나 둘 다 단어가 아닌 문자                                                       |
+-----------------+-----------------------------------------------------------------------------------------------------------------------+
| (?=subpattern)  | Positive lookahead. 이 문자 다음의 문자열은 하위 패턴과 일치해야 하지만 어떤 문자도 소비되지 않음                     |
+-----------------+-----------------------------------------------------------------------------------------------------------------------+
| (?!subpattern)  | Negative lookahead. 어서션 다음의 문자열은 하위 패턴과 일치하지 않아야 하지만 어떤 문자도 소비되지 않음               |
+-----------------+-----------------------------------------------------------------------------------------------------------------------+

.. code-block:: sql

    -- ^ : 문자열의 시작과 매칭
    SELECT ('cubrid dbms' REGEXP '^cub');
    
::

    ('cubrid dbms' regexp '^cub')
    ===============================
      1

.. code-block:: sql

    -- $ : 문자열의 끝과 매칭
    SELECT ('this is cubrid dbms' REGEXP 'dbms$');
    
::

    ('this is cubrid dbms' regexp 'dbms$')
    ========================================
      1

.. code-block:: sql

    -- (?=subpattern): positive lookahead
    SELECT REGEXP_REPLACE ('cubrid dbms cubrid sql cubrid rdbms', 'cubrid(?= sql)', 'CUBRID');

    -- (?!subpattern): nagative lookahead
    SELECT REGEXP_REPLACE ('cubrid dbms cubrid sql cubrid rdbms', 'cubrid(?! sql)', 'CUBRID');
    
::

   regexp_replace('cubrid dbms cubrid sql cubrid rdbms', 'cubrid(?= sql)', 'CUBRID')
   ======================
     'cubrid dbms CUBRID sql cubrid rdbms'

   regexp_replace('cubrid dbms cubrid sql cubrid rdbms', 'cubrid(?! sql)', 'CUBRID')
   ======================
     'CUBRID dbms cubrid sql CUBRID rdbms'

구분자
------------

패턴에 여러 구분자를 포함할 수 있다:

+-----------------+------------------------------------------------------+
| 문자            | 설명                                                 |
+=================+======================================================+
| \|              | 두 개의 대체 패턴 또는 하위 패턴을 분리              |
+-----------------+------------------------------------------------------+

.. code-block:: sql

    -- a|b : a 또는 b인 모든 문자열 매칭
    SELECT ('a' REGEXP 'a|b');
    SELECT ('d' REGEXP 'a|b');
    
::

    ('a' regexp 'a|b')
    ==============================
      1

    ('d' regexp 'a|b')
    ==============================
      0

정규식은 구분자 연산자(alternatvies, \|)로 간단히 구분하여 여러 대체 패턴을 포함할 수 있다. 정규식은 대체 패턴이 일치하는 경우 일치하는 즉시 매칭한다.
하위 패턴(그룹 또는 어서션)은 구분자 연산자를 사용하여 여러 다른 패턴을 구분할 수도 있다.

.. code-block:: sql

    -- a|b|c : matches any character that is either a, b or c.
    SELECT ('a' REGEXP 'a|b|c');
    SELECT ('d' REGEXP 'a|b|c');
    
::

    ('a' regexp 'a|b|c')
    ==============================
      1

    ('d' regexp 'a|b|c')
    ==============================
      0

문자 클래스
-----------------

문자 클래스 문법은 문자 하나 또는 대괄호 내의 문자 범주와 매칭한다.

개별 문자
~~~~~~~~~

지정된 모든 문자는 클래스의 일부로 간주된다 (\\, [, ] 제외).

.. code-block:: sql

    -- [abc] : a, b 또는 c인 모든 문자와 일치.
    SELECT ('a' REGEXP '[abc]');
    SELECT ('d' REGEXP '[abc]');
    
::

    ('a' regexp '[abc]')
    ==============================
      1

    ('d' regexp '[abc]')
    ==============================
      0

범위
~~~~~~~~~

문자 범위를 나타내기 위해 유효한 두 문자 사이에 대시 문자(-)를 사용한다.
예를 들어 "[a-z]"는 모든 알파벳 문자와 일치하지만 "[0-9]"는 단일 숫자와 일치한다.

.. code-block:: sql

    SELECT ('adf' REGEXP '[a-f]');
    SELECT ('adf' REGEXP '[g-z]');
    
::

    ('adf' regexp '[a-f]')
    ================================
      1

    ('adf' regexp '[g-z]')
    ================================
      0

.. code-block:: sql

    -- [0-9]+: 문자열의 숫자 시퀀스와 일치
    SELECT REGEXP_SUBSTR ('aas200gjb', '[0-9]+');
    
::

    regexp_substr('aas200gjb', '[0-9]+')
    ======================
      '200'

.. code-block:: sql

    SELECT ('strike' REGEXP '^[^a-dXYZ]+$');
    
::

    ('strike' regexp '^[^a-dXYZ]+$')
    ================================
      1

.. _regex-posix-character-class:

POSIX 기반 문자 클래스
~~~~~~~~~~~~~~~~~~~~~~~

POSIX 기반 문자 클래스(*[:classname:]*)는 아래와 같이 문자의 범주를 정의한다.

.. note::

    C++ <regex> 에서는 유니코드 영역까지 매칭하지만 Google RE2 에서는 ASCII 영역만 매칭한다.

+------------+-----------------------------------------+
| 클래스     | 설명                                    |
+============+=========================================+
| [:alnum:]  | 영숫자 문자                             |
+------------+-----------------------------------------+
| [:alpha:]  | 알파벳 문자                             |
+------------+-----------------------------------------+
| [:blank:]  | 빈 문자                                 |
+------------+-----------------------------------------+
| [:cntrl:]  | 제어 문자                               |
+------------+-----------------------------------------+
| [:digit:]  | 십진수 문자                             |
+------------+-----------------------------------------+
| [:graph:]  | 표시할 수 있는 문자                     |
+------------+-----------------------------------------+
| [:lower:]  | 소문자                                  |
+------------+-----------------------------------------+
| [:print:]  | 인쇄 가능한 문자                        |
+------------+-----------------------------------------+
| [:punct:]  | 구두점 문자                             |
+------------+-----------------------------------------+
| [:space:]  | 공백 문자                               |
+------------+-----------------------------------------+
| [:upper:]  | 대문자                                  |
+------------+-----------------------------------------+
| [:xdigit:] | 16진수 문자                             |
+------------+-----------------------------------------+

[:d:], [:w:] 및 [:s:]는 ECMAScript 문법의 확장이다. C++ <regex> 에서만 사용할 수 있다.

+------------+-----------------------------------------+
| 클래스     | 설명                                    |
+============+=========================================+
| [:d:]      | 숫자 (0-9)                              |
+------------+-----------------------------------------+
| [:w:]      | 단어                                    |
+------------+-----------------------------------------+
| [:s:]      | 공백                                    |
+------------+-----------------------------------------+

.. code-block:: sql

    SELECT REGEXP_SUBSTR ('Samseong-ro 86-gil, Gangnam-gu, Seoul 06178', '[[:digit:]]{5}');
    
::

    regexp_substr('Samseong-ro 86-gil, Gangnam-gu, Seoul 06178', '[[:digit:]]{5}')
    ================================
      '06178'

.. code-block:: sql

    -- ;set regexp_engine=cppstd
    SET NAMES utf8 COLLATE utf8_ko_cs;
    SELECT REGEXP_REPLACE ('가나다 가나 가나다라', '\b([[:alpha:]]{2})\b', '#');
    
::

    regexp_count('가나123abc가다abc가가' collate utf8_ko_cs, '[가-나]+' collate utf8_ko_cs)
    =================================================================================================
                                                                                                    3

.. _regex-unicode-character-class:

유니코드 문자 클래스
~~~~~~~~~~~~~~~~~~~~~~~

유니코드 문자 클래스(*\\p{classname}*)는 Google RE2 에서만 제공한다. 아래의 표와 같이 클래스 이름을 지정할 수 있다.
예를 들어 한글 문자를 매칭하기 위해서는 **\\p{Hangul}**\을 사용한다.

+-------------------------+
| 유니코드 문자 클래스    |
+=========================+
| Adlam                   |
+-------------------------+
| Ahom                    |
+-------------------------+
| Anatolian_Hieroglyphs   |
+-------------------------+
| Arabic                  |
+-------------------------+
| Armenian                |
+-------------------------+
| Avestan                 |
+-------------------------+
| Balinese                |
+-------------------------+
| Bamum                   |
+-------------------------+
| Bassa_Vah               |
+-------------------------+
| Batak                   |
+-------------------------+
| Bengali                 |
+-------------------------+
| Bhaiksuki               |
+-------------------------+
| Bopomofo                |
+-------------------------+
| Brahmi                  |
+-------------------------+
| Braille                 |
+-------------------------+
| Buginese                |
+-------------------------+
| Buhid                   |
+-------------------------+
| Canadian_Aboriginal     |
+-------------------------+
| Carian                  |
+-------------------------+
| Caucasian_Albanian      |
+-------------------------+
| Chakma                  |
+-------------------------+
| Cham                    |
+-------------------------+
| Cherokee                |
+-------------------------+
| Chorasmian              |
+-------------------------+
| Common                  |
+-------------------------+
| Coptic                  |
+-------------------------+
| Cuneiform               |
+-------------------------+
| Cypriot                 |
+-------------------------+
| Cypro_Minoan            |
+-------------------------+
| Cyrillic                |
+-------------------------+
| Deseret                 |
+-------------------------+
| Devanagari              |
+-------------------------+
| Dives_Akuru             |
+-------------------------+
| Dogra                   |
+-------------------------+
| Duployan                |
+-------------------------+
| Egyptian_Hieroglyphs    |
+-------------------------+
| Elbasan                 |
+-------------------------+
| Elymaic                 |
+-------------------------+
| Ethiopic                |
+-------------------------+
| Georgian                |
+-------------------------+
| Glagolitic              |
+-------------------------+
| Gothic                  |
+-------------------------+
| Grantha                 |
+-------------------------+
| Greek                   |
+-------------------------+
| Gujarati                |
+-------------------------+
| Gunjala_Gondi           |
+-------------------------+
| Gurmukhi                |
+-------------------------+
| Han                     |
+-------------------------+
| Hangul                  |
+-------------------------+
| Hanifi_Rohingya         |
+-------------------------+
| Hanunoo                 |
+-------------------------+
| Hatran                  |
+-------------------------+
| Hebrew                  |
+-------------------------+
| Hiragana                |
+-------------------------+
| Imperial_Aramaic        |
+-------------------------+
| Inherited               |
+-------------------------+
| Inscriptional_Pahlavi   |
+-------------------------+
| Inscriptional_Parthian  |
+-------------------------+
| Javanese                |
+-------------------------+
| Kaithi                  |
+-------------------------+
| Kannada                 |
+-------------------------+
| Katakana                |
+-------------------------+
| Kawi                    |
+-------------------------+
| Kayah_Li                |
+-------------------------+
| Kharoshthi              |
+-------------------------+
| Khitan_Small_Script     |
+-------------------------+
| Khmer                   |
+-------------------------+
| Khojki                  |
+-------------------------+
| Khudawadi               |
+-------------------------+
| Lao                     |
+-------------------------+
| Latin                   |
+-------------------------+
| Lepcha                  |
+-------------------------+
| Limbu                   |
+-------------------------+
| Linear_A                |
+-------------------------+
| Linear_B                |
+-------------------------+
| Lisu                    |
+-------------------------+
| Lycian                  |
+-------------------------+
| Lydian                  |
+-------------------------+
| Mahajani                |
+-------------------------+
| Makasar                 |
+-------------------------+
| Malayalam               |
+-------------------------+
| Mandaic                 |
+-------------------------+
| Manichaean              |
+-------------------------+
| Marchen                 |
+-------------------------+
| Masaram_Gondi           |
+-------------------------+
| Medefaidrin             |
+-------------------------+
| Meetei_Mayek            |
+-------------------------+
| Mende_Kikakui           |
+-------------------------+
| Meroitic_Cursive        |
+-------------------------+
| Meroitic_Hieroglyphs    |
+-------------------------+
| Miao                    |
+-------------------------+
| Modi                    |
+-------------------------+
| Mongolian               |
+-------------------------+
| Mro                     |
+-------------------------+
| Multani                 |
+-------------------------+
| Myanmar                 |
+-------------------------+
| Nabataean               |
+-------------------------+
| Nag_Mundari             |
+-------------------------+
| Nandinagari             |
+-------------------------+
| New_Tai_Lue             |
+-------------------------+
| Newa                    |
+-------------------------+
| Nko                     |
+-------------------------+
| Nushu                   |
+-------------------------+
| Nyiakeng_Puachue_Hmong  |
+-------------------------+
| Ogham                   |
+-------------------------+
| Ol_Chiki                |
+-------------------------+
| Old_Hungarian           |
+-------------------------+
| Old_Italic              |
+-------------------------+
| Old_North_Arabian       |
+-------------------------+
| Old_Permic              |
+-------------------------+
| Old_Persian             |
+-------------------------+
| Old_Sogdian             |
+-------------------------+
| Old_South_Arabian       |
+-------------------------+
| Old_Turkic              |
+-------------------------+
| Old_Uyghur              |
+-------------------------+
| Oriya                   |
+-------------------------+
| Osage                   |
+-------------------------+
| Osmanya                 |
+-------------------------+
| Pahawh_Hmong            |
+-------------------------+
| Palmyrene               |
+-------------------------+
| Pau_Cin_Hau             |
+-------------------------+
| Phags_Pa                |
+-------------------------+
| Phoenician              |
+-------------------------+
| Psalter_Pahlavi         |
+-------------------------+
| Rejang                  |
+-------------------------+
| Runic                   |
+-------------------------+
| Samaritan               |
+-------------------------+
| Saurashtra              |
+-------------------------+
| Sharada                 |
+-------------------------+
| Shavian                 |
+-------------------------+
| Siddham                 |
+-------------------------+
| SignWriting             |
+-------------------------+
| Sinhala                 |
+-------------------------+
| Sogdian                 |
+-------------------------+
| Sora_Sompeng            |
+-------------------------+
| Soyombo                 |
+-------------------------+
| Sundanese               |
+-------------------------+
| Syloti_Nagri            |
+-------------------------+
| Syriac                  |
+-------------------------+
| Tagalog                 |
+-------------------------+
| Tagbanwa                |
+-------------------------+
| Tai_Le                  |
+-------------------------+
| Tai_Tham                |
+-------------------------+
| Tai_Viet                |
+-------------------------+
| Takri                   |
+-------------------------+
| Tamil                   |
+-------------------------+
| Tangsa                  |
+-------------------------+
| Tangut                  |
+-------------------------+
| Telugu                  |
+-------------------------+
| Thaana                  |
+-------------------------+
| Thai                    |
+-------------------------+
| Tibetan                 |
+-------------------------+
| Tifinagh                |
+-------------------------+
| Tirhuta                 |
+-------------------------+
| Toto                    |
+-------------------------+
| Ugaritic                |
+-------------------------+
| Vai                     |
+-------------------------+
| Vithkuqi                |
+-------------------------+
| Wancho                  |
+-------------------------+
| Warang_Citi             |
+-------------------------+
| Yezidi                  |
+-------------------------+
| Yi                      |
+-------------------------+
| Zanabazar_Square        |
+-------------------------+

.. code-block:: sql

    -- ;set regexp_engine=re2
    SELECT REGEXP_COUNT('가나 가나다라 마바사아 자차카타 파하', '\p{Hangul}+');

::

    regexp_count(_utf8'가나 가나다라 마바사아 자차카타 파하' collate utf8_ko_cs, _utf8'\p{Hangul}+' collate utf8_ko_cs)
    ==============================
    5

.. _regex-rlike:

REGEXP, RLIKE
=============

**REGEXP**, **RLIKE**\ 는 동일한 의미로 사용되며, 정규 표현식을 이용한 패턴을 매칭한다. 아래의 문법에서, *expression*\이 *pattern*\과 일치하면 1을 반환한다. 그렇지 않으면 0을 반환한다.
*expression* 또는 *pattern*\이 **NULL**\이면 **NULL**\을 반환한다. 두 번째 구문은 두 구문 모두 **NOT**\을 사용하는 세 번째 구문과 동일한 의미를 갖는다.

::

    expression REGEXP | RLIKE [BINARY] pattern
    expression NOT REGEXP | RLIKE pattern
    NOT (expression REGEXP | RLIKE pattern)

*   *expression* : 칼럼 또는 입력 표현식
*   *pattern* : 정규 표현식에 사용될 패턴. 대소문자 구분 없음

**REGEXP**\ 와 **LIKE**\ 의 차이는 다음과 같다.

* **LIKE** 절은 입력값 전체가 패턴과 매칭되어야 성공한다.
* **REGEXP**\ 는 입력값의 일부가 패턴과 매칭되면 성공한다. **REGEXP**\ 에서 전체 값에 대한 패턴 매칭을 하려면, 패턴의 시작에는 "^"을, 끝에는 "$"을 사용해야 한다.
* **LIKE** 절의 패턴은 대소문자를 구분하지만 **REGEXP**\ 에서 정규 표현식의 패턴은 대소문자를 구분하지 않는다. 대소문자를 구분하려면 **REGEXP BINARY** 구문을 사용해야 한다.

.. code-block:: sql

    -- [a-dX], [^a-dX] : a, b, c, d 또는 X인 모든 문자와 매칭됨.
    SELECT ('aXbc' REGEXP '[a-dX]');

::
    
    ('aXbc' regexp '[a-dX]')
    ==============================
    1

.. code-block:: sql

    -- SELECT 리스트에서 REGEXP를 사용하는 경우 괄호로 묶어야 한다.
    -- 단, WHERE 절에서는 괄호가 필요하지 않다.
    -- BINARY와 함께 사용하는 경우를 제외하고 대소문자를 구분하지 않는다.
    SELECT name FROM public.athlete where name REGEXP '^[a-d]';

::
    
    name
    ======================
    'Dziouba Irina'
    'Dzieciol Iwona'
    'Dzamalutdinov Kamil'
    'Crucq Maurits'
    'Crosta Daniele'
    'Bukovec Brigita'
    'Bukic Perica'
    'Abdullayev Namik'

.. _regex-count:

REGEXP_COUNT
============

.. function:: REGEXP_COUNT (string, pattern_string [, position [, match_type]])

    **REGEXP_COUNT** 함수는 주어진 문자열 *string* 내에서 정규식 패턴 *pattern_string*\의 매칭 횟수를 반환한다. **NULL**\이 인수로 지정된 경우 **NULL**\을 반환한다.

    :param string: 입력 문자열을 지정한다. 값이 **NULL**\이면 **NULL**\을 반환한다
    :param pattern_string: 매칭을 수행할 정규식 패턴 문자열을 지정한다. 값이 **NULL**\이면 **NULL**\을 반환한다.
    :param position: 매칭을 수행할 *string*\의 위치를 지정한다. 값을 생략하면 기본값 1이 적용된다. 값이 음수이거나 0이면 에러를 반환한다. 값이 **NULL**\이면 **NULL**\을 반환한다
    :param match_type: 함수의 매칭 옵션을 설정할 문자열을 지정한다.  값을 생략하면 기본값 'i'가 적용된다. 값이 'c' 또는 'i'가 아닌 경우 에러를 반환한다. 값이 **NULL**\이면 **NULL**\을 반환한다.
    :rtype: INT

.. code-block:: sql

    -- 인수가 NULL 값으로 지정되면 NULL을 반환한다
    SELECT REGEXP_COUNT('ab123ab111a','[a-d]+',NULL);
    
::

    regexp_count('ab123ab111a','[a-d]+',NULL)
    ======================
      NULL

.. code-block:: sql

    -- 빈 문자열 패턴은 어떤 문자열과도 일치하지 않는다
    SELECT REGEXP_COUNT('ab123ab111a','');
    
::

    regexp_count('ab123ab111a','')
    ======================
      0

.. code-block:: sql

    SELECT REGEXP_COUNT('ab123Ab111aAA','[a-d]', 3);
    
::

    regexp_count('ab123Ab111aAA', '[a-d]', 3)
    ===========================================
                                            5

.. code-block:: sql

    -- 대소문자 구분 안함 옵션('i')이 기본값이다
    SELECT REGEXP_COUNT('ab123Ab111aAA','[a-d]', 3, 'i');

    -- 대소문자 구분 옵션('c')이 match_type으로 지정된 경우 A는 매칭되지 않는다.
    SELECT REGEXP_COUNT('ab123Ab111aAA','[a-d]', 3, 'c');
    
    
::

    regexp_count('ab123Ab111aAA', '[a-d]', 3, 'i')
    ================================================
                                                 5

    regexp_count('ab123Ab111aAA', '[a-d]', 3, 'c')
    ================================================
                                                 2

.. code-block:: sql

    SET NAMES utf8 COLLATE utf8_ko_cs;
    SELECT REGEXP_COUNT('가나123abc가다abc가가','[가-나]+');
    
::

    regexp_count('가나123abc가다abc가가' collate utf8_ko_cs, '[가-나]+' collate utf8_ko_cs)
    =================================================================================================
                                                                                                    3


.. _regex-instr:

REGEXP_INSTR
============

.. function:: REGEXP_INSTR (string, pattern_string [, position [, occurrence [, return_option [, match_type]]]])

    **REGEXP_INSTR** 함수는 주어진 문자열 *string* 내에서 정규식 패턴 *pattern_string*\을 검색하여 시작 위치 또는 끝 위치를 반환한다. **NULL**\이 인수로 지정된 경우 **NULL**\을 반환한다.

    :param string: 입력 문자열을 지정한다. 값이 **NULL**\이면 **NULL**\을 반환한다
    :param pattern_string: 매칭을 수행할 정규식 패턴 문자열을 지정한다. 값이 **NULL**\이면 **NULL**\을 반환한다.
    :param position: 매칭을 수행할 *string*\의 위치를 지정한다. 값을 생략하면 기본값 1이 적용된다. 값이 음수이거나 0이면 에러를 반환한다. 값이 **NULL**\이면 **NULL**\을 반환한다
    :param occurrence: 몇 번째 매칭을 사용할 지 지정한다. 값을 생략하면 기본값 1을 적용한다. 값을 생략하면 기본값 1이 적용된다. 값이 음수이면 에러를 반환한다. 값이 **NULL**\이면 **NULL**\을 반환한다.
    :param return_option: 일치하는 문자열의 시작 또는 끝 지점 중 어떤 위치를 반환할지 여부를 지정한다. 만약 값이 0이면 일치하는 문자의 시작 위치를 반환한다. 값이 1이면 일치하는 문자의 끝 위치를 반환한다. 값을 생략하면 기본값 0이 적용된다. 값이 0 또는 1이 아닌 경우 에러를 반환한다. 값이 **NULL**\이면 **NULL**\을 반환한다.
    :param match_type: 함수의 매칭 옵션을 설정할 문자열을 지정한다.  값을 생략하면 기본값 'i'가 적용된다. 값이 'c' 또는 'i'가 아닌 경우 에러를 반환한다. 값이 **NULL**\이면 **NULL**\을 반환한다.
    :rtype: INT

.. code-block:: sql

    -- 인수가 NULL 값으로 지정되면 NULL을 반환한다
    SELECT REGEXP_INSTR('12345abcdeabcde','[abc]',NULL);
    
::

    regexp_instr('12345abcdeabcde', '[abc]', null)
    ======================
      NULL

.. code-block:: sql

    -- 빈 문자열 패턴은 어떤 문자열과도 일치하지 않는다
    SELECT REGEXP_INSTR('12345abcdeabcde','');
    
::

    regexp_instr('12345abcdeabcde', '')
    ======================
      0

.. code-block:: sql

    -- 매칭되는 첫 번째 문자의 위치를 반환한다
    SELECT REGEXP_INSTR('12354abc5','[:alpha:]+',1,1,0);
    
::

    regexp_instr('12354abc5','[:alpha:]+', 1, 1, 0);
    ======================
      6


.. code-block:: sql

    -- 매칭 후 일치하는 문자열의 위치를 반환한다
    SELECT REGEXP_INSTR('12354abc5','[:alpha:]+',1,1,1);
    
::

    regexp_instr('12354abc5','[:alpha:]+', 1, 1, 1);
    ======================
      7

.. code-block:: sql

    SET NAMES utf8 COLLATE utf8_ko_cs;
    SELECT REGEXP_INSTR('12345가나다라마가나다라마바','[가-다]+');
    
::

    regexp_instr('12345가나다라마가나다라마바' collate utf8_ko_cs, '[가-다]+' collate utf8_ko_cs)
    ============================================================================================================
                                                                                                            6

.. _regex-like:

REGEXP_LIKE
===========

.. function:: REGEXP_LIKE (string, pattern_string [, match_type])

    **REGEXP_LIKE** 함수는 주어진 문자열 *string* 내에서 정규식 패턴 *pattern_string*\을 검색한다. 정규식 패턴이 *pattern_string*\의 어느 곳에서나 일치하면 1이 반환된다. 그렇지 않으면 0이 반환된다. **NULL**\이 인수로 지정된 경우 **NULL**\을 반환한다.

    :param string: 입력 문자열을 지정한다. 값이 **NULL**\이면 **NULL**\을 반환한다
    :param pattern_string: 매칭을 수행할 정규식 패턴 문자열을 지정한다. 값이 **NULL**\이면 **NULL**\을 반환한다.
    :param match_type: 함수의 매칭 옵션을 설정할 문자열을 지정한다.  값을 생략하면 기본값 'i'가 적용된다. 값이 'c' 또는 'i'가 아닌 경우 에러를 반환한다. 값이 **NULL**\이면 **NULL**\을 반환한다.
    :rtype: INT

.. code-block:: sql

    SELECT REGEXP_LIKE('abbbbc','ab+c');
    
::

    regexp_like('abbbbc', 'ab+c');
    ======================
      1

.. code-block:: sql

    -- 빈 문자열 패턴은 어떤 문자열과도 일치하지 않는다
    SELECT REGEXP_LIKE('abbbbc','');
    
::

    regexp_like('abbbbc', '');
    ======================
      0

.. code-block:: sql

    SELECT REGEXP_LIKE('abbbbc','AB+C', 'c');
    
::

    regexp_like('abbbbc', 'AB+C');
    ======================
      0

.. code-block:: sql

    SET NAMES utf8 COLLATE utf8_ko_cs;
    SELECT REGEXP_LIKE('가나다','가나?다');
    SELECT REGEXP_LIKE('가나라다','가나?다');
    
::

    regexp_like('가나다' collate utf8_ko_cs, '가나?다' collate utf8_ko_cs)
    ==============================================================================
                                                                                1

    regexp_like('가나라다' collate utf8_ko_cs, '가나?다' collate utf8_ko_cs)
    =================================================================================
                                                                                    0

.. _regex-replace:

REGEXP_REPLACE
==============

.. function:: REGEXP_REPLACE (string, pattern_string, replacement_string [, position [, occurrence [, match_type]]])

    **REGEXP_REPLACE** 함수는 주어진 문자열 *string* 내에서 정규식 패턴 *pattern_string*\을 검색하여 문자열 *replacement_string*\으로 바꾼다. **NULL**\이 인수로 지정된 경우 **NULL**\을 반환한다.

    :param string: 입력 문자열을 지정한다. 값이 **NULL**\이면 **NULL**\을 반환한다
    :param pattern_string: 매칭을 수행할 정규식 패턴 문자열을 지정한다. 값이 **NULL**\이면 **NULL**\을 반환한다.
    :param replacement_string: Specifies the string to replace the matched string by *pattern_string*\. 값이 **NULL**\이면 **NULL**\을 반환한다.
    :param position: 매칭을 수행할 *string*\의 위치를 지정한다. 값을 생략하면 기본값 1이 적용된다. 값이 음수이거나 0이면 에러를 반환한다. 값이 **NULL**\이면 **NULL**\을 반환한다
    :param occurrence: 몇 번째 매칭을 사용할 지 지정한다. 값을 생략하면 기본값 1을 적용한다. 만약 값을 생략하면 기본값 0이 적용된다. 값이 음수이면 에러를 반환한다. 값이 **NULL**\이면 **NULL**\을 반환한다.
    :param match_type: 함수의 매칭 옵션을 설정할 문자열을 지정한다.  값을 생략하면 기본값 'i'가 적용된다. 값이 'c' 또는 'i'가 아닌 경우 에러를 반환한다. 값이 **NULL**\이면 **NULL**\을 반환한다.
    :rtype: STRING

.. code-block:: sql

    -- 인수가 NULL 값으로 지정되면 NULL을 반환한다
    SELECT REGEXP_REPLACE('12345abcdeabcde','[a-d]',NULL);
    
::

    regexp_replace('12345abcdeabcde', '[a-d]', null)
    ======================
    NULL

.. code-block:: sql

    -- 빈 문자열 패턴은 어떤 문자열과도 일치하지 않는다
    SELECT REGEXP_REPLACE('12345abcdeabcde','','#');
    
::

    regexp_replace('12345abcdeabcde', '', '#')
    ======================
      '12345abcdeabcde'

.. code-block:: sql

    SELECT REGEXP_REPLACE('12345abDEKBcde','[a-d]','#');
    
::

    regexp_replace('12345abDEKBcde', '[a-d]', '#')
    ======================
      '12345###EK###e'

.. code-block:: sql

    -- 대소문자 구분 안함 옵션('i')이 기본값이다
    SELECT REGEXP_REPLACE('12345abDEKBcde','[a-d]','#', 1, 0, 'i');

    -- 대소문자 구분 옵션('c')이 match_type으로 지정된 경우 'B' 와 'D'는 매칭되지 않는다.
    SELECT REGEXP_REPLACE('12345abDEKBcde','[a-d]','#', 1, 0, 'c');
    
::

    regexp_replace('12345abDEKBcde', '[a-d]', '#', 1, 0, 'i')
    ======================
      '12345###EK###e'


    regexp_replace('12345abDEKBcde', '[a-d]', '#', 1, 0, 'c')
    ======================
      '12345##DEKB##e'

.. code-block:: sql

    SET NAMES utf8 COLLATE utf8_ko_cs;
    SELECT REGEXP_REPLACE('a1가b2나다라','[가-다]','#',6);
    
::

    regexp_replace('a1가b2나다라' collate utf8_ko_cs, '[가-다]' collate utf8_ko_cs, '#' collate utf8_ko_cs, 6)
    ======================
    'a1가b2##라'

.. _regex-substr:

REGEXP_SUBSTR
=============

.. function:: REGEXP_SUBSTR (string, pattern_string [, position [, occurrence [, match_type]]])

    **REGEXP_SUBSTR** 함수는 주어진 문자열 *string* 내에서 정규식 패턴 *pattern_string*\에 일치하는 문자열을 추출한다. **NULL**\이 인수로 지정된 경우 **NULL**\을 반환한다.

    :param string: 입력 문자열을 지정한다. 값이 **NULL**\이면 **NULL**\을 반환한다
    :param pattern_string: 매칭을 수행할 정규식 패턴 문자열을 지정한다. 값이 **NULL**\이면 **NULL**\을 반환한다.
    :param position: 매칭을 수행할 *string*\의 위치를 지정한다. 값을 생략하면 기본값 1이 적용된다. 값이 음수이거나 0이면 에러를 반환한다. 값이 **NULL**\이면 **NULL**\을 반환한다
    :param occurrence: 몇 번째 매칭을 사용할 지 지정한다. 값을 생략하면 기본값 0을 적용한다. 이 의미는 발생하는 모든 매칭을 사용한다는 의미이다. 값이 음수이면 에러를 반환한다. 값이 **NULL**\이면 **NULL**\을 반환한다.
    :param match_type: 함수의 매칭 옵션을 설정할 문자열을 지정한다. 값을 생략하면 기본값 'i'가 적용된다. 값이 'c' 또는 'i'가 아닌 경우 에러를 반환한다. 값이 **NULL**\이면 **NULL**\을 반환한다.
    :rtype: STRING

.. code-block:: sql

    -- 만약 패턴이 매칭되지 않으면, NULL을 반환한다
    SELECT REGEXP_SUBSTR('12345abcdeabcde','[k-z]+');
    
::

    regexp_substr('12345abcdeabcde','[k-z]+');
    ======================
      NULL

.. code-block:: sql

    -- 빈 문자열 패턴은 어떤 문자열과도 일치하지 않는다
    SELECT REGEXP_SUBSTR('12345abcdeabcde','');
    
::

    regexp_substr('12345abcdeabcde', '')
    ======================
      NULL

.. code-block:: sql

    SELECT REGEXP_SUBSTR('Samseong-ro, Gangnam-gu, Seoul',',[^,]+,');
    
::

    regexp_substr('Samseong-ro, Gangnam-gu, Seoul', ',[^,]+,')
    ======================
      ', Gangnam-gu,'
     
.. code-block:: sql

    SET NAMES utf8 COLLATE utf8_ko_cs;
    SELECT REGEXP_SUBSTR('삼성로, 강남구, 서울특별시','\p{Hangul}+',1,2);
    
::

    regexp_substr('삼성로, 강남구, 서울특별시' collate utf8_ko_cs, '\p{Hangul}+' collate utf8_ko_cs, 1, 2)
    ======================
    '강남구'
