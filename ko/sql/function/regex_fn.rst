:meta-keywords: cubrid regex, cubrid regexp, cubrid rlike, regular expression functions, regex
:meta-description: CUBRID functions related to regular expressions.

:tocdepth: 3

*********************************************
정규 표현식 함수와 연산자
*********************************************

정규 표현식은 복잡한 검색 패턴을 표현하는 강력한 방법이다.
이 섹션에서는 정규 표현식을 이용한 패턴을 매칭하는 함수 및 연산자를 설명한다.

.. contents::

.. _regex-syntax:

정규 표현식 문법
==============================================

정규 표현식을 구현하기 위해 CUBRID는 `ECMA-262 정규식 문법 <http://ecma-international.org/ecma-262/5.1/#sec-15.10>`_ 을 따르는 C++ <regex> 표준 라이브러리르 사용한다.
다음 하위 섹션에서 지원되는 정규식 문법을 예시와 함께 설명한다.

.. note::

  **호환성 고려사항**
  
  CUBRID 11 이전 버전에서 CUBRID는 Henry Spencer의 정규식 구현을 사용하였다.
  CUBRID 11.0 부터 CUBRID는 Henry Spencer 라이브러리를 제거하고 C++ <regex> 표준 라이브러리를 사용하여 정규식 함수와 연산자를 지원한다.
  CUBRID 11.2 부터 CUBRID는 Google RE2 라이브러리를 추가로 지원한다. 시스템 파라미터를 설정하여 C++ <regex> 또는 Google RE2를 선택하여 사용할 수 있다.

  \1. Henry Spencer의 정규식 구현은 바이트 방식으로 작동한다. 따라서 REGEXP 및 RLIKE는 멀티바이트를 지원하지 않았다.
  따라서 인자의 콜레이션을 고려하지 않고 ASCII 인코딩으로만 작동했다.
  
  \2. Henry Spencer 라이브러리는 POSIX의 *collating sequence* (*[.character.]*) 표현식을 지원했지만 더 이상 지원하지 않는다.
  또한 *character equivalents* (*[=word=]*) 문법도 지원하지 않는다. 이러한 문법을 가진 표현식이 주어지면 CUBRID는 에러를 반환한다.
  
  \3. Henry Spencer 라이브러리는 점 연산자 (.)로 행 종결자를 매치한다. 그러나 C++ <regex>는 매치되지 않는다.

  \4. 단어-시작 경계 와 단어-끝 경계 (각각 [[:<:]] 와 [[:>:]]) 문법을 지원하지 않는다. 대신, 단어 경계 표기 (\\b) 를 사용할 수 있다.

.. warning::

  **C++ <regex> 라이브러리 주의사항**

  입력 문자열이 길거나 정규 표현식 패턴이 복잡한 경우 C++ <regex> 라이브러리에서 과도한 재귀 호출이 발생할 수 있는 문제가 있다.
  따라서 C++ <regex> 대신 Google RE2를 사용하는 것을 권장한다.
  C++ <regex>는 하위 호환성을 지원하기 위해 남겨두었으며 이후 버전에서 제거될 예정이다. (deprecated)

.. note::

  **멀티바이트 문자열 비교 고려사항**

  C++ <regex>는 시스템 로케일에 따라 C++ <locale>에 의해 멀티바이트 비교를 수행한다. 따라서 로케일에 민감한 기능을 사용하려면 해당 시스템 로케일이 설치되어 있어야 합니다.

특수 패턴 문자
---------------------------

특수 패턴 문자는 문자열로 표현하기 어려운 문자를 나타내거나 문자 범위 (예: [a-z] 범위) 를 나타내기 위해 정규식 패턴에 나타날 때 특별한 의미를 갖는 문자(또는 문자 시퀀스) 이다.
이러한 각 특수 패턴 문자는 단일 문자에 대해 매칭을 수행한다 (수량자 기호 제외).

+----------------+----------------------------------------------------------------------------------------------------------+
| 문자           | 설명                                                                                                     |
+================+==========================================================================================================+
| .              | 행 종결자를 제외한 모든 문자 (LF, CR, LS, PS).                                                           |
+----------------+----------------------------------------------------------------------------------------------------------+
| \\t            | 수평 탭 문자 (\\u0009 와 동일).                                                                          |
+----------------+----------------------------------------------------------------------------------------------------------+
| \\n            | 개행(줄 바꿈) 문자 (\\u000A 와 동일).                                                                    |
+----------------+----------------------------------------------------------------------------------------------------------+
| \\v            | 세로 탭 문자 (\\u000B 와 동일).                                                                          |
+----------------+----------------------------------------------------------------------------------------------------------+
| \\f            | 폼 피드 문자 (\\u000C 와 동일).                                                                          |
+----------------+----------------------------------------------------------------------------------------------------------+
| \\r            | 캐리지 리턴 문자 (\\u000D 와 동일)                                                                       |
+----------------+----------------------------------------------------------------------------------------------------------+
| \\c\ *letter*  | 코드 단위 값이 *letter*의 코드 단위 값을                                                                 |
|                | 32로 나눈 나머지와 같은 제어 코드 문자.                                                                  |
+----------------+----------------------------------------------------------------------------------------------------------+
| \\x\ *hh*      | 코드 단위 값이 2개의 16진수 *hh*에 해당하는 16진수 값을 갖는 문자                                        |
+----------------+----------------------------------------------------------------------------------------------------------+
| \\u\ *hhhh*    | 코드 단위 값이 4자리 16진수 *hhhh*에 해당하는 16진수 값을 갖는 문자                                      |
+----------------+----------------------------------------------------------------------------------------------------------+
| \\0            | 널 문자 (\\u0000와 동일).                                                                                |
+----------------+----------------------------------------------------------------------------------------------------------+
| \\\ *num*      | 여는 괄호가 *num*번째인 부분 일치의 결과. 자세한 내용은 아래 그룹을 참조.                                |
+----------------+----------------------------------------------------------------------------------------------------------+
| \\d            | 10진수 문자 ([[:digit:]] 와 동일).                                                                       |
+----------------+----------------------------------------------------------------------------------------------------------+
| \\D            | 10진수 문자가 아닌 모든 문자 ([^[:digit:]] 와 동일).                                                     |
+----------------+----------------------------------------------------------------------------------------------------------+
| \\s            | 공백 문자 ([[:space:]] 와 동일).                                                                         |
+----------------+----------------------------------------------------------------------------------------------------------+
| \\S            | 공백 문자가 아닌 모든 문자 ([^[:space:]] 와 동일).                                                       |
+----------------+----------------------------------------------------------------------------------------------------------+
| \\w            | 영숫자 또는 밑줄 문자 ([_[:alnum:]] 와 동일).                                                            |
+----------------+----------------------------------------------------------------------------------------------------------+
| \\W            | 영숫자 또는 밑줄 문자가 아닌 모든 문자 ([^_[:alnum:]] 와 동일).                                          |
+----------------+----------------------------------------------------------------------------------------------------------+
|                | | 정규 표현식 내에서 특별한 의미를 해석하지 않고 있는 그대로 *character* 문자                            |
| \\\ *character*| | 위의 특수 문자 시퀀스를 형성하는 문자를 제외한 모든 문자를 이스케이프 한다.                            |
|                | | 필요한 대상: ^ $ \\ . * + ? ( ) [ ] { } \|                                                             |
+----------------+----------------------------------------------------------------------------------------------------------+
| \[\ *class*\]  | *class*의 일부인 문자열. 아래의 **POSIX 기반 문자 클래스**를 참조.                                       |
+----------------+----------------------------------------------------------------------------------------------------------+
| \[^\ *class*\] | *class*의 일부가 아닌 문자열. 아래의 **POSIX 기반 문자 클래스**를 참조.                                  |
+----------------+----------------------------------------------------------------------------------------------------------+

.. code-block:: sql

    -- .: 모든 문자와 일치
    SELECT ('cubrid dbms' REGEXP '^c.*$');
    
::

    ('cubrid dbms' regexp '^c.*$')
    ================================
      1

"\\n", "\\t", "\\r" 및 "\\\\"와 같은 특수 문자를 매칭하려면 일부는 **no_backslash_escapes** (기본값: yes) 값을 **no**\로 지정하여 백슬래시(\\)로 이스케이프해야 한다.
**no_backslash_escapes**\에 대한 자세한 내용은 :ref:`escape-characters`\를 참조한다.

.. code-block:: sql

    -- \n : no_backslash_escapes=yes(기본값)인 경우 \n 특수 문자와 일치
    SELECT ('new\nline' REGEXP 'new\\nline'); 

::
    
    ('new\nline' REGEXP 'new\\nline'); 
    =====================================
      1

.. code-block:: sql

    -- \n : no_backslash_escapes=no일 때 \n 특수 문자와 일치
    SELECT ('new\nline' REGEXP 'new
    line');

::
    
    ('new
    line' regexp 'new
    line')
    =====================================
      1

수량자
------------

수량자 문자 또는 특수 패턴 문자 뒤에 지정합니다. 정규표현식 매칭에서 캐릭터가 반복되는 횟수를 지정할 수 있다:

+----------------+-------------------------------------------------------------------------+
| Characters     | Description                                                             |
+================+=========================================================================+
| \*             | 선행하는 문자 또는 패턴이 0회 이상 일치                                 |
+----------------+-------------------------------------------------------------------------+
| \+             | 선행하는 문자 또는 패턴이 1회 이상 일치                                 |
+----------------+-------------------------------------------------------------------------+
| ?              | 선행하는 문자 또는 패턴이 선택사항 (0회 또는 1회 일치)                  |
+----------------+-------------------------------------------------------------------------+
| {*num*}        | 선행하는 문자 또는 패턴이 정확히 *num* 회 일치                          |
+----------------+-------------------------------------------------------------------------+
| {*num,*}       | 선행하는 문자 또는 패턴이 정확히 *num* 회 또는 그 이상 일치             |
+----------------+-------------------------------------------------------------------------+
| {*min,max*}    | 선행하는 문자 또는 패턴이 최소 *min* 회 일치하지만 *max*를 넘지 않음    |
+----------------+-------------------------------------------------------------------------+

.. code-block:: sql

    -- a+ : 하나 이상의 a 문자 시퀀스와 일치. 대소문자 구분하지 않음.
    SELECT ('Aaaapricot' REGEXP '^A+pricot');
    
::

    ('Aaaapricot' regexp '^A+pricot')
    ================================
      1

.. code-block:: sql

    -- a? : 0 또는 1개의 문자와 일치
    SELECT ('Apricot' REGEXP '^Aa?pricot');
    
::

    ('Apricot' regexp '^Aa?pricot')
    ==========================
      1
    
.. code-block:: sql

    SELECT ('Aapricot' REGEXP '^Aa?pricot');
    
::

    ('Aapricot' regexp '^Aa?pricot')
    ===========================
      1
     
.. code-block:: sql

    SELECT ('Aaapricot' REGEXP '^Aa?pricot');
    
::

    ('Aaapricot' regexp '^Aa?pricot')
    ============================
      0

.. code-block:: sql

    -- (cub)* : 시퀀스 abc의 0개 이상의 인스턴스와 일치
    SELECT ('cubcub' REGEXP '^(cub)*$');
    
::

    ('cubcub' regexp '^(cub)*$')
    ==========================
      1

기본적으로 이러한 모든 수량자는 가능한 한 조건을 충족하는 많은 문자를 사용하는 *greedy* 방식으로 수행된다.
그리고 이 동작은 한정자 뒤에 물음표(?)를 추가하여 *non-greedy*로 재정의할 수 있다.

.. code-block:: sql

    -- (a+), (a+?) : greedy 또는 non-greedy로 수량자를 사용해 각각 매칭 수행.
    SELECT REGEXP_SUBSTR ('aardvark', '(a+)'), REGEXP_SUBSTR ('aardvark', '(a+?)');
    
::

    regexp_substr('aardvark', '(a+)')  regexp_substr('aardvark', '(a+?)')
    ============================================
      'aa'                  'a'

그룹
------

그룹을 사용하면 단일 문자 대신 일련의 문자에 레이블 (예 $1)을 적용할 수 있다. 두 종류의 그룹이 있다.

+--------------------+-------------------------------------------------------+
| 문자               | 설명                                                  |
+====================+=======================================================+
| (\ *subpattern*)   | 역참조를 생성하는 그룹                                |
+--------------------+-------------------------------------------------------+
| (?:\ *subpattern*) | 역참조를 생성하지 않는 패시브 그룹                    |
+--------------------+-------------------------------------------------------+

.. code-block:: sql

    -- 캡쳐된 그룹은 $int로 참조할 수 있다
    SELECT REGEXP_REPLACE ('hello cubrid','([[:alnum:]]+)','$1!');

::

    regexp_replace('hello cubrid','([[:alnum:]]+)','$1!')
    ==========================
      'hello! cubrid!'

그룹이 역참조를 생성하면, 문자열에서 하위 패턴을 나타내는 문자가 하위 일치로 저장된다. 각 하위 일치 항목은 여는 괄호가 나타나는 순서에 따라 번호가 매겨진다 (첫 번째 하위 일치 항목은 1번, 두 번째 하위 일치 항목은 2번 등...).
이러한 하위 일치는 전체 하위 패턴이 다른 곳에 다시 나타나도록 지정하기 위해 정규식 자체에서 사용할 수 있는데 (특수 문자 목록의 \int 참조), REGEXP_REPLACE 함수의 대체 문자열에서 사용할 수 있다.

.. code-block:: sql

    -- 그룹 없이 regexp_substr을 수행한다. 다음은 완전히 일치하는 경우이다.
    SELECT REGEXP_SUBSTR ('abckabcjabc', '[a-c]{3}k[a-c]{3}j[a-c]{3}');

    -- ([a-c]{3}) 는 \1 역참조를 생성한다
    SELECT REGEXP_SUBSTR ('abckabcjabc', '([a-c]{3})k\1j\1');

::

    regexp_substr('abckabcjabc', '[a-c]{3}k[a-c]{3}j[a-c]{3}')
    ======================
      'abckabcjabc'

    regexp_substr('abckabcjabc', '([a-c]{3})k\1j\1')
    ======================
      'abckabcjabc'

어서션
----------

어서션은 문자열의 문자를 사용하지 않는 조건이다. 즉, 문자를 나타내지는 않지만 문자의 앞이나 뒤에 충족되어야 하는 조건이다.

+-----------------+-----------------------------------------------------------------------------------------------------------------------+
| 문자            | 설명                                                                                                                  |
+=================+=======================================================================================================================+
| ^               | 문자열의 시작이나 행 종결자 다음                                                                                      |
+-----------------+-----------------------------------------------------------------------------------------------------------------------+
| $               | 문자열의 끝이나 행 종결자 이전                                                                                        |
+-----------------+-----------------------------------------------------------------------------------------------------------------------+
| \\b             | 이전 문자는 단어 문자이고 다음 문자는 단어가 아닌 문자(또는 그 반대)                                                  |
+-----------------+-----------------------------------------------------------------------------------------------------------------------+
| \\B             | 이전 및 다음 문자는 모두 단어 문자이거나 둘 다 단어가 아닌 문자                                                       |
+-----------------+-----------------------------------------------------------------------------------------------------------------------+
| (?=subpattern)  | Positive lookahead. 이 문자 다음의 문자열은 하위 패턴과 일치해야 하지만 어떤 문자도 소비되지 않음                     |
+-----------------+-----------------------------------------------------------------------------------------------------------------------+
| (?!subpattern)  | Negative lookahead. 어서션 다음의 문자열은 하위 패턴과 일치하지 않아야 하지만 어떤 문자도 소비되지 않음               |
+-----------------+-----------------------------------------------------------------------------------------------------------------------+

.. code-block:: sql

    -- ^ : 문자열의 시작과 매칭
    SELECT ('cubrid dbms' REGEXP '^cub');
    
::

    ('cubrid dbms' regexp '^cub')
    ===============================
      1

.. code-block:: sql

    -- $ : 문자열의 끝과 매칭
    SELECT ('this is cubrid dbms' REGEXP 'dbms$');
    
::

    ('this is cubrid dbms' regexp 'dbms$')
    ========================================
      1

.. code-block:: sql

    -- (?=subpattern): positive lookahead
    SELECT REGEXP_REPLACE ('cubrid dbms cubrid sql cubrid rdbms', 'cubrid(?= sql)', 'CUBRID');

    -- (?!subpattern): nagative lookahead
    SELECT REGEXP_REPLACE ('cubrid dbms cubrid sql cubrid rdbms', 'cubrid(?! sql)', 'CUBRID');
    
::

   regexp_replace('cubrid dbms cubrid sql cubrid rdbms', 'cubrid(?= sql)', 'CUBRID')
   ======================
     'cubrid dbms CUBRID sql cubrid rdbms'

   regexp_replace('cubrid dbms cubrid sql cubrid rdbms', 'cubrid(?! sql)', 'CUBRID')
   ======================
     'CUBRID dbms cubrid sql CUBRID rdbms'

구분자
------------

패턴에 여러 구분자를 포함할 수 있다:

+-----------------+------------------------------------------------------+
| 문자            | 설명                                                 |
+=================+======================================================+
| \|              | 두 개의 대체 패턴 또는 하위 패턴을 분리              |
+-----------------+------------------------------------------------------+

.. code-block:: sql

    -- a|b : a 또는 b인 모든 문자열 매칭
    SELECT ('a' REGEXP 'a|b');
    SELECT ('d' REGEXP 'a|b');
    
::

    ('a' regexp 'a|b')
    ==============================
      1

    ('d' regexp 'a|b')
    ==============================
      0

정규식은 구분자 연산자(alternatvies, |)로 간단히 구분하여 여러 대체 패턴을 포함할 수 있다.
정규식은 대체 패턴이 일치하는 경우 일치하는 즉시 매칭한다.
하위 패턴(그룹 또는 어서션)은 구분자 연산자를 사용하여 여러 다른 패턴을 구분할 수도 있다.

.. code-block:: sql

    -- a|b|c : matches any character that is either a, b or c.
    SELECT ('a' REGEXP 'a|b|c');
    SELECT ('d' REGEXP 'a|b|c');
    
::

    ('a' regexp 'a|b|c')
    ==============================
      1

    ('d' regexp 'a|b|c')
    ==============================
      0

문자 클래스
-----------------

문자 클래스 문법은 문자 하나 또는 대괄호 내의 문자 범주와 매칭한다.

**개별 문자**

지정된 모든 문자는 클래스의 일부로 간주된다 (\\, [, ] 제외).

.. code-block:: sql

    -- [abc] : a, b 또는 c인 모든 문자와 일치.
    SELECT ('a' REGEXP '[abc]');
    SELECT ('d' REGEXP '[abc]');
    
::

    ('a' regexp '[abc]')
    ==============================
      1

    ('d' regexp '[abc]')
    ==============================
      0

**범위**

문자 범위를 나타내기 위해 유효한 두 문자 사이에 대시 문자(-)를 사용한다.
예를 들어 "[a-z]"는 모든 알파벳 문자와 일치하지만 "[0-9]"는 단일 숫자와 일치한다.

.. code-block:: sql

    SELECT ('adf' REGEXP '[a-f]');
    SELECT ('adf' REGEXP '[g-z]');
    
::

    ('adf' regexp '[a-f]')
    ================================
      1

    ('adf' regexp '[g-z]')
    ================================
      0

.. code-block:: sql

    -- [0-9]+: 문자열의 숫자 시퀀스와 일치
    SELECT REGEXP_SUBSTR ('aas200gjb', '[0-9]+');
    
::

    regexp_substr('aas200gjb', '[0-9]+')
    ======================
      '200'

.. code-block:: sql

    SELECT ('strike' REGEXP '^[^a-dXYZ]+$');
    
::

    ('strike' regexp '^[^a-dXYZ]+$')
    ================================
      1

**POSIX 기반 문자 클래스**

POSIX 기반 문자 클래스(*[:classname:]*)는 아래와 같이 문자의 범주를 정의한다. [:d:], [:w:] 및 [:s:]는 ECMAScript 문법의 확장이다.

+------------+-----------------------------------------+
| Class      | Description                             |
+============+=========================================+
| [:alnum:]  | 영숫자 문자                             |
+------------+-----------------------------------------+
| [:alpha:]  | 알파벳 문자                             |
+------------+-----------------------------------------+
| [:blank:]  | 빈 문자                                 |
+------------+-----------------------------------------+
| [:cntrl:]  | 제어 문자                               |
+------------+-----------------------------------------+
| [:digit:]  | 십진수 문자                             |
+------------+-----------------------------------------+
| [:graph:]  | 표시할 수 있는 문자                     |
+------------+-----------------------------------------+
| [:lower:]  | 소문자                                  |
+------------+-----------------------------------------+
| [:print:]  | 인쇄 가능한 문자                        |
+------------+-----------------------------------------+
| [:punct:]  | 구두점 문자                             |
+------------+-----------------------------------------+
| [:space:]  | 공백 문자                               |
+------------+-----------------------------------------+
| [:upper:]  | 대문자                                  |
+------------+-----------------------------------------+
| [:xdigit:] | 16진수 문자                             |
+------------+-----------------------------------------+
| [:d:]      | 숫자 (0-9)                              |
+------------+-----------------------------------------+
| [:w:]      | 단어                                    |
+------------+-----------------------------------------+
| [:s:]      | 공백                                    |
+------------+-----------------------------------------+

.. code-block:: sql

    SELECT REGEXP_SUBSTR ('Samseong-ro 86-gil, Gangnam-gu, Seoul 06178', '[[:digit:]]{5}');
    
::

    regexp_substr('Samseong-ro 86-gil, Gangnam-gu, Seoul 06178', '[[:digit:]]{5}')
    ================================
      '06178'

.. code-block:: sql

    SET NAMES utf8 COLLATE utf8_ko_cs;
    SELECT REGEXP_REPLACE ('가나다 가나 가나다라', '\b[[:alpha:]]{2}\b', '#');
    
::

    regexp_replace('가나다 가나 가나다라', '\b[[:alpha:]]{2}\b', '#')
    ======================
      '가나다 # 가나다라'

.. _regex-rlike:

REGEXP, RLIKE
=============

**REGEXP**, **RLIKE**\ 는 동일한 의미로 사용되며, 정규 표현식을 이용한 패턴을 매칭한다. 아래의 문법에서, *expression*이 *pattern*과 일치하면 1을 반환한다. 그렇지 않으면 0을 반환한다.
*expression* 또는 *pattern*이 **NULL**이면 **NULL**을 반환한다. 두 번째 구문은 두 구문 모두 **NOT**을 사용하는 세 번째 구문과 동일한 의미를 갖는다.

::

    expression REGEXP | RLIKE [BINARY] pattern
    expression NOT REGEXP | RLIKE pattern
    NOT (expression REGEXP | RLIKE pattern)

*   *expression* : 칼럼 또는 입력 표현식
*   *pattern* : 정규 표현식에 사용될 패턴. 대소문자 구분 없음

**REGEXP**\ 와 **LIKE**\ 의 차이는 다음과 같다.

* **LIKE** 절은 입력값 전체가 패턴과 매칭되어야 성공한다.
* **REGEXP**\ 는 입력값의 일부가 패턴과 매칭되면 성공한다. **REGEXP**\ 에서 전체 값에 대한 패턴 매칭을 하려면, 패턴의 시작에는 "^"을, 끝에는 "$"을 사용해야 한다.
* **LIKE** 절의 패턴은 대소문자를 구분하지만 **REGEXP**\ 에서 정규 표현식의 패턴은 대소문자를 구분하지 않는다. 대소문자를 구분하려면 **REGEXP BINARY** 구문을 사용해야 한다.
* **REGEXP**, **REGEXP BINARY**\ 는 피연산자의 콜레이션을 고려하지 않고 ASCII 인코딩으로 동작한다.

.. code-block:: sql

    -- [a-dX], [^a-dX] : a, b, c, d 또는 X인 모든 문자와 매칭됨.
    SELECT ('aXbc' REGEXP '[a-dX]');

::
    
    ('aXbc' regexp '[a-dX]')
    ==============================
    1

.. code-block:: sql

    -- SELECT 리스트에서 REGEXP를 사용하는 경우 괄호로 묶어야 한다.
    -- 단, WHERE 절에서는 괄호가 필요하지 않다.
    -- BINARY와 함께 사요하는 경우를 제외하고 대소문자를 구분하지 않는다.
    SELECT name FROM athlete where name REGEXP '^[a-d]';

::
    
    name
    ======================
    'Dziouba Irina'
    'Dzieciol Iwona'
    'Dzamalutdinov Kamil'
    'Crucq Maurits'
    'Crosta Daniele'
    'Bukovec Brigita'
    'Bukic Perica'
    'Abdullayev Namik'

.. _regex-count:

REGEXP_COUNT
============

.. function:: REGEXP_COUNT (string, pattern_string [, position [, match_type]])

    **REGEXP_COUNT** 함수는 주어진 문자열 *string* 내에서 정규식 패턴 *pattern_string*의 매칭 횟수를 반환한다. **NULL**\이 인수로 지정된 경우 **NULL**\을 반환한다.

    :param string: 입력 문자열을 지정한다. 값이 **NULL**\이면 **NULL**\을 반환한다
    :param pattern_string: 매칭을 수행할 정규식 패턴 문자열을 지정한다. 값이 **NULL**\이면 **NULL**\을 반환한다.
    :param position: 매칭을 수행할 *string*\의 위치를 지정한다. 값을 생략하면 기본값 1이 적용된다. 값이 음수이거나 0이면 에러를 반환한다. 값이 **NULL**\이면 **NULL**\을 반환한다
    :param match_type: 함수의 매칭 옵션을 설정할 문자열을 지정한다.  값을 생략하면 기본값 'i'가 적용된다. 값이 'c' 또는 'i'가 아닌 경우 에러를 반환한다. 값이 **NULL**\이면 **NULL**\을 반환한다.
    :rtype: INT

.. code-block:: sql

    -- 인수가 NULL 값으로 지정되면 NULL을 반환한다
    SELECT REGEXP_COUNT('ab123ab111a','[a-d]+',NULL);
    
::

    regexp_count('ab123ab111a','[a-d]+',NULL)
    ======================
      NULL

.. code-block:: sql

    -- 빈 문자열 패턴은 어떤 문자열과도 일치하지 않는다
    SELECT REGEXP_COUNT('ab123ab111a','');
    
::

    regexp_count('ab123ab111a','')
    ======================
      0

.. code-block:: sql

    SELECT REGEXP_COUNT('ab123Ab111aAA','[a-d]', 3);
    
::

    regexp_count('ab123Ab111aAA', '[a-d]', 3)
    ===========================================
                                            5

.. code-block:: sql

    -- 대소문자 구분 안함 옵션('i')이 기본값이다
    SELECT REGEXP_COUNT('ab123Ab111aAA','[a-d]', 3, 'i');

    -- 대소문자 구분 옵션('c')이 match_type으로 지정된 경우 A는 매칭되지 않는다.
    SELECT REGEXP_COUNT('ab123Ab111aAA','[a-d]', 3, 'c');
    
    
::

    regexp_count('ab123Ab111aAA', '[a-d]', 3, 'i')
    ================================================
                                                 5

    regexp_count('ab123Ab111aAA', '[a-d]', 3, 'c')
    ================================================
                                                 2

.. code-block:: sql

    SET NAMES utf8 COLLATE utf8_ko_cs;
    SELECT REGEXP_COUNT('가나123abc가다abc가가','[가-나]+');
    
::

    regexp_count('가나123abc가다abc가가','[가-나]+')
    ======================
      2


.. _regex-instr:

REGEXP_INSTR
============

.. function:: REGEXP_INSTR (string, pattern_string [, position [, occurrence [, return_option [, match_type]]]])

    **REGEXP_INSTR** 함수는 주어진 문자열 *string* 내에서 정규식 패턴 *pattern_string*을 검색하여 시작 위치 또는 끝 위치를 반환한다. **NULL**\이 인수로 지정된 경우 **NULL**\을 반환한다.

    :param string: 입력 문자열을 지정한다. 값이 **NULL**\이면 **NULL**\을 반환한다
    :param pattern_string: 매칭을 수행할 정규식 패턴 문자열을 지정한다. 값이 **NULL**\이면 **NULL**\을 반환한다.
    :param position: 매칭을 수행할 *string*\의 위치를 지정한다. 값을 생략하면 기본값 1이 적용된다. 값이 음수이거나 0이면 에러를 반환한다. 값이 **NULL**\이면 **NULL**\을 반환한다
    :param occurrence: 몇 번째 매칭을 사용할 지 지정한다. 값을 생략하면 기본값 1을 적용한다. 값을 생략하면 기본값 1이 적용된다. 값이 음수이면 에러를 반환한다. 값이 **NULL**\이면 **NULL**\을 반환한다.
    :param return_option: 일치하는 문자열의 시작 또는 끝 지점 중 어떤 위치를 반환할지 여부를 지정한다. 만약 값이 0이면 일치하는 문자의 시작 위치를 반환한다. 값이 1이면 일치하는 문자의 끝 위치를 반환한다. 값을 생략하면 기본값 0이 적용된다. 값이 0 또는 1이 아닌 경우 에러를 반환한다. 값이 **NULL**\이면 **NULL**\을 반환한다.
    :param match_type: 함수의 매칭 옵션을 설정할 문자열을 지정한다.  값을 생략하면 기본값 'i'가 적용된다. 값이 'c' 또는 'i'가 아닌 경우 에러를 반환한다. 값이 **NULL**\이면 **NULL**\을 반환한다.
    :rtype: INT

.. code-block:: sql

    -- 인수가 NULL 값으로 지정되면 NULL을 반환한다
    SELECT REGEXP_INSTR('12345abcdeabcde','[abc]',NULL);
    
::

    regexp_instr('12345abcdeabcde', '[abc]', null)
    ======================
      NULL

.. code-block:: sql

    -- 빈 문자열 패턴은 어떤 문자열과도 일치하지 않는다
    SELECT REGEXP_INSTR('12345abcdeabcde','');
    
::

    regexp_instr('12345abcdeabcde', '')
    ======================
      0

.. code-block:: sql

    -- 매칭되는 첫 번째 문자의 위치를 반환한다
    SELECT REGEXP_INSTR('12354abc5','[:alpha:]+',1,1,0);
    
::

    regexp_instr('12354abc5','[:alpha:]+', 1, 1, 0);
    ======================
      6


.. code-block:: sql

    -- 매칭 후 일치하는 문자열의 위치를 반환한다
    SELECT REGEXP_INSTR('12354abc5','[:alpha:]+',1,1,1);
    
::

    regexp_instr('12354abc5','[:alpha:]+', 1, 1, 1);
    ======================
      9

.. code-block:: sql

    SET NAMES utf8 COLLATE utf8_ko_cs;
    SELECT REGEXP_INSTR('12345가나다라마가나다라마바','[가-다]+');
    
::

    regexp_instr('12345가나다라마가나다라마바','[가-다]+');
    ======================
      6

.. _regex-like:

REGEXP_LIKE
===========

.. function:: REGEXP_LIKE (string, pattern_string [, match_type])

    **REGEXP_LIKE** 함수는 주어진 문자열 *string* 내에서 정규식 패턴 *pattern_string*을 검색한다. 정규식 패턴이 *pattern_string*의 어느 곳에서나 일치하면 1이 반환된다. 그렇지 않으면 0이 반환된다. **NULL**\이 인수로 지정된 경우 **NULL**\을 반환한다.

    :param string: 입력 문자열을 지정한다. 값이 **NULL**\이면 **NULL**\을 반환한다
    :param pattern_string: 매칭을 수행할 정규식 패턴 문자열을 지정한다. 값이 **NULL**\이면 **NULL**\을 반환한다.
    :param match_type: 함수의 매칭 옵션을 설정할 문자열을 지정한다.  값을 생략하면 기본값 'i'가 적용된다. 값이 'c' 또는 'i'가 아닌 경우 에러를 반환한다. 값이 **NULL**\이면 **NULL**\을 반환한다.
    :rtype: INT

.. code-block:: sql

    SELECT REGEXP_LIKE('abbbbc','ab+c');
    
::

    regexp_like('abbbbc', 'ab+c');
    ======================
      1

.. code-block:: sql

    -- 빈 문자열 패턴은 어떤 문자열과도 일치하지 않는다
    SELECT REGEXP_LIKE('abbbbc','');
    
::

    regexp_like('abbbbc', '');
    ======================
      0

.. code-block:: sql

    SELECT REGEXP_LIKE('abbbbc','AB+C', 'c');
    
::

    regexp_like('abbbbc', 'AB+C');
    ======================
      0

.. code-block:: sql

    SET NAMES utf8 COLLATE utf8_ko_cs;
    SELECT REGEXP_LIKE('가나다','가나?다');
    SELECT REGEXP_LIKE('가나라다','가나?다');
    
::

    regexp_like('가나다', '가나?다')
    ===============================
      1

    regexp_like('가나라다, '가나?다')
    ================================
      0

.. _regex-replace:

REGEXP_REPLACE
==============

.. function:: REGEXP_REPLACE (string, pattern_string, replacement_string [, position [, occurrence [, match_type]]])

    **REGEXP_REPLACE** 함수는 주어진 문자열 *string* 내에서 정규식 패턴 *pattern_string*을 검색하여 문자열 *replacement_string*으로 바꾼다. **NULL**이 인수로 지정된 경우 **NULL**을 반환한다.

    :param string: 입력 문자열을 지정한다. 값이 **NULL**\이면 **NULL**\을 반환한다
    :param pattern_string: 매칭을 수행할 정규식 패턴 문자열을 지정한다. 값이 **NULL**\이면 **NULL**\을 반환한다.
    :param replacement_string: Specifies the string to replace the matched string by *pattern_string*. 값이 **NULL**\이면 **NULL**\을 반환한다.
    :param position: 매칭을 수행할 *string*\의 위치를 지정한다. 값을 생략하면 기본값 1이 적용된다. 값이 음수이거나 0이면 에러를 반환한다. 값이 **NULL**\이면 **NULL**\을 반환한다
    :param occurrence: 몇 번째 매칭을 사용할 지 지정한다. 값을 생략하면 기본값 1을 적용한다. 만약 값을 생략하면 기본값 0이 적용된다. 값이 음수이면 에러를 반환한다. 값이 **NULL**\이면 **NULL**\을 반환한다.
    :param match_type: 함수의 매칭 옵션을 설정할 문자열을 지정한다.  값을 생략하면 기본값 'i'가 적용된다. 값이 'c' 또는 'i'가 아닌 경우 에러를 반환한다. 값이 **NULL**\이면 **NULL**\을 반환한다.
    :rtype: STRING

.. code-block:: sql

    -- 인수가 NULL 값으로 지정되면 NULL을 반환한다
    SELECT REGEXP_REPLACE('12345abcdeabcde','[a-d]',NULL);
    
::

    regexp_replace('12345abcdeabcde', '[a-d]', null)
    ======================
    NULL

.. code-block:: sql

    -- 빈 문자열 패턴은 어떤 문자열과도 일치하지 않는다
    SELECT REGEXP_REPLACE('12345abcdeabcde','','#');
    
::

    regexp_replace('12345abcdeabcde', '', '#')
    ======================
      '12345abcdeabcde'

.. code-block:: sql

    SELECT REGEXP_REPLACE('12345abDEKBcde','[a-d]','#');
    
::

    regexp_replace('12345abDEKBcde', '[a-d]', '#')
    ======================
      '12345###EK###e'

.. code-block:: sql

    -- 대소문자 구분 안함 옵션('i')이 기본값이다
    SELECT REGEXP_REPLACE('12345abDEKBcde','[a-d]','#', 1, 0, 'i');

    -- 대소문자 구분 옵션('c')이 match_type으로 지정된 경우 'B' 와 'D'는 매칭되지 않는다.
    SELECT REGEXP_REPLACE('12345abDEKBcde','[a-d]','#', 1, 0, 'c');
    
::

    regexp_replace('12345abDEKBcde', '[a-d]', '#', 1, 0, 'i')
    ======================
      '12345###EK###e'


    regexp_replace('12345abDEKBcde', '[a-d]', '#', 1, 0, 'c')
    ======================
      '12345##DEKB##e'

.. code-block:: sql

    SET NAMES utf8 COLLATE utf8_ko_cs;
    SELECT REGEXP_REPLACE('a1가b2나다라','[가-다]','#',6);
    
::

    regexp_replace('a1가b2나다라', '[가-다]', '#', 6);
    ======================
      'a1가b2##라'

.. _regex-substr:

REGEXP_SUBSTR
=============

.. function:: REGEXP_SUBSTR (string, pattern_string [, position [, occurrence [, match_type]]])

    **REGEXP_SUBSTR** 함수는 주어진 문자열 *string* 내에서 정규식 패턴 *pattern_string*에 일치하는 문자열을 추출한다. **NULL**\이 인수로 지정된 경우 **NULL**\을 반환한다.

    :param string: 입력 문자열을 지정한다. 값이 **NULL**\이면 **NULL**\을 반환한다
    :param pattern_string: 매칭을 수행할 정규식 패턴 문자열을 지정한다. 값이 **NULL**\이면 **NULL**\을 반환한다.
    :param position: 매칭을 수행할 *string*\의 위치를 지정한다. 값을 생략하면 기본값 1이 적용된다. 값이 음수이거나 0이면 에러를 반환한다. 값이 **NULL**\이면 **NULL**\을 반환한다
    :param occurrence: 몇 번째 매칭을 사용할 지 지정한다. 값을 생략하면 기본값 0을 적용한다. 이 의미는 발생하는 모든 매칭을 사용한다는 의미이다. 값이 음수이면 에러를 반환한다. 값이 **NULL**\이면 **NULL**\을 반환한다.
    :param match_type: 함수의 매칭 옵션을 설정할 문자열을 지정한다. 값을 생략하면 기본값 'i'가 적용된다. 값이 'c' 또는 'i'가 아닌 경우 에러를 반환한다. 값이 **NULL**\이면 **NULL**\을 반환한다.
    :rtype: STRING

.. code-block:: sql

    -- 만약 패턴이 매칭되지 않으면, NULL을 반환한다
    SELECT REGEXP_SUBSTR('12345abcdeabcde','[k-z]+');
    
::

    regexp_substr('12345abcdeabcde','[k-z]+');
    ======================
      NULL

.. code-block:: sql

    -- 빈 문자열 패턴은 어떤 문자열과도 일치하지 않는다
    SELECT REGEXP_SUBSTR('12345abcdeabcde','');
    
::

    regexp_substr('12345abcdeabcde', '')
    ======================
      NULL

.. code-block:: sql

    SELECT REGEXP_SUBSTR('Samseong-ro, Gangnam-gu, Seoul',',[^,]+,');
    
::

    regexp_substr('Samseong-ro, Gangnam-gu, Seoul', ',[^,]+,')
    ======================
      ', Gangnam-gu,'
     
.. code-block:: sql

    SET NAMES utf8 COLLATE utf8_ko_cs;
    SELECT REGEXP_SUBSTR('삼성로, 강남구, 서울특별시','[[:alpha:]]+',1,2);
    
::

    regexp_substr('삼성로, 강남구, 서울특별시', [[:alpha:]]+', 1, 2);
    ======================
      '강남구'
